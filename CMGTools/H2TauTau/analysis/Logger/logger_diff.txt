 .../python/proto/samples/run2012/diboson.py        |   32 +-
 .../H2TauTau/python/proto/samples/run2012/ewk.py   |   35 +-
 .../python/proto/samples/run2012/tauMu_JanAug06.py |   17 +-
 CMGTools/H2TauTau/python/triggerMap.py             |   42 +
 .../python/analyzers/DiTriggerAnalyzer.py          |   15 +-
 .../python/physicsobjects/ElectronCalibrator.py    |   22 -
 .../python/physicsobjects/HTauTauElectron.py       |   45 +-
 .../python/physicsobjects/JetReCalibrator.py       |   68 -
 CMGTools/RootTools/python/physicsobjects/Lepton.py |    2 +
 .../python/physicsobjects/MuScleFitCorrector.py    |   26 -
 CMGTools/RootTools/python/physicsobjects/Muon.py   |    7 +-
 CMGTools/RootTools/python/physicsobjects/Tau.py    |   18 +
 PhysicsTools/PatAlgos/BuildFile.xml                |   23 -
 PhysicsTools/PatAlgos/doc/html/index.html          |   11 -
 PhysicsTools/PatAlgos/doc/html/overview.html       |   12 -
 PhysicsTools/PatAlgos/interface/BaseIsolator.h     |   43 -
 PhysicsTools/PatAlgos/interface/EfficiencyLoader.h |   50 -
 PhysicsTools/PatAlgos/interface/HemisphereAlgo.h   |  101 --
 .../PatAlgos/interface/IsoDepositIsolator.h        |   35 -
 .../PatAlgos/interface/KinResolutionsLoader.h      |   58 -
 .../interface/KinematicResolutionProvider.h        |   32 -
 .../PatAlgos/interface/KinematicResolutionRcd.h    |   32 -
 PhysicsTools/PatAlgos/interface/MultiIsolator.h    |   91 --
 PhysicsTools/PatAlgos/interface/OverlapTest.h      |   91 --
 .../PatAlgos/interface/PATPrimaryVertexSelector.h  |   55 -
 .../PatAlgos/interface/PATUserDataHelper.h         |  167 ---
 .../PatAlgos/interface/PATUserDataMerger.h         |  159 ---
 PhysicsTools/PatAlgos/interface/SimpleIsolator.h   |   25 -
 .../PatAlgos/interface/StringResolutionProvider.h  |   69 -
 PhysicsTools/PatAlgos/interface/VertexingHelper.h  |  113 --
 PhysicsTools/PatAlgos/plugins/BuildFile.xml        |   28 -
 .../PatAlgos/plugins/CandidateSummaryTable.cc      |  139 --
 .../PatAlgos/plugins/DuplicatedElectronCleaner.cc  |   94 --
 .../PatAlgos/plugins/JetCorrFactorsProducer.cc     |  286 ----
 .../PatAlgos/plugins/JetCorrFactorsProducer.h      |  134 --
 PhysicsTools/PatAlgos/plugins/ObjectEnergyScale.cc |   23 -
 PhysicsTools/PatAlgos/plugins/ObjectEnergyScale.h  |  159 ---
 .../PatAlgos/plugins/ObjectSpatialResolution.cc    |   24 -
 .../PatAlgos/plugins/ObjectSpatialResolution.h     |  177 ---
 PhysicsTools/PatAlgos/plugins/PATCleaner.cc        |   23 -
 PhysicsTools/PatAlgos/plugins/PATCleaner.h         |  141 --
 .../plugins/PATCompositeCandidateProducer.cc       |   89 --
 .../plugins/PATCompositeCandidateProducer.h        |   68 -
 .../PatAlgos/plugins/PATConversionProducer.cc      |  120 --
 .../PatAlgos/plugins/PATConversionProducer.h       |   57 -
 .../PatAlgos/plugins/PATElectronProducer.cc        | 1126 ----------------
 .../PatAlgos/plugins/PATElectronProducer.h         |  175 ---
 .../plugins/PATGenCandsFromSimTracksProducer.cc    |  354 -----
 .../PatAlgos/plugins/PATGenericParticleProducer.cc |  197 ---
 .../PatAlgos/plugins/PATGenericParticleProducer.h  |   90 --
 .../PatAlgos/plugins/PATHeavyIonProducer.cc        |  131 --
 .../PatAlgos/plugins/PATHemisphereProducer.cc      |  209 ---
 .../PatAlgos/plugins/PATHemisphereProducer.h       |   91 --
 PhysicsTools/PatAlgos/plugins/PATJetProducer.cc    |  478 -------
 PhysicsTools/PatAlgos/plugins/PATJetProducer.h     |  108 --
 PhysicsTools/PatAlgos/plugins/PATJetSelector.h     |  209 ---
 .../PatAlgos/plugins/PATLeptonCountFilter.cc       |   50 -
 .../PatAlgos/plugins/PATLeptonCountFilter.h        |   44 -
 PhysicsTools/PatAlgos/plugins/PATMETProducer.cc    |  144 --
 PhysicsTools/PatAlgos/plugins/PATMETProducer.h     |   73 -
 PhysicsTools/PatAlgos/plugins/PATMHTProducer.cc    |  511 -------
 PhysicsTools/PatAlgos/plugins/PATMHTProducer.h     |  186 ---
 PhysicsTools/PatAlgos/plugins/PATMuonProducer.cc   |  646 ---------
 PhysicsTools/PatAlgos/plugins/PATMuonProducer.h    |  159 ---
 PhysicsTools/PatAlgos/plugins/PATObjectFilter.cc   |    6 -
 PhysicsTools/PatAlgos/plugins/PATObjectFilter.h    |   24 -
 PhysicsTools/PatAlgos/plugins/PATObjectSelector.cc |   28 -
 PhysicsTools/PatAlgos/plugins/PATObjectSelector.h  |  125 --
 .../PatAlgos/plugins/PATPFParticleProducer.cc      |  149 --
 .../PatAlgos/plugins/PATPFParticleProducer.h       |   77 --
 PhysicsTools/PatAlgos/plugins/PATPhotonProducer.cc |  269 ----
 PhysicsTools/PatAlgos/plugins/PATPhotonProducer.h  |   84 --
 .../PatAlgos/plugins/PATPrimaryVertexCleaner.cc    |    7 -
 .../PatAlgos/plugins/PATSingleVertexSelector.cc    |  171 ---
 .../PatAlgos/plugins/PATSingleVertexSelector.h     |   65 -
 PhysicsTools/PatAlgos/plugins/PATTauProducer.cc    |  478 -------
 PhysicsTools/PatAlgos/plugins/PATTauProducer.h     |  113 --
 .../PatAlgos/plugins/PATTriggerEventProducer.cc    |  291 ----
 .../PatAlgos/plugins/PATTriggerEventProducer.h     |   83 --
 .../PatAlgos/plugins/PATTriggerMatchEmbedder.cc    |  122 --
 .../PatAlgos/plugins/PATTriggerMatchSelector.h     |   53 -
 PhysicsTools/PatAlgos/plugins/PATTriggerMatcher.cc |   87 --
 .../PatAlgos/plugins/PATTriggerProducer.cc         |  979 --------------
 PhysicsTools/PatAlgos/plugins/PATTriggerProducer.h |  134 --
 .../plugins/StringResolutionProviderESProducer.cc  |   33 -
 .../PatAlgos/plugins/TauJetCorrFactorsProducer.cc  |  150 ---
 .../PatAlgos/plugins/TauJetCorrFactorsProducer.h   |   93 --
 .../PatAlgos/plugins/VertexAssociationProducer.cc  |  100 --
 .../cleaningLayer1/cleanPatCandidates_cff.py       |   31 -
 .../python/cleaningLayer1/electronCleaner_cfi.py   |   25 -
 .../cleaningLayer1/genericTrackCleaner_cfi.py      |   35 -
 .../python/cleaningLayer1/jetCleaner_cfi.py        |   59 -
 .../python/cleaningLayer1/muonCleaner_cfi.py       |   14 -
 .../python/cleaningLayer1/photonCleaner_cfi.py     |   24 -
 .../python/cleaningLayer1/tauCleaner_cfi.py        |   38 -
 .../PatAlgos/python/famos/boostrapWithFamos_cff.py |   21 -
 .../python/mcMatchLayer0/electronMatch_cfi.py      |   19 -
 .../python/mcMatchLayer0/jetFlavourId_cff.py       |   21 -
 .../PatAlgos/python/mcMatchLayer0/jetMatch_cfi.py  |   30 -
 .../python/mcMatchLayer0/mcMatchSequences_cff.py   |   27 -
 .../PatAlgos/python/mcMatchLayer0/muonMatch_cfi.py |   19 -
 .../python/mcMatchLayer0/photonMatch_cfi.py        |   20 -
 .../PatAlgos/python/mcMatchLayer0/tauMatch_cfi.py  |   31 -
 .../python/mcMatchLayer0/trackMuMatch_cfi.py       |   19 -
 .../PatAlgos/python/patEventContent_cff.py         |   91 --
 .../PatAlgos/python/patHeavyIonSequences_cff.py    |   14 -
 PhysicsTools/PatAlgos/python/patInputFiles_cff.py  |   30 -
 PhysicsTools/PatAlgos/python/patSequences_cff.py   |   20 -
 PhysicsTools/PatAlgos/python/patTemplate_cfg.py    |   40 -
 PhysicsTools/PatAlgos/python/patTestJEC_cfi.py     |   48 -
 .../PatAlgos/python/patTestJEC_local_cfi.py        |   20 -
 .../python/producersHeavyIons/heavyIonJets_cff.py  |   19 -
 .../python/producersHeavyIons/heavyIonMuons_cff.py |   12 -
 .../heavyIonPatCandidates_cff.py                   |   13 -
 .../producersHeavyIons/heavyIonPhotons_cff.py      |   18 -
 .../producersHeavyIons/heavyIonProducer_cfi.py     |   10 -
 .../python/producersLayer1/electronProducer_cff.py |   21 -
 .../python/producersLayer1/electronProducer_cfi.py |   91 --
 .../producersLayer1/genericParticleProducer_cfi.py |   67 -
 .../producersLayer1/hemisphereProducer_cfi.py      |   24 -
 .../python/producersLayer1/jetProducer_cff.py      |   28 -
 .../python/producersLayer1/jetProducer_cfi.py      |   97 --
 .../python/producersLayer1/metProducer_cff.py      |   15 -
 .../python/producersLayer1/metProducer_cfi.py      |   47 -
 .../python/producersLayer1/mhtProducer_cff.py      |   11 -
 .../python/producersLayer1/mhtProducer_cfi.py      |   71 -
 .../python/producersLayer1/muonProducer_cff.py     |   18 -
 .../python/producersLayer1/muonProducer_cfi.py     |  114 --
 .../python/producersLayer1/patCandidates_cff.py    |   35 -
 .../producersLayer1/pfParticleProducer_cfi.py      |   46 -
 .../python/producersLayer1/photonProducer_cff.py   |   19 -
 .../python/producersLayer1/photonProducer_cfi.py   |   62 -
 .../python/producersLayer1/tauProducer_cff.py      |   57 -
 .../python/producersLayer1/tauProducer_cfi.py      |  175 ---
 .../PatAlgos/python/recoLayer0/bTagging_cff.py     |    7 -
 .../python/recoLayer0/duplicatedElectrons_cfi.py   |    8 -
 .../python/recoLayer0/duplicatedPhotons_cfi.py     |   13 -
 .../PatAlgos/python/recoLayer0/electronId_cff.py   |    7 -
 .../python/recoLayer0/electronIsolation_cff.py     |   28 -
 .../recoLayer0/genericTrackCandidates_cff.py       |   67 -
 .../python/recoLayer0/jetCorrFactors_cfi.py        |   34 -
 .../PatAlgos/python/recoLayer0/jetID_cff.py        |    5 -
 .../python/recoLayer0/jetMETCorrections_cff.py     |   19 -
 .../PatAlgos/python/recoLayer0/jetPlusTrack_cff.py |   15 -
 .../python/recoLayer0/jetTracksCharge_cff.py       |   12 -
 .../pfCandidateIsoDepositSelection_cff.py          |   12 -
 .../python/recoLayer0/photonIsolation_cff.py       |   28 -
 .../recoLayer0/stringResolutionProvider_cfi.py     |   23 -
 .../recoLayer0/stringResolutions_etEtaPhi_cff.py   |  507 -------
 .../python/recoLayer0/tauDiscriminators_cff.py     |   13 -
 .../PatAlgos/python/recoLayer0/tauIsolation_cff.py |   57 -
 .../python/recoLayer0/tauJetCorrFactors_cfi.py     |   42 -
 .../python/recoLayer0/tauJetCorrections_cff.py     |   34 -
 .../selectionLayer1/countPatCandidates_cff.py      |   17 -
 .../selectionLayer1/electronCountFilter_cfi.py     |   10 -
 .../python/selectionLayer1/electronSelector_cfi.py |   12 -
 .../python/selectionLayer1/jetCountFilter_cfi.py   |   10 -
 .../python/selectionLayer1/jetSelector_cfi.py      |   12 -
 .../selectionLayer1/leptonCountFilter_cfi.py       |   15 -
 .../python/selectionLayer1/metCountFilter_cfi.py   |   10 -
 .../python/selectionLayer1/metSelector_cfi.py      |   12 -
 .../python/selectionLayer1/muonCountFilter_cfi.py  |   10 -
 .../python/selectionLayer1/muonSelector_cfi.py     |   12 -
 .../selectionLayer1/objectEnergyScale_cfi.py       |  185 ---
 .../selectionLayer1/objectSpatialResolution_cfi.py |  139 --
 .../selectionLayer1/photonCountFilter_cfi.py       |    9 -
 .../python/selectionLayer1/photonSelector_cfi.py   |   12 -
 .../selectionLayer1/selectedPatCandidates_cff.py   |   30 -
 .../python/selectionLayer1/tauCountFilter_cfi.py   |   10 -
 .../python/selectionLayer1/tauSelector_cfi.py      |   12 -
 .../python/selectionLayer1/trackSelector_cfi.py    |   12 -
 PhysicsTools/PatAlgos/python/tools/circuitry.py    |   92 --
 .../PatAlgos/python/tools/cmsswVersionTools.py     |  442 ------
 PhysicsTools/PatAlgos/python/tools/coreTools.py    |  545 --------
 .../PatAlgos/python/tools/electronTools.py         |  156 ---
 .../PatAlgos/python/tools/heavyIonTools.py         |  198 ---
 PhysicsTools/PatAlgos/python/tools/helpers.py      |  345 -----
 PhysicsTools/PatAlgos/python/tools/jetTools.py     | 1417 --------------------
 PhysicsTools/PatAlgos/python/tools/metTools.py     |   96 --
 PhysicsTools/PatAlgos/python/tools/muonTools.py    |  151 ---
 PhysicsTools/PatAlgos/python/tools/pfTools.py      |  638 ---------
 PhysicsTools/PatAlgos/python/tools/photonTools.py  |  155 ---
 PhysicsTools/PatAlgos/python/tools/tauTools.py     |  614 ---------
 PhysicsTools/PatAlgos/python/tools/trackTools.py   |  320 -----
 PhysicsTools/PatAlgos/python/tools/trigTools.py    |  831 ------------
 .../triggerLayer1/triggerEventProducer_cfi.py      |   12 -
 .../triggerLayer1/triggerMatchEmbedder_cfi.py      |   66 -
 .../python/triggerLayer1/triggerMatcher_cfi.py     |  183 ---
 .../python/triggerLayer1/triggerProducer_cff.py    |   12 -
 .../python/triggerLayer1/triggerProducer_cfi.py    |   27 -
 PhysicsTools/PatAlgos/scripts/patReplaceFast.pl    |   92 --
 .../PatAlgos/scripts/patReplaceGenerator.sh        |  114 --
 PhysicsTools/PatAlgos/scripts/patReplaceParser.pl  |  225 ----
 PhysicsTools/PatAlgos/src/BaseIsolator.cc          |   19 -
 PhysicsTools/PatAlgos/src/EfficiencyLoader.cc      |   27 -
 PhysicsTools/PatAlgos/src/HemisphereAlgo.cc        |  393 ------
 PhysicsTools/PatAlgos/src/IsoDepositIsolator.cc    |  104 --
 PhysicsTools/PatAlgos/src/KinResolutionsLoader.cc  |   41 -
 .../PatAlgos/src/KinematicResolutionRcd.cc         |   19 -
 PhysicsTools/PatAlgos/src/MultiIsolator.cc         |   95 --
 PhysicsTools/PatAlgos/src/OverlapTest.cc           |   78 --
 .../PatAlgos/src/PATPrimaryVertexSelector.cc       |   60 -
 PhysicsTools/PatAlgos/src/PATUserDataMerger.cc     |    2 -
 PhysicsTools/PatAlgos/src/SimpleIsolator.cc        |   22 -
 .../PatAlgos/src/StringResolutionProvider.cc       |   56 -
 PhysicsTools/PatAlgos/src/VertexingHelper.cc       |   92 --
 PhysicsTools/PatAlgos/test/BuildFile.xml           |   18 -
 PhysicsTools/PatAlgos/test/IntegrationTest_cfg.py  |   84 --
 PhysicsTools/PatAlgos/test/checkPySintax           |    9 -
 PhysicsTools/PatAlgos/test/diskSize.pl             |  171 ---
 PhysicsTools/PatAlgos/test/fwlite/rootlogon.C      |  151 ---
 .../PatAlgos/test/fwlite/testSelection_electron.C  |   59 -
 .../PatAlgos/test/fwlite/testSelection_jet.C       |   59 -
 .../PatAlgos/test/fwlite/testSelection_muon.C      |   59 -
 .../PatAlgos/test/patTuple_PATandPF2PAT_cfg.py     |   95 --
 .../test/patTuple_PF2PATGsfElectrons_cfg.py        |   50 -
 .../PatAlgos/test/patTuple_PF2PATTypeIMET_cfg.py   |   97 --
 PhysicsTools/PatAlgos/test/patTuple_PF2PAT_cfg.py  |   83 --
 .../PatAlgos/test/patTuple_addBTagging_cfg.py      |   57 -
 .../PatAlgos/test/patTuple_addDecayInFlight_cfg.py |   69 -
 PhysicsTools/PatAlgos/test/patTuple_addJets_cfg.py |  105 --
 .../PatAlgos/test/patTuple_addTracks_cfg.py        |   42 -
 .../PatAlgos/test/patTuple_addTriggerInfo_cfg.py   |   29 -
 .../PatAlgos/test/patTuple_addVertexInfo_cfg.py    |   80 --
 .../PatAlgos/test/patTuple_caloTaus_cfg.py         |   34 -
 .../test/patTuple_factorisedTaginfo_cfg.py         |  107 --
 PhysicsTools/PatAlgos/test/patTuple_fastsim_cfg.py |   25 -
 .../PatAlgos/test/patTuple_metUncertainties_cfg.py |   41 -
 .../PatAlgos/test/patTuple_onlyElectrons_cfg.py    |   33 -
 .../PatAlgos/test/patTuple_onlyJets_cfg.py         |   33 -
 PhysicsTools/PatAlgos/test/patTuple_onlyMET_cfg.py |   31 -
 .../PatAlgos/test/patTuple_onlyMuons_cfg.py        |   33 -
 .../PatAlgos/test/patTuple_onlyPhotons_cfg.py      |   33 -
 .../PatAlgos/test/patTuple_onlyTaus_cfg.py         |   33 -
 PhysicsTools/PatAlgos/test/patTuple_pfIso_cfg.py   |   35 -
 .../PatAlgos/test/patTuple_standard_cfg.py         |   43 -
 .../PatAlgos/test/patTuple_topSelection_cfg.py     |  179 ---
 .../PatAlgos/test/patTuple_userData_cfg.py         |   66 -
 .../PatAlgos/test/private/PATUserDataTestModule.cc |  216 ---
 .../test/private/TestEventHypothesisReader.cc      |  109 --
 .../test/private/TestEventHypothesisWriter.cc      |  136 --
 .../test/private/patLayer1_fromAOD-minimal.cfg.py  |   91 --
 .../PatAlgos/test/private/refTestAnalyzer_cfg.py   |   49 -
 .../PatAlgos/test/private/testCleaners_cfg.py      |   43 -
 .../test/private/testEventHypothesisReader_cfg.py  |   17 -
 .../test/private/testEventHypothesisWriter_cfg.py  |   27 -
 .../PatAlgos/test/private/testPATUserData.py       |   31 -
 .../test/private/testPATUserDataExternal.py        |   73 -
 .../PatAlgos/test/private/testPATUserDataRead.py   |   22 -
 PhysicsTools/PatAlgos/test/runAsyncTests.pl        |  212 ---
 .../PatAlgos/test/runtestPhysicsToolsPatAlgos.cpp  |    3 -
 PhysicsTools/PatAlgos/test/runtests.sh             |   42 -
 252 files changed, 188 insertions(+), 25651 deletions(-)

diff --git a/CMGTools/H2TauTau/python/proto/samples/run2012/diboson.py b/CMGTools/H2TauTau/python/proto/samples/run2012/diboson.py
index 8259226..3c6d6b2 100644
--- a/CMGTools/H2TauTau/python/proto/samples/run2012/diboson.py
+++ b/CMGTools/H2TauTau/python/proto/samples/run2012/diboson.py
@@ -97,17 +97,41 @@ ZZ = cfg.MCComponent(
 
 
 mc_diboson = [
-    WWJetsTo2L2Nu,
-    WZJetsTo2L2Q,
+#    WWJetsTo2L2Nu,
+#    WZJetsTo2L2Q,
     WZJetsTo3LNu,
-    ZZJetsTo2L2Nu,
-    ZZJetsTo2L2Q,
+#    ZZJetsTo2L2Nu,
+#    ZZJetsTo2L2Q,
     ZZJetsTo4L,
     # WW,
     # WZ,
     # ZZ
     ]
 
+mc_diboson_wz = [
+    WWJetsTo2L2Nu,
+#    WZJetsTo2L2Q,
+    WZJetsTo3LNu,
+#    ZZJetsTo2L2Nu,
+#    ZZJetsTo2L2Q,
+#    ZZJetsTo4L,
+    # WW,
+    # WZ,
+    # ZZ
+    ]
+
+mc_diboson_ww = [
+    WWJetsTo2L2Nu,
+#    WZJetsTo2L2Q,
+#    WZJetsTo3LNu,
+#    ZZJetsTo2L2Nu,
+#    ZZJetsTo2L2Q,
+#    ZZJetsTo4L,
+    # WW,
+    # WZ,
+    # ZZ
+    ]
+
 
 mc_diboson_incl = [
     WW,
diff --git a/CMGTools/H2TauTau/python/proto/samples/run2012/ewk.py b/CMGTools/H2TauTau/python/proto/samples/run2012/ewk.py
index d2bda07..6a2db1c 100644
--- a/CMGTools/H2TauTau/python/proto/samples/run2012/ewk.py
+++ b/CMGTools/H2TauTau/python/proto/samples/run2012/ewk.py
@@ -153,6 +153,22 @@ Tbar_tW = cfg.MCComponent(
     triggers = [],
     effCorrFactor = 1 )
 
+T_tchan = cfg.MCComponent(
+    name = 'T_tchan',
+    files = [],
+    xSection = 47.0, # from the sync twiki
+    nGenEvents = 1,
+    triggers = [],
+    effCorrFactor = 1 )
+
+Tbar_tchan = cfg.MCComponent(
+    name = 'Tbar_tchan',
+    files = [],
+    xSection = 25.0, # from the sync twiki
+    nGenEvents = 1,
+    triggers = [],
+    effCorrFactor = 1 )
+
 
 
 mc_dy = [
@@ -179,11 +195,24 @@ mc_w_ext = [
 
 t_mc_ewk = [
     # TTJets,
-    T_tW,
-    Tbar_tW,
+#    T_tW,
+#    Tbar_tW,
+    TTJetsFullLept,
+    TTJetsSemiLept,
+#    TTJetsHadronic,
+    ]
+
+mc_singletop = [
+    T_tchan,
+    Tbar_tchan
+    ]
+
+
+mc_ttbar = [
+    # TTJets,
     TTJetsFullLept,
     TTJetsSemiLept,
-    TTJetsHadronic,
+#    TTJetsHadronic,
     ]
 
 
diff --git a/CMGTools/H2TauTau/python/proto/samples/run2012/tauMu_JanAug06.py b/CMGTools/H2TauTau/python/proto/samples/run2012/tauMu_JanAug06.py
index 7e692f0..a5576f4 100644
--- a/CMGTools/H2TauTau/python/proto/samples/run2012/tauMu_JanAug06.py
+++ b/CMGTools/H2TauTau/python/proto/samples/run2012/tauMu_JanAug06.py
@@ -67,18 +67,18 @@ aliases = {
 
 mc_ewk = []
 # mc_ewk += mc_dy
+
 mc_ewk += t_mc_ewk
-mc_ewk += mc_w
-mc_ewk += mc_w_ext
+#mc_ewk += mc_w
+#mc_ewk += mc_w_ext
 
 MC_list = copy.copy( mc_ewk )
+#MC_list.extend( mc_diboson ) 
 
 # MC_list.extend( mc_higgs )
 # MC_list.extend( mc_higgs_susy )
-MC_list.extend( mc_diboson ) 
-    
 allsamples = copy.copy( MC_list )
-allsamples.extend( data_list )
+#allsamples.extend( data_list )
 # allsamples.extend( embed_list )
 
 mc_repro = []
@@ -87,13 +87,12 @@ mc_repro += mc_higgs
 mc_repro += mc_higgs_susy
 
 connect( allsamples, '%TAUMU_SVFitVEGAS_Jul29_steggema', 'tauMu.*root', aliases, cache=True, verbose=False)
-
 connect( embed_list, '%TAUMU_SVFitVEGAS_Aug07_steggema', 'tauMu.*root', aliases, cache=True, verbose=False)
 connect( mc_repro, '%TAUMU_SVFitVEGAS_Aug26_steggema', 'tauMu.*root', aliases, cache=True, verbose=False)
 
-allsamples.extend( embed_list )
-allsamples.extend( mc_repro )
-MC_list.extend( mc_repro ) 
+#allsamples.extend( embed_list )
+#allsamples.extend( mc_repro )
+#MC_list.extend( mc_repro ) 
 
 # Attach number of generated events for stitching
 dy_nevents = [ DYJets.nGenEvents,
diff --git a/CMGTools/H2TauTau/python/triggerMap.py b/CMGTools/H2TauTau/python/triggerMap.py
index 8d48a03..a193a4b 100644
--- a/CMGTools/H2TauTau/python/triggerMap.py
+++ b/CMGTools/H2TauTau/python/triggerMap.py
@@ -115,6 +115,48 @@ pathsAndFilters = {
     'HLT_Mu17_Mu8_v19':('', ''),
     'HLT_Mu17_Mu8_v21':('', ''),
     'HLT_Mu17_Mu8_v22':('', ''),
+
+    # Yuta added
+#    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v*':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9'),
+#    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v*':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9')
+#    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7'),
+#    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7')
+#    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v*':('hltL1sL1Mu3p5EG12ORL1MuOpenEG12L3Filtered8','hltMu8Ele17CaloIdTCaloIsoVLTrkIdVLTrkIsoVLTrackIsoFilter'),
+#    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v*':('hltL1Mu12EG7L3MuFiltered17','hltMu17Ele8CaloIdTCaloIsoVLTrkIdVLTrkIsoVLTrackIsoFilter')
+
+#    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v*':('hltL1sL1Mu3p5EG12ORL1MuOpenEG12L3Filtered8','hltMu8Ele17CaloIdTCaloIsoVLTrkIdVLTrkIsoVLTrackIsoFilter'),
+#    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v*':('hltL1Mu12EG7L3MuFiltered17','hltMu17Ele8CaloIdTCaloIsoVLTrkIdVLTrkIsoVLTrackIsoFilter')
+
+    # added newly
+#    'HLT_Mu8_Ele17_CaloIdL_v*':('HLT_Mu8_Ele17_CaloIdL_v*','HLT_Mu8_Ele17_CaloIdL_v*'), #160404-167913
+#    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_v*':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_v*','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_v*'), #170249-180252
+#    'HLT_Mu17_Ele8_CaloIdL_v*':('HLT_Mu17_Ele8_CaloIdL_v*','HLT_Mu17_Ele8_CaloIdL_v*'), #160404-173198 
+#    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_v*':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_v*','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_v*') #173199-180252
+
+    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v*':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7', 'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7'),
+    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v*':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7', 'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7'),
+
+
+    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9'),
+    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v8':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v8','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v8'),
+    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7'),
+    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v6':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v6','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v6'),
+    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v5':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v5','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v5'),
+    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v4':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v4','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v4'),
+    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v3':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v3','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v3'),
+    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v2':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v2','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v2'),
+    'HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v1':('HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v1','HLT_Mu17_Ele8_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v1'),
+    
+    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9'),
+    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v8':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v8','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v9'),
+    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v7'),
+    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v6':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v6','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v6'),
+    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v5':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v5','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v5'),
+    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v4':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v4','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v4'),
+    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v3':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v3','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v3'),
+    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v2':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v2','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v2'),
+    'HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v1':('HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v1','HLT_Mu8_Ele17_CaloIdT_CaloIsoVL_TrkIdVL_TrkIsoVL_v1'),
+
     }
     
 
diff --git a/CMGTools/RootTools/python/analyzers/DiTriggerAnalyzer.py b/CMGTools/RootTools/python/analyzers/DiTriggerAnalyzer.py
index 9bfadfd..05486c2 100644
--- a/CMGTools/RootTools/python/analyzers/DiTriggerAnalyzer.py
+++ b/CMGTools/RootTools/python/analyzers/DiTriggerAnalyzer.py
@@ -5,11 +5,11 @@ from CMGTools.RootTools.utils.TriggerList import TriggerList
 from CMGTools.RootTools.utils.TriggerMatching import selTriggerObjects
 from CMGTools.RootTools.physicsobjects.PhysicsObjects import TriggerObject
 
-class TriggerAnalyzer( Analyzer ):
+class DiTriggerAnalyzer( Analyzer ):
     '''Access to trigger information, and trigger selection'''
 
     def declareHandles(self):
-        super(TriggerAnalyzer, self).declareHandles()
+        super(DiTriggerAnalyzer, self).declareHandles()
 
         self.handles['cmgTriggerObjectSel'] =  AutoHandle(
             'cmgTriggerObjectSel',
@@ -22,7 +22,8 @@ class TriggerAnalyzer( Analyzer ):
             )
  
     def beginLoop(self):
-        super(TriggerAnalyzer,self).beginLoop()
+        super(DiTriggerAnalyzer,self).beginLoop()
+#        import pdb; pdb.set_trace()
         self.triggerList = TriggerList( self.cfg_comp.triggers )
         if hasattr(self.cfg_comp,'vetoTriggers'):
             self.vetoTriggerList = TriggerList( self.cfg_comp.vetoTriggers )
@@ -93,8 +94,10 @@ class TriggerAnalyzer( Analyzer ):
                                                                usePrescaled = usePrescaled)
               if passed2 and not hltPath2 == None:
                 hltPathVec.append(hltPath2)
-        
+
         event.hltPaths = set(hltPathVec)
+#        import pdb; pdb.set_trace()
+
         
         #Check the veto!
         veto=False
@@ -148,11 +151,11 @@ class TriggerAnalyzer( Analyzer ):
 
     def write(self):
         print 'writing TriggerAnalyzer'
-        super(TriggerAnalyzer, self).write()
+        super(DiTriggerAnalyzer, self).write()
         self.triggerList.write( self.dirName )
 
     def __str__(self):
-        tmp = super(TriggerAnalyzer,self).__str__()
+        tmp = super(DiTriggerAnalyzer,self).__str__()
         triglist = str( self.triggerList )
         return '\n'.join( [tmp, triglist ] )
 
diff --git a/CMGTools/RootTools/python/physicsobjects/ElectronCalibrator.py b/CMGTools/RootTools/python/physicsobjects/ElectronCalibrator.py
deleted file mode 100644
index 7a83809..0000000
--- a/CMGTools/RootTools/python/physicsobjects/ElectronCalibrator.py
+++ /dev/null
@@ -1,22 +0,0 @@
-from math import *
-
-class EmbeddedElectronCalibrator:
-    def __init__(self,label="calib"):
-        self._label = label
-    def correct(self,cmgelectron,dummy):
-        ele = cmgelectron.sourcePtr().get()
-        if not ele.hasUserFloat("p_"+self._label): 
-            raise RuntimeError, "Electron does not have an embedded energy scale correction with label '%s'" % self._label
-        kind_in = ele.candidateP4Kind()
-        p4_in = ele.p4(kind_in)
-        pCalib    = ele.userFloat("p_"+self._label)
-        pErrCalib = ele.userFloat("pError_"+self._label)
-        pKindCalib = ele.userInt("pKind_"+self._label)
-        ecalCalib  = ele.userFloat("ecalEnergy_"+self._label)
-        eErrCalib  = ele.userFloat("ecalEnergyError_"+self._label)
-        ele.setCorrectedEcalEnergy( ecalCalib )
-        ele.setCorrectedEcalEnergyError( eErrCalib )
-        p4_out = p4_in * (pCalib/p4_in.P())
-        ele.setP4(pKindCalib, p4_out, pErrCalib, True)
-        cmgelectron.setP4(p4_out)
-
diff --git a/CMGTools/RootTools/python/physicsobjects/HTauTauElectron.py b/CMGTools/RootTools/python/physicsobjects/HTauTauElectron.py
index 0d885af..d4b9940 100644
--- a/CMGTools/RootTools/python/physicsobjects/HTauTauElectron.py
+++ b/CMGTools/RootTools/python/physicsobjects/HTauTauElectron.py
@@ -75,7 +75,15 @@ class HTauTauElectron( Electron ):
         '''To be used in the tri-lepton veto for both the etau and mutau channels.
         Agreed at the CMS center with Josh, Andrew, Valentina, Jose on the 22nd of October
         '''
+
+#        print 'check', self.sourcePtr().gsfTrack().trackerExpectedHitsInner().numberOfHits(), self.numberOfHits()
         if self.numberOfHits() != 0: return False
+
+#        print 'Yuta', self.passConversionVeto(), self.sourcePtr().userFloat("hasConversion"), self.sourcePtr().get().passConversionVeto()
+
+        
+#        if self.sourcePtr().userFloat("hasConversion"): return False
+
         if not self.passConversionVeto(): return False
         eta = abs( self.sourcePtr().superCluster().eta() )
         #Colin no eta cut should be done here.
@@ -91,7 +99,42 @@ class HTauTauElectron( Electron ):
             else :          lmvaID = 0.975
         result = self.mvaNonTrigV0()  > lmvaID
         return result
-        
+
+
+
+    def mvaForLeptonVeto(self):
+        '''To be used in the tri-lepton veto for both the etau and mutau channels.
+        Agreed at the CMS center with Josh, Andrew, Valentina, Jose on the 22nd of October
+        '''
+
+        eta = abs( self.sourcePtr().superCluster().eta() )
+        #Colin no eta cut should be done here.
+        #        if eta > 2.1 : return False
+        lmvaID = -99999 # identification
+        if self.pt() < 20 :
+            if   eta<0.8:   lmvaID = 0.925
+            elif eta<1.479: lmvaID = 0.915
+            else :          lmvaID = 0.965
+        else:
+            if   eta<0.8:   lmvaID = 0.905
+            elif eta<1.479: lmvaID = 0.955
+            else :          lmvaID = 0.975
+        result = self.mvaNonTrigV0()  > lmvaID
+        return result
+
+
+    def loosestIdForTriLeptonVeto(self):
+        '''To be used in the tri-lepton veto for both the etau and mutau channels.
+        Agreed at the CMS center with Josh, Andrew, Valentina, Jose on the 22nd of October
+        '''
+
+#        print 'check_loosest', self.sourcePtr().gsfTrack().trackerExpectedHitsInner().numberOfHits(), self.numberOfHits()
+#        print 'eYuta', self.passConversionVeto(), self.sourcePtr().userFloat("hasConversion"), self.sourcePtr().get().passConversionVeto()
+        if self.numberOfHits() != 0: return False
+#        if self.sourcePtr().userFloat("hasConversion"): return False
+        if not self.passConversionVeto(): return False
+        return True
+
 
     def tightId( self ):
         return self.tightIdForEleTau()
diff --git a/CMGTools/RootTools/python/physicsobjects/JetReCalibrator.py b/CMGTools/RootTools/python/physicsobjects/JetReCalibrator.py
deleted file mode 100644
index 028c4af..0000000
--- a/CMGTools/RootTools/python/physicsobjects/JetReCalibrator.py
+++ /dev/null
@@ -1,68 +0,0 @@
-import ROOT
-import os, types
-
-class JetReCalibrator:
-    def __init__(self,globalTag,jetFlavour,doResidualJECs):
-        """Create a corrector object that reads the payloads from the text dumps of a global tag under
-            CMGTools/RootTools/data/jec  (see the getJec.py there to make the dumps).
-           It will apply the L1,L2,L3 and possibly the residual corrections to the jets."""
-        # Make base corrections
-        path = "%s/src/CMGTools/RootTools/data/jec" % os.environ['CMSSW_BASE'];
-        self.L1JetPar  = ROOT.JetCorrectorParameters("%s/%s_L1FastJet_%s.txt" % (path,globalTag,jetFlavour));
-        self.L2JetPar  = ROOT.JetCorrectorParameters("%s/%s_L2Relative_%s.txt" % (path,globalTag,jetFlavour));
-        self.L3JetPar  = ROOT.JetCorrectorParameters("%s/%s_L3Absolute_%s.txt" % (path,globalTag,jetFlavour));
-        self.vPar = ROOT.vector(ROOT.JetCorrectorParameters)()
-        self.vPar.push_back(self.L1JetPar);
-        self.vPar.push_back(self.L2JetPar);
-        self.vPar.push_back(self.L3JetPar);
-        # Add residuals if needed
-        if doResidualJECs : 
-            self.ResJetPar = ROOT.JetCorrectorParameters("%s/%s_L2L3Residual_%s.txt" % (path,globalTag,jetFlavour))
-            self.vPar.push_back(self.ResJetPar);
-        #Step3 (Construct a FactorizedJetCorrector object) 
-        self.JetCorrector = ROOT.FactorizedJetCorrector(self.vPar)
-        self.JetUncertainty = ROOT.JetCorrectionUncertainty("%s/%s_Uncertainty_%s.txt" % (path,globalTag,jetFlavour));
-    def correctAll(self,jets,rho,delta=0,metShift=[0,0]):
-        """Applies 'correct' to all the jets, discard the ones that have bad corrections (corrected pt <= 0)"""
-        badJets = []
-        for j in jets:
-            ok = self.correct(j,rho,delta,metShift)
-            if not ok: badJets.append(j)
-        if len(badJets) > 0:
-            print "Warning: %d out of %d jets flagged bad by JEC." % (len(badJets), len(jets))
-        for bj in badJets:
-            jets.remove(bj)
-    def correct(self,jet,rho,delta=0,metShift=[0,0]):
-        """Corrects a jet energy (optionally shifting it also by delta times the JEC uncertainty)
-           If a two-component list is passes as 'metShift', it will be modified adding to the first and second
-           component the change to the MET along x and y due to the JEC, defined as the negative difference 
-           between the new and old jet 4-vectors, for jets with corrected pt > 10."""
-        self.JetCorrector.setJetEta(jet.eta())
-        self.JetCorrector.setJetPt(jet.pt() * jet.rawFactor())
-        self.JetCorrector.setJetA(jet.jetArea())
-        self.JetCorrector.setRho(rho)
-        corr = self.JetCorrector.getCorrection()
-        self.JetUncertainty.setJetEta(jet.eta())
-        self.JetUncertainty.setJetPt(corr * jet.pt() * jet.rawFactor())
-        try:
-            jet.jetEnergyCorrUncertainty = self.JetUncertainty.getUncertainty(True) 
-        except RuntimeError, r:
-            print "Caught %s when getting uncertainty for jet of pt %.1f, eta %.2f\n" % (r,corr * jet.pt() * jet.rawFactor(),jet.eta())
-            jet.jetEnergyCorrUncertainty = 0.5
-        if delta != 0:
-            #print "   jet with corr pt %6.2f has an uncertainty %.2f " % (jet.pt()*jet.rawFactor()*corr, jet.jetEnergyCorrUncertainty)
-            corr *= max(0, 1+delta*jet.jetEnergyCorrUncertainty)
-        #print "   jet with raw pt %6.2f eta %+5.3f phi %+5.3f: previous corr %.4f, my corr %.4f " % (jet.pt()*jet.rawFactor(), jet.eta(), jet.phi(), 1./jet.rawFactor(), corr)
-        if corr <= 0:
-            return False
-        if jet.pt() > 10:
-            metShift[0] += jet.px()
-            metShift[1] += jet.py()
-        jet.setP4(jet.p4() * (corr * jet.rawFactor()))
-        jet.setRawFactor(1.0/corr)
-        if jet.pt() > 10:
-            metShift[0] -= jet.px()
-            metShift[1] -= jet.py()
-        return True
-        
-
diff --git a/CMGTools/RootTools/python/physicsobjects/Lepton.py b/CMGTools/RootTools/python/physicsobjects/Lepton.py
index 540864c..2b7a487 100644
--- a/CMGTools/RootTools/python/physicsobjects/Lepton.py
+++ b/CMGTools/RootTools/python/physicsobjects/Lepton.py
@@ -46,6 +46,8 @@ class Lepton( PhysicsObject):
                 neutralIso=neutralIso-gamma.pt()
         corNeutralIso = neutralIso - dBetaFactor * self.puChargedHadronIso();
         charged = self.chargedHadronIso();
+
+#        import pdb; pdb.set_trace()
         if  allCharged:
             charged = self.chargedAllIso();
         return charged + max(corNeutralIso,0)
diff --git a/CMGTools/RootTools/python/physicsobjects/MuScleFitCorrector.py b/CMGTools/RootTools/python/physicsobjects/MuScleFitCorrector.py
deleted file mode 100644
index 4b37328..0000000
--- a/CMGTools/RootTools/python/physicsobjects/MuScleFitCorrector.py
+++ /dev/null
@@ -1,26 +0,0 @@
-
-class MuScleFitCorr:
-    def __init__(self,isMC,isReReco,isSync=False):
-        from ROOT import MuScleFitCorrector
-        import os
-        path = "%s/src/CMGTools/RootTools/data/musclefit/" % os.environ['CMSSW_BASE'];
-        self.isMC = isMC
-        if self.isMC:
-            self.corr = MuScleFitCorrector(path+"MuScleFit_2012_MC_53X_smear%s.txt" % ("ReReco" if isReReco else "Prompt"))
-            self.isSync = isSync
-        else:
-            self.corrABC = MuScleFitCorrector(path+"MuScleFit_2012ABC_DATA%s_53X.txt" % ("_ReReco" if isReReco else ""))
-            self.corrD   = MuScleFitCorrector(path+"MuScleFit_2012D_DATA%s_53X.txt"   % ("_ReReco" if isReReco else ""))
-    def corrected_p4(self, mu, run):
-        import ROOT
-        p4 = ROOT.TLorentzVector(mu.px(), mu.py(), mu.pz(), mu.energy())
-        if self.isMC:
-            self.corr.applyPtCorrection(p4, mu.charge())
-            self.corr.applyPtSmearing(p4, mu.charge(), self.isSync)
-        else:
-            corr = self.corrD if run >= 203773 else self.corrABC
-            corr.applyPtCorrection(p4, mu.charge())
-        ## convert to the proper C++ class (but preserve the mass!)
-        return ROOT.reco.Muon.PolarLorentzVector( p4.Pt(), p4.Eta(), p4.Phi(), mu.mass() )
-    def correct(self, mu, run):
-        mu.setP4( self.corrected_p4(mu, run) )
diff --git a/CMGTools/RootTools/python/physicsobjects/Muon.py b/CMGTools/RootTools/python/physicsobjects/Muon.py
index c29dd0e..b135c32 100644
--- a/CMGTools/RootTools/python/physicsobjects/Muon.py
+++ b/CMGTools/RootTools/python/physicsobjects/Muon.py
@@ -4,12 +4,15 @@ class Muon( Lepton ):
 
     def looseId( self ):
         '''Loose ID as recommended by mu POG.'''
-        return self.sourcePtr().userFloat('isPFMuon') and \
-               ( self.isGlobalMuon() or self.isTrackerMuon() )
+#        return self.sourcePtr().userFloat('isPFMuon') and \
+#               ( self.isGlobalMuon() or self.isTrackerMuon() )
+        return ( self.isGlobalMuon() or self.isTrackerMuon() )
 
     def tightId( self ):
         '''Tight ID as recommended by mu POG.'''
+        # Added isPFMuon here
         return self.looseId() and \
+               self.sourcePtr().userFloat('isPFMuon') and \
                self.isGlobalMuon() and \
                self.normalizedChi2() < 10 and \
                self.numberOfValidMuonHits() > 0 and \
diff --git a/CMGTools/RootTools/python/physicsobjects/Tau.py b/CMGTools/RootTools/python/physicsobjects/Tau.py
index 87330e4..19a6163 100644
--- a/CMGTools/RootTools/python/physicsobjects/Tau.py
+++ b/CMGTools/RootTools/python/physicsobjects/Tau.py
@@ -3,6 +3,7 @@ from CMGTools.RootTools.physicsobjects.TauDecayModes import tauDecayModes
 import math
 
 cutsElectronMVA3Medium = [0.933,0.921,0.944,0.945,0.918,0.941,0.981,0.943,0.956,0.947,0.951,0.95,0.897,0.958,0.955,0.942]
+cutsElectronMVA3Loose  = [0.835,0.831,0.849,0.859,0.873,0.823,0.85,0.855,0.816,0.861,0.862,0.847,0.893,0.82,0.845,0.851]
 
 class Tau( Lepton ):
     
@@ -62,14 +63,31 @@ class Tau( Lepton ):
     def electronMVA3Medium(self):
         '''Custom electron MVA 3 medium WP used for H->tau tau'''
         icat = int(round(self.tauID('againstElectronMVA3category')))
+
         if icat < 0:
             return False
         elif icat > 15:
             return True
 
         rawMVA = self.tauID('againstElectronMVA3raw') 
+#        print 'Medium => ', icat, rawMVA
+#        return True
         return rawMVA > cutsElectronMVA3Medium[icat]
 
+    def electronMVA3Loose(self):
+        '''Custom electron MVA 3 loose WP used for H->tau tau'''
+        icat = int(round(self.tauID('againstElectronMVA3category')))
+        if icat < 0:
+            return False
+        elif icat > 15:
+            return True
+
+        rawMVA = self.tauID('againstElectronMVA3raw') 
+#        print 'Loose =>', icat, rawMVA
+ #       return True
+        return rawMVA > cutsElectronMVA3Loose[icat]
+
+
 
 def isTau(leg):
     '''Duck-typing a tau'''
diff --git a/PhysicsTools/PatAlgos/BuildFile.xml b/PhysicsTools/PatAlgos/BuildFile.xml
deleted file mode 100644
index d4b918d..0000000
--- a/PhysicsTools/PatAlgos/BuildFile.xml
+++ /dev/null
@@ -1,23 +0,0 @@
-<use   name="DataFormats/Candidate"/>
-<use   name="DataFormats/Common"/>
-<use   name="DataFormats/EgammaCandidates"/>
-<use   name="DataFormats/EgammaReco"/>
-<use   name="DataFormats/JetReco"/>
-<use   name="DataFormats/Math"/>
-<use   name="DataFormats/METReco"/>
-<use   name="DataFormats/MuonReco"/>
-<use   name="DataFormats/PatCandidates"/>
-<use   name="DataFormats/TauReco"/>
-<use   name="DataFormats/TrackReco"/>
-<use   name="DataFormats/VertexReco"/>
-<use   name="FWCore/Framework"/>
-<use   name="FWCore/ParameterSet"/>
-<use   name="FWCore/ServiceRegistry"/>
-<use   name="FWCore/Utilities"/>
-<use   name="PhysicsTools/PatUtils"/>
-<use   name="PhysicsTools/Utilities"/>
-<use   name="PhysicsTools/IsolationAlgos"/>
-<use   name="clhep"/>
-<export>
-  <lib   name="1"/>
-</export>
diff --git a/PhysicsTools/PatAlgos/doc/html/index.html b/PhysicsTools/PatAlgos/doc/html/index.html
deleted file mode 100644
index efbb96d..0000000
--- a/PhysicsTools/PatAlgos/doc/html/index.html
+++ /dev/null
@@ -1,11 +0,0 @@
-<! Template File - Modify as required.>
-<! Use as an index to other html documents>
-<! References to local pages should be relative to this directory>
-<! This makes it easy for both users of the web project space and>
-<! any others who might simply look at html files directly in the source code.>
-<! e.g. href=page1.html or  href=mysubdir/page2.html > 
-<html>
-<body>
-This Text Inserted from File doc/html/index.html
-</body>
-</html>
diff --git a/PhysicsTools/PatAlgos/doc/html/overview.html b/PhysicsTools/PatAlgos/doc/html/overview.html
deleted file mode 100644
index fca463b..0000000
--- a/PhysicsTools/PatAlgos/doc/html/overview.html
+++ /dev/null
@@ -1,12 +0,0 @@
-<! Template File - Modify as required.>
-<! Use as a brief project description that appears on your main page>
-<! Links are not encouraged from this section - use index.html for this>
-This Text Inserted from File doc/html/overview.html
-<table border=0 width=100%>
-<tr>
-<td align=center><b>Status :</b></td>
-<td align=center>
-Unknown
-</td>
-</tr>
-</table>
diff --git a/PhysicsTools/PatAlgos/interface/BaseIsolator.h b/PhysicsTools/PatAlgos/interface/BaseIsolator.h
deleted file mode 100644
index 0f484c5..0000000
--- a/PhysicsTools/PatAlgos/interface/BaseIsolator.h
+++ /dev/null
@@ -1,43 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_interface_BaseIsolator_h
-#define PhysicsTools_PatAlgos_interface_BaseIsolator_h
-
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Framework/interface/Event.h"
-
-namespace pat { namespace helper {
-class BaseIsolator {
-    public:
-        typedef edm::ValueMap<float> Isolation;
-        BaseIsolator() {}
-        BaseIsolator(const edm::ParameterSet &conf, bool withCut) ;
-        virtual ~BaseIsolator() {}
-        virtual void beginEvent(const edm::Event &event, const edm::EventSetup &eventSetup) = 0;
-        virtual void endEvent() = 0;
-
-        /// Tests if the value associated to this item is strictly below the cut.
-        template<typename AnyRef> bool test(const AnyRef &ref) const { 
-            bool ok = (getValue(ref.id(), ref.key()) < cut_);
-            try_++; if (!ok) fail_++;
-            return ok;
-        }
-        /// Returns the associated isolation value given any sort of ref
-        template<typename AnyRef> float getValue(const AnyRef &ref) const {
-            return getValue(ref.id(), ref.key());
-        }
-
-        virtual std::string description() const = 0;
-        void print(std::ostream &out) const ;
-    protected:
-        virtual float getValue(const edm::ProductID &id, size_t index) const = 0;
-        edm::InputTag input_;
-        float cut_;
-        mutable uint64_t try_, fail_;
-}; // class BaseIsolator
-} } // namespaces
-
-inline std::ostream & operator<<(std::ostream &stream, const pat::helper::BaseIsolator &iso) {  
-    iso.print(stream); 
-    return stream;
-}
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/EfficiencyLoader.h b/PhysicsTools/PatAlgos/interface/EfficiencyLoader.h
deleted file mode 100644
index 96f31f8..0000000
--- a/PhysicsTools/PatAlgos/interface/EfficiencyLoader.h
+++ /dev/null
@@ -1,50 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_EfficiencyLoader_h
-#define PhysicsTools_PatAlgos_EfficiencyLoader_h
-
-#include "DataFormats/PatCandidates/interface/PATObject.h"
-#include "DataFormats/PatCandidates/interface/LookupTableRecord.h"
-#include "DataFormats/Common/interface/Handle.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-
-namespace pat { namespace helper {
-class EfficiencyLoader {
-    public:
-        /// Empty constructor
-        EfficiencyLoader() {}
-
-        /// Constructor from a PSet
-        EfficiencyLoader(const edm::ParameterSet &iConfig) ;
-
-        /// 'true' if this there is at least one efficiency configured
-        bool enabled() const { return !names_.empty(); }
-     
-        /// To be called for each new event, reads in the ValueMaps for efficiencies
-        void newEvent(const edm::Event &event) const ;
-
-        /// Sets the efficiencies for this object, using the reference to the original objects
-        template<typename T, typename R>
-        void setEfficiencies( pat::PATObject<T> &obj,  const R & originalRef ) const ;
-
-    private:
-        std::vector<std::string>   names_;
-        std::vector<edm::InputTag> tags_;
-        mutable std::vector<edm::Handle< edm::ValueMap<pat::LookupTableRecord> > > handles_;
-}; // class
-
-template<typename T, typename R>
-void
-EfficiencyLoader::setEfficiencies( pat::PATObject<T> &obj,  const R & originalRef ) const
-{
-    for (size_t i = 0, n = names_.size(); i < n; ++i) {
-        obj.setEfficiency(names_[i], (* handles_[i])[originalRef] );
-    }
-}
-
-} }
-
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/HemisphereAlgo.h b/PhysicsTools/PatAlgos/interface/HemisphereAlgo.h
deleted file mode 100644
index b277af8..0000000
--- a/PhysicsTools/PatAlgos/interface/HemisphereAlgo.h
+++ /dev/null
@@ -1,101 +0,0 @@
-#ifndef HemisphereAlgo_h
-#define HemisphereAlgo_h
-
-
-/*  \class HemisphereAlgo
-*
-*  Class that, given the 4-momenta of the objects in the event, 
-*  allows to split up the event into two "hemispheres" according 
-*  to different criteria (see below)/
-*
-*  Authors: Luc Pape & Filip Moortgat      Date: July 2005
-*                                          Updated: July 2006
-*                                          Updated: 15 Sept 2006
-
-Transported to PAT by Wolfgang Adam and Tanja Rommerskirchen
-*
-*/
-#include "DataFormats/Candidate/interface/Candidate.h"
-
-#include <vector>
-#include <iostream>
-#include <cmath>
-
-class HemisphereAlgo {
-
-public:
-
-// There are 2 constructors:
-// 1. Constructor taking as argument vectors of Px, Py, Pz and E of the objects in
-// the event that should be separated, the seeding method and the hemisphere
-// association method,
-// 2. Constructor taking as argument vectors of Px, Py, Pz and E of the objects in
-// the event that should be separated. The seeding method and the hemisphere
-// association method should then be defined by SetMethod(seeding_method, association_method).
-// 
-// Seeding method: choice of 2 inital axes
-//   1: 1st: max P ; 2nd: max P * delta R wrt first one 
-//   2: 2 objects who give maximal invariant mass (recommended)
-//
-// HemisphereAlgo association method:
-//   1: maximum pt longitudinal projected on the axes
-//   2: minimal mass squared sum of the hemispheres
-//   3: minimal Lund distance (recommended)
-//
-// Note that SetMethod also allows the seeding and/or association method to be
-// redefined for an existing hemisphere object. The GetAxis or GetGrouping is 
-// then recomputed using the newly defined methods.
-//
-
-  HemisphereAlgo(const std::vector<reco::CandidatePtr>& componentRefs_, const int seed_method = 0, const int hemisphere_association_method = 0);
-
-// Destructor
-~HemisphereAlgo(){};
-
-
-std::vector<float> getAxis1(); // returns Nx, Ny, Nz, P, E of the axis of group 1
-std::vector<float> getAxis2(); // returns Nx, Ny, Nz, P, E of the axis of group 2
-
-// where Nx, Ny, Nz are the direction cosines e.g. Nx = Px/P, 
-// P is the momentum, E is the energy
-
-std::vector<int> getGrouping(); // returns vector with "1" and "2"'s according to
-                           // which group the object belongs 
-			   // (order of objects in vector is same as input)
-
-void SetMethod(int seed_method, int hemisphere_association_method){
-  seed_meth = seed_method;
-  hemi_meth = hemisphere_association_method;
-  status = 0;
-}                    // sets or overwrites the seed and association methods
-
-void SetNoSeed(int object_number)  {
-  Object_Noseed[object_number] = 1; 
-  status = 0;
-} 
-                          // prevents an object from being used as a seed
-                          // (method introduced on 15/09/06)
-
-private:
-
-
-int reconstruct(); // the hemisphere separation algorithm
- std::vector<reco::CandidatePtr> Object;
-
-std::vector<int> Object_Group;
-std::vector<int> Object_Noseed;
-
-std::vector<float> Axis1;
-std::vector<float> Axis2;
-
-//static const float hemivsn = 1.01;
-int seed_meth;
-int hemi_meth;
-int status;
-
-
-
-
-};
-
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/IsoDepositIsolator.h b/PhysicsTools/PatAlgos/interface/IsoDepositIsolator.h
deleted file mode 100644
index 008ce48..0000000
--- a/PhysicsTools/PatAlgos/interface/IsoDepositIsolator.h
+++ /dev/null
@@ -1,35 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_interface_IsoDepositIsolator_h
-#define PhysicsTools_PatAlgos_interface_IsoDepositIsolator_h
-
-#include "PhysicsTools/PatAlgos/interface/BaseIsolator.h"
-#include "DataFormats/RecoCandidate/interface/IsoDeposit.h"
-#include "PhysicsTools/IsolationAlgos/interface/EventDependentAbsVeto.h"
-
-
-namespace pat { namespace helper {
-class IsoDepositIsolator : public BaseIsolator {
-    public:
-        typedef edm::ValueMap<reco::IsoDeposit> Isolation;
- 
-        IsoDepositIsolator() {}
-        IsoDepositIsolator(const edm::ParameterSet &conf, bool withCut) ;
-        virtual ~IsoDepositIsolator() ;
-        virtual void beginEvent(const edm::Event &event, const edm::EventSetup &eventSetup) ;
-        virtual void endEvent() ;
-
-        virtual std::string description() const ;
-    protected:
-        enum Mode { Sum, Sum2, SumRelative, Sum2Relative, Max, MaxRelative, Count };
-        edm::Handle<Isolation> handle_;
-
-        float deltaR_;
-        Mode  mode_;
-        reco::isodeposit::AbsVetos vetos_;
-        reco::isodeposit::EventDependentAbsVetos evdepVetos_; // subset of the above, don't delete twice
-        bool skipDefaultVeto_;
-
-        virtual float getValue(const edm::ProductID &id, size_t index) const ;
-}; // class IsoDepositIsolator
-} } // namespaces
-
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h b/PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h
deleted file mode 100644
index b1e628c..0000000
--- a/PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h
+++ /dev/null
@@ -1,58 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_KinResolutionsLoader_h
-#define PhysicsTools_PatAlgos_KinResolutionsLoader_h
-
-#include "DataFormats/PatCandidates/interface/PATObject.h"
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/EventSetup.h"
-#include "FWCore/Framework/interface/ESHandle.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
-#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
-
-#include "PhysicsTools/PatAlgos/interface/KinematicResolutionProvider.h"
-
-
-namespace pat { namespace helper {
-class KinResolutionsLoader {
-    public:
-        /// Empty constructor
-        KinResolutionsLoader() {}
-
-        /// Constructor from a PSet
-        KinResolutionsLoader(const edm::ParameterSet &iConfig) ;
-
-        /// 'true' if this there is at least one efficiency configured
-        bool enabled() const { return !patlabels_.empty(); }
-     
-        /// To be called for each new event, reads in the EventSetup object 
-        void newEvent(const edm::Event &event, const edm::EventSetup &setup) const ;
-
-        /// Sets the efficiencies for this object, using the reference to the original objects
-        template<typename T>
-        void setResolutions( pat::PATObject<T> &obj ) const ;
-
-        /// Method for documentation and validation of PSet
-        static void fillDescription(edm::ParameterSetDescription & iDesc);
-    private:
-        /// Labels of the resolutions in PAT
-        std::vector<std::string>   patlabels_;
-        /// Labels of the KinematicResolutionProvider in the EventSetup
-        std::vector<std::string>   eslabels_;
-        /// Handles to the EventSetup
-        mutable std::vector<edm::ESHandle<KinematicResolutionProvider> > handles_;
-}; // class
-
-template<typename T>
-void
-KinResolutionsLoader::setResolutions( pat::PATObject<T> &obj ) const
-{
-    for (size_t i = 0, n = patlabels_.size(); i < n; ++i) {
-        obj.setKinResolution( handles_[i]->getResolution(obj), patlabels_[i]);
-    }
-}
-
-} }
-
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/KinematicResolutionProvider.h b/PhysicsTools/PatAlgos/interface/KinematicResolutionProvider.h
deleted file mode 100644
index d224556..0000000
--- a/PhysicsTools/PatAlgos/interface/KinematicResolutionProvider.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_KinematicResolutionProvider_H
-#define PhysicsTools_PatAlgos_KinematicResolutionProvider_H
-
-/**
-   \class   KinematicResolutionProvider KinematicResolutionProvider.h "PhysicsTools/PatAlgos/interface/KinematicResolutionProvider.h"
-
-   \brief   Interface for derived classes to provide object resolutions for PAT
-
-   This vitrtual base class is an interface for all derived classes that provide 
-   resolution factors for PAT. The following functions need to be implemented by 
-   any derived class: 
-
-   * getResolution
-
-   a setup function is provided but might need to be re-implemented. 
-*/
-
-namespace reco { class Candidate; }
-namespace pat  { class CandKinResolution; }
-namespace edm  { class ParameterSet; class EventSetup; }
-
-class KinematicResolutionProvider {
-
- public:
-  /// everything that needs to be done before the event loop
-  virtual void setup(const edm::EventSetup &iSetup) const { }
-  /// get a CandKinResolution object from the service; this
-  /// function needs to be implemented by any derived class
-  virtual pat::CandKinResolution getResolution(const reco::Candidate &c) const = 0;
-};
-
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/KinematicResolutionRcd.h b/PhysicsTools/PatAlgos/interface/KinematicResolutionRcd.h
deleted file mode 100644
index 13f6afb..0000000
--- a/PhysicsTools/PatAlgos/interface/KinematicResolutionRcd.h
+++ /dev/null
@@ -1,32 +0,0 @@
-#ifndef PatAlgos_KinematicResolutionRcd_h
-#define PatAlgos_KinematicResolutionRcd_h
-// -*- C++ -*-
-//
-// Package:     PatAlgos
-// Class  :     KinematicResolutionRcd
-// 
-/**\class KinematicResolutionRcd ParticleResolutionRcd.h PhysicsTools/PatAlgos/interface/ParticleResolutionRcd.h
-
- Description: Interface for getting Kinematic Resolutions through EventSetup
-
-*/
-//
-// Author:      
-// Created:     Sun Jun 24 16:53:34 CEST 2007
-// $Id: KinematicResolutionRcd.h,v 1.2 2009/06/25 23:49:34 gpetrucc Exp $
-//
-
-#include "FWCore/Framework/interface/EventSetupRecordImplementation.h"
-#include "FWCore/Framework/interface/DependentRecordImplementation.h"
-#include "MagneticField/Records/interface/IdealMagneticFieldRecord.h"
-
-
-#include "boost/mpl/vector.hpp"
-
-
-class KinematicResolutionRcd : 
-    public edm::eventsetup::DependentRecordImplementation<
-            KinematicResolutionRcd,
-            boost::mpl::vector<IdealMagneticFieldRecord>
-        > {};
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/MultiIsolator.h b/PhysicsTools/PatAlgos/interface/MultiIsolator.h
deleted file mode 100644
index e40893f..0000000
--- a/PhysicsTools/PatAlgos/interface/MultiIsolator.h
+++ /dev/null
@@ -1,91 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_interface_MultiIsolator_h
-#define PhysicsTools_PatAlgos_interface_MultiIsolator_h
-
-#include "DataFormats/Common/interface/View.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Framework/interface/Event.h"
-
-#include "PhysicsTools/PatAlgos/interface/BaseIsolator.h"
-#include "boost/ptr_container/ptr_vector.hpp"
-
-#include "DataFormats/PatCandidates/interface/Isolation.h"
-
-namespace pat { namespace helper {
-class MultiIsolator {
-    public:
-        typedef std::vector<std::pair<pat::IsolationKeys,float> > IsolationValuePairs;
-        MultiIsolator() {}
-        MultiIsolator(const edm::ParameterSet &conf, bool cuts=true) ;
-        ~MultiIsolator() {}
-
-        // adds an isolator (and takes onwership of the pointer)
-        void addIsolator(BaseIsolator *iso, uint32_t mask, pat::IsolationKeys key) ;
-
-        // parses an isolator and adds it to the list
-        void addIsolator(const edm::ParameterSet &conf, bool withCut, uint32_t mask, pat::IsolationKeys key) ;
-
-        // Parses out an isolator, and returns a pointer to it.
-        // For an empty PSet, it returns a null pointer.
-        // You own the returned pointer!
-        static BaseIsolator * make(const edm::ParameterSet &conf, bool withCut) ;
-       
-        void beginEvent(const edm::Event &event, const edm::EventSetup &eventSetup);
-        void endEvent() ; 
-
-        template<typename T>
-        uint32_t test(const edm::View<T> &coll, int idx) const;
-
-        template<typename T>
-        void fill(const edm::View<T> &coll, int idx, IsolationValuePairs& isolations) const ;
-
-        /// Fill Isolation from a Ref, Ptr or RefToBase to the object
-        template<typename RefType>
-        void fill(const RefType &ref, IsolationValuePairs& isolations) const ;
-
-        void print(std::ostream &out) const ;
-
-        std::string printSummary() const ;
-
-        /// True if it has a non null configuration
-        bool enabled() const  { return !isolators_.empty(); }
-    private:
-        boost::ptr_vector<BaseIsolator> isolators_;
-        std::vector<uint32_t>           masks_;
-        std::vector<pat::IsolationKeys> keys_;
-};
-
-    template<typename T>
-    uint32_t 
-    MultiIsolator::test(const edm::View<T> &coll, int idx) const {
-        uint32_t retval = 0;
-        edm::RefToBase<T> rb = coll.refAt(idx); // edm::Ptr<T> in a shiny new future to come one remote day ;-)
-        for (size_t i = 0, n = isolators_.size(); i < n; ++i) {
-            if (!isolators_[i].test(rb)) retval |= masks_[i];
-        }
-        return retval;
-    }
-
-    template<typename RefType>
-    void 
-    MultiIsolator::fill(const RefType &rb, IsolationValuePairs & isolations) const 
-    {
-        isolations.resize(isolators_.size());
-        for (size_t i = 0, n = isolators_.size(); i < n; ++i) {
-           isolations[i].first  = keys_[i];
-           isolations[i].second = isolators_[i].getValue(rb); 
-        }
-    }
-
-
-    template<typename T>
-    void 
-    MultiIsolator::fill(const edm::View<T> &coll, int idx, IsolationValuePairs & isolations) const 
-    {
-        edm::RefToBase<T> rb = coll.refAt(idx); 
-        fill(rb, isolations);
-    }
-
-}} // namespace
-
-#endif
- 
diff --git a/PhysicsTools/PatAlgos/interface/OverlapTest.h b/PhysicsTools/PatAlgos/interface/OverlapTest.h
deleted file mode 100644
index bac74d4..0000000
--- a/PhysicsTools/PatAlgos/interface/OverlapTest.h
+++ /dev/null
@@ -1,91 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_interface_OverlapTest_h
-#define PhysicsTools_PatAlgos_interface_OverlapTest_h
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "DataFormats/Candidate/interface/CandidateFwd.h"
-#include "DataFormats/Candidate/interface/Candidate.h"
-#include "DataFormats/RecoCandidate/interface/RecoCandidate.h"
-#include "PhysicsTools/PatUtils/interface/StringParserTools.h"
-#include "PhysicsTools/PatUtils/interface/PATDiObjectProxy.h"
-
-namespace pat { namespace helper {
-
-// Base class for a test for overlaps
-class OverlapTest {
-    public:
-        /// constructor: reads 'src' and 'requireNoOverlaps' parameters
-        OverlapTest(const std::string &name, const edm::ParameterSet &iConfig) :
-            src_(iConfig.getParameter<edm::InputTag>("src")),
-            name_(name),
-            requireNoOverlaps_(iConfig.getParameter<bool>("requireNoOverlaps")) {}
-        /// destructor, does nothing
-        virtual ~OverlapTest() {}
-        /// initializer for each event. to be implemented in child classes.
-        virtual void readInput(const edm::Event & iEvent, const edm::EventSetup &iSetup) = 0;
-        /// check for overlaps for a given item. to be implemented in child classes
-        /// return true if overlaps have been found, and fills the PtrVector
-        virtual bool fillOverlapsForItem(const reco::Candidate &item, reco::CandidatePtrVector &overlapsToFill) const = 0;
-        /// end of event method. does nothing
-        virtual void done() {}
-        // -- basic getters ---
-       
-        const std::string & name() const { return name_; }
-        bool requireNoOverlaps() const { return requireNoOverlaps_; } 
-    protected:
-        edm::InputTag src_;
-        std::string   name_;
-        bool          requireNoOverlaps_;
-};
-
-class BasicOverlapTest : public OverlapTest {
-    public:
-        BasicOverlapTest(const std::string &name, const edm::ParameterSet &iConfig) :
-            OverlapTest(name, iConfig),
-            presel_(iConfig.getParameter<std::string>("preselection")),
-            deltaR_(iConfig.getParameter<double>("deltaR")),
-            checkRecoComponents_(iConfig.getParameter<bool>("checkRecoComponents")),
-            pairCut_(iConfig.getParameter<std::string>("pairCut")) {}
-        // implementation of mother methods
-        /// Read input, apply preselection cut
-        virtual void readInput(const edm::Event & iEvent, const edm::EventSetup &iSetup) ;
-        /// Check for overlaps
-        virtual bool fillOverlapsForItem(const reco::Candidate &item, reco::CandidatePtrVector &overlapsToFill) const ;
-    protected:
-        // ---- configurables ----
-        /// A generic preselection cut that can work on any Candidate, but has access also to methods of PAT specific objects
-        PATStringCutObjectSelector presel_;
-        /// Delta R for the match
-        double deltaR_;
-        /// Check the overlapping by RECO components
-        bool checkRecoComponents_;
-        /// Cut on the pair of objects together
-        StringCutObjectSelector<pat::DiObjectProxy> pairCut_;
-        // ---- working variables ----
-        /// The collection to check overlaps against
-        edm::Handle<reco::CandidateView> candidates_;
-        /// Flag saying if each element has passed the preselection or not
-        std::vector<bool> isPreselected_;
-};
-
-class OverlapBySuperClusterSeed : public OverlapTest {
-    public:
-        // constructor: nothing except initialize the base class
-        OverlapBySuperClusterSeed(const std::string &name, const edm::ParameterSet &iConfig) : OverlapTest(name, iConfig) {}
-        // every event: nothing except read the input list
-        virtual void readInput(const edm::Event & iEvent, const edm::EventSetup &iSetup) { 
-            iEvent.getByLabel(src_, others_); 
-        }
-         /// Check for overlaps
-        virtual bool fillOverlapsForItem(const reco::Candidate &item, reco::CandidatePtrVector &overlapsToFill) const ;
-    protected:
-        edm::Handle<edm::View<reco::RecoCandidate> > others_;
-};
-
-
-
-} } // namespaces
-
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/PATPrimaryVertexSelector.h b/PhysicsTools/PatAlgos/interface/PATPrimaryVertexSelector.h
deleted file mode 100644
index 4bd9c82..0000000
--- a/PhysicsTools/PatAlgos/interface/PATPrimaryVertexSelector.h
+++ /dev/null
@@ -1,55 +0,0 @@
-#ifndef PatAlgos_PATPrimaryVertexSelector_H_
-#define PatAlgos_PATPrimaryVertexSelector_H_
-
-/** 
-  \class    pat::PATPrimaryVertexSelector PATPrimaryVertexSelector.h "PhysicsTools/PatAlgos/interface/PATPrimaryVertexSelector.h"
-
-   The PATPrimaryVertexSelector is used together with an ObjectSelector to clean and
-   sort a collection of primary vertices. The code is very close to what is done in
-   SusyAnalyzer: it allows a selection based on the (normalized) chi2 of the vertex fit,
-   the position, the multiplicity and the pt-sum of the associated tracks. The tracks 
-   entering in the calculation of the last two quantities can be restricted in eta. 
-   The output collection is sorted by the sum of the track pts.
-
-*/
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/EventSetup.h"
-#include "DataFormats/Common/interface/Handle.h"
-#include "DataFormats/VertexReco/interface/Vertex.h"
-#include "DataFormats/VertexReco/interface/VertexFwd.h"
-
-class PATPrimaryVertexSelector {
-public:
-  typedef reco::VertexCollection collection;
-  typedef std::vector<const reco::Vertex*> container;
-  typedef container::const_iterator const_iterator;
-  PATPrimaryVertexSelector (const edm::ParameterSet& cfg);
-  /// needed for use with an ObjectSelector
-  const_iterator begin() const { return selected_.begin(); }
-  /// needed for use with an ObjectSelector
-  const_iterator end() const { return selected_.end(); }
-  /// needed for use with an ObjectSelector
-  void select(const edm::Handle<collection>&, const edm::Event&, const edm::EventSetup&);
-  /// needed for use with an ObjectSelector
-  size_t size() const { return selected_.size(); }
-  /// operator used in sorting the selected vertices
-  bool operator() (const reco::Vertex*, const reco::Vertex*) const;
-private:
-  /// access to track-related vertex quantities (multiplicity and pt-sum)
-  void getVertexVariables (const reco::Vertex&, unsigned int&, double&) const;
-  /// track selection
-  bool acceptTrack (const reco::Track&) const;
-
-private:
-  container selected_;               /// container of selected vertices
-  unsigned int multiplicityCut_;     /// minimum multiplicity of (selected) associated tracks
-  float ptSumCut_;                   /// minimum pt sum o (selected) associated tracks 
-  float trackEtaCut_;                /// eta cut used for the track selection
-  float chi2Cut_;                    /// cut on the normalized chi2
-  float dr2Cut_;                     /// cut on the (squared) transverse position
-  float dzCut_;                      /// cut on the longitudinal position
-};
-
-#endif
-
diff --git a/PhysicsTools/PatAlgos/interface/PATUserDataHelper.h b/PhysicsTools/PatAlgos/interface/PATUserDataHelper.h
deleted file mode 100644
index 8ae09a8..0000000
--- a/PhysicsTools/PatAlgos/interface/PATUserDataHelper.h
+++ /dev/null
@@ -1,167 +0,0 @@
-//
-// $Id: PATUserDataHelper.h,v 1.8 2010/02/20 21:00:13 wmtan Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATUserDataHelper_h
-#define PhysicsTools_PatAlgos_PATUserDataHelper_h
-
-/**
-  \class    pat::PATUserDataHelper PATUserDataHelper.h "PhysicsTools/PatAlgos/interface/PATUserDataHelper.h"
-  \brief    Assists in assimilating all pat::UserData into pat objects.
-
-
-            This will pull the following from the event stream (if they exist) and put them into the
-	    object in question, all indexed by the reco objects that make up the pat objects in question:
-
-	    * ValueMap<double>
-	    * ValueMap<int>
-	    * ValueMap<Ptr<UserData> >
-	    * ValueMap<CandidatePtr>
-
-	    This is accomplished by using PATUserDataMergers. 
-
-	    This also can add "in situ" string-parser-based methods directly. 
-
-  \author   Salvatore Rappoccio
-  \version  $Id: PATUserDataHelper.h,v 1.8 2010/02/20 21:00:13 wmtan Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/Common/interface/Ptr.h"
-#include "DataFormats/Common/interface/Association.h"
-#include "DataFormats/PatCandidates/interface/PATObject.h"
-
-#include "DataFormats/PatCandidates/interface/UserData.h"
-#include "DataFormats/Candidate/interface/CandidateFwd.h"
-#include "DataFormats/Candidate/interface/Candidate.h"
-#include "PhysicsTools/PatAlgos/interface/PATUserDataMerger.h"
-#include "CommonTools/Utils/interface/StringObjectFunction.h"
-
-
-#include <iostream>
-
-
-namespace pat {
-
-
-  template<class ObjectType>
-  class PATUserDataHelper {
-    
-  public:
-
-    typedef StringObjectFunction<ObjectType>                      function_type;
-
-    PATUserDataHelper() {}
-    PATUserDataHelper(const edm::ParameterSet & iConfig);
-    ~PATUserDataHelper() {}
-
-    static void fillDescription(edm::ParameterSetDescription & iDesc);
-
-    // Adds information from user data to patObject,
-    // using recoObject as the key
-    void add(ObjectType & patObject,
-	     edm::Event const & iEvent, edm::EventSetup const & iSetup);
-
-  private:
-
-    // Custom user data
-    pat::PATUserDataMerger<ObjectType, pat::helper::AddUserPtr>      userDataMerger_;
-    // User doubles
-    pat::PATUserDataMerger<ObjectType, pat::helper::AddUserFloat>    userFloatMerger_;
-    // User ints
-    pat::PATUserDataMerger<ObjectType, pat::helper::AddUserInt>      userIntMerger_;
-    // User candidate ptrs
-    pat::PATUserDataMerger<ObjectType, pat::helper::AddUserCand>     userCandMerger_;
-    
-    // Inline functions that operate on ObjectType
-    std::vector<std::string>                                          functionNames_;
-    std::vector<std::string>                                          functionLabels_;
-    std::vector<function_type >                                       functions_;
-
-  };
-
-// Constructor: Initilize user data src
-template<class ObjectType>
-PATUserDataHelper<ObjectType>::PATUserDataHelper(const edm::ParameterSet & iConfig) :
-  userDataMerger_   (iConfig.getParameter<edm::ParameterSet>("userClasses")),
-  userFloatMerger_  (iConfig.getParameter<edm::ParameterSet>("userFloats")),
-  userIntMerger_    (iConfig.getParameter<edm::ParameterSet>("userInts")),
-  userCandMerger_   (iConfig.getParameter<edm::ParameterSet>("userCands")),
-  functionNames_    (iConfig.getParameter<std::vector<std::string> >("userFunctions")),
-  functionLabels_   (iConfig.getParameter<std::vector<std::string> >("userFunctionLabels"))
-{
-
-  // Make sure the sizes match
-  if ( functionNames_.size() != functionLabels_.size() ) {
-    throw cms::Exception("Size mismatch") << "userFunctions and userFunctionLabels do not have the same size, they must be the same\n";
-  }
-  // Loop over the function names, create a new string-parser function object 
-  // with all of them. This operates on ObjectType
-  std::vector<std::string>::const_iterator funcBegin = functionNames_.begin(),
-    funcEnd = functionNames_.end(),
-    funcIt = funcBegin;
-  for ( ; funcIt != funcEnd; ++funcIt) {
-    functions_.push_back(  StringObjectFunction<ObjectType>( *funcIt ) );
-  }
-}
-
-
-/* ==================================================================================
-     PATUserDataHelper::add 
-            This expects four inputs:
-	        patObject:         PATObject<ObjectType> to add to
-		recoObject:        The base for the value maps
-		iEvent:            Passed to the various data mergers
-		iSetup:            "                                "
-
-   ==================================================================================
-*/
-
-template<class ObjectType>
-void PATUserDataHelper<ObjectType>::add(ObjectType & patObject,
-					edm::Event const & iEvent, 
-					const edm::EventSetup & iSetup ) 
-{
-
-  // Add "complex" user data to the PAT object
-  userDataMerger_.add(   patObject, iEvent, iSetup );
-  userFloatMerger_.add(  patObject, iEvent, iSetup );
-  userIntMerger_.add(    patObject, iEvent, iSetup );
-  userCandMerger_.add(   patObject, iEvent, iSetup );
-
-  // Add "inline" user-selected functions to the PAT object
-  typename std::vector<function_type>::const_iterator funcBegin = functions_.begin(),
-    funcEnd = functions_.end(),
-    funcIt = funcBegin;
-  if ( functionLabels_.size() == functions_.size() ) {
-    for ( ; funcIt != funcEnd; ++funcIt) {
-      double d = (*funcIt)( patObject );
-      patObject.addUserFloat( functionLabels_[funcIt - funcBegin], d );
-    }
-  }
-
-  
-}
-
-
-template<class ObjectType>
-void PATUserDataHelper<ObjectType>::fillDescription(edm::ParameterSetDescription & iDesc)
-{
-  edm::ParameterSetDescription dataMergerPSet;
-  pat::PATUserDataMerger<ObjectType, pat::helper::AddUserPtr>::fillDescription(dataMergerPSet);
-  iDesc.add("userClasses", dataMergerPSet);
-  iDesc.add("userFloats", dataMergerPSet);
-  iDesc.add("userInts", dataMergerPSet);
-  iDesc.add("userCands", dataMergerPSet);
-  std::vector<std::string> emptyVectorOfStrings;
-  iDesc.add<std::vector<std::string> >("userFunctions",emptyVectorOfStrings);
-  iDesc.add<std::vector<std::string> >("userFunctionLabels",emptyVectorOfStrings);
-}
-
-}
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/PATUserDataMerger.h b/PhysicsTools/PatAlgos/interface/PATUserDataMerger.h
deleted file mode 100644
index c04220d..0000000
--- a/PhysicsTools/PatAlgos/interface/PATUserDataMerger.h
+++ /dev/null
@@ -1,159 +0,0 @@
-//
-// $Id: PATUserDataMerger.h,v 1.10 2011/10/26 17:01:25 vadler Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATUserDataMerger_h
-#define PhysicsTools_PatAlgos_PATUserDataMerger_h
-
-/**
-  \class    pat::PATUserDataMerger PATUserDataMerger.h "PhysicsTools/PatAlgos/interface/PATUserDataMerger.h"
-  \brief    Assimilates pat::UserData into pat objects
-
-            This expects one input:
-		src:               The data to add to the objects that get passed to this
-		                   object, which are ValueMaps to some type (like UserData or double).
-
-		This will be called from PATUserDataHelper to handle the templated cases
-		like UserData or double. PATUserDataHelper will then add all the instantiated
-		cases.
-
-  \author   Salvatore Rappoccio
-  \version  $Id: PATUserDataMerger.h,v 1.10 2011/10/26 17:01:25 vadler Exp $
-*/
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/Common/interface/Ptr.h"
-#include "DataFormats/Common/interface/Association.h"
-#include "DataFormats/Candidate/interface/CandidateFwd.h"
-#include "DataFormats/Candidate/interface/Candidate.h"
-#include "DataFormats/PatCandidates/interface/PATObject.h"
-
-#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
-#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
-
-#include <iostream>
-
-
-namespace pat {
-  namespace helper {
-    struct AddUserInt {
-        typedef int                       value_type;
-        typedef edm::ValueMap<value_type> product_type;
-        template<typename ObjectType>
-        void addData(ObjectType &obj, const std::string & key, const value_type &val) { obj.addUserInt(key, val); }
-    };
-    struct AddUserFloat {
-        typedef float                     value_type;
-        typedef edm::ValueMap<value_type> product_type;
-        template<typename ObjectType>
-        void addData(ObjectType &obj, const std::string & key, const value_type &val) { obj.addUserFloat(key, val); }
-    };
-    struct AddUserPtr {
-        typedef edm::Ptr<UserData>        value_type;
-        typedef edm::ValueMap<value_type> product_type;
-        template<typename ObjectType>
-        void addData(ObjectType &obj, const std::string & key, const value_type &val) {
-              obj.addUserDataFromPtr(key, val);
-        }
-    };
-    struct AddUserCand {
-        typedef reco::CandidatePtr        value_type;
-        typedef edm::ValueMap<value_type> product_type;
-        template<typename ObjectType>
-        void addData(ObjectType &obj, const std::string & key, const value_type &val) { obj.addUserCand(key, val); }
-    };
-
-  }
-
-  template<typename ObjectType, typename Operation>
-  class PATUserDataMerger {
-
-  public:
-
-    PATUserDataMerger() {}
-    PATUserDataMerger(const edm::ParameterSet & iConfig);
-    ~PATUserDataMerger() {}
-
-    static void fillDescription(edm::ParameterSetDescription & iDesc);
-
-    // Method to call from PATUserDataHelper to add information to the PATObject in question.
-    void add(ObjectType & patObject,
-	     edm::Event const & iEvent, edm::EventSetup const & iSetup);
-
-  private:
-
-    // configurables
-    std::vector<edm::InputTag>  userDataSrc_;   // ValueMap containing the user data
-    Operation                   loader_;
-
-  };
-
-}
-
-// Constructor: Initilize user data src
-template<typename ObjectType, typename Operation>
-pat::PATUserDataMerger<ObjectType, Operation>::PATUserDataMerger(const edm::ParameterSet & iConfig) :
-  userDataSrc_(iConfig.getParameter<std::vector<edm::InputTag> >("src") )
-{
-}
-
-
-/* ==================================================================================
-     PATUserDataMerger::add
-            This expects four inputs:
-	        patObject:         ObjectType to add to
-
-		from Event:
-		userDataSrc:       The data to add, which is a ValueMap keyed by recoObject
-
-		from Setup:
-		none currently
-
-		This will simply add the UserData *'s from the value map that are
-		indexed by the reco objects, to the pat object's user data vector.
-   ==================================================================================
-*/
-
-template<class ObjectType, typename Operation>
-void
-pat::PATUserDataMerger<ObjectType, Operation>::add(ObjectType & patObject,
-						   edm::Event const & iEvent,
-						   const edm::EventSetup & iSetup )
-{
-
-  std::vector<edm::InputTag>::const_iterator input_it = userDataSrc_.begin(),
-//     input_begin = userDataSrc_.begin(), // warning from gcc461: variable 'input_begin' set but not used [-Wunused-but-set-variable]
-    input_end = userDataSrc_.end();
-
-  for ( ; input_it != input_end; ++input_it ) {
-
-    // Declare the object handles:
-    // ValueMap containing the values, or edm::Ptr's to the UserData that
-    //   is associated to those PAT Objects
-    edm::Handle<typename Operation::product_type> userData;
-
-    // Get the objects by label
-    if ( input_it->encode().size() == 0 ) continue;
-    iEvent.getByLabel( *input_it, userData );
-
-    edm::Ptr<reco::Candidate> recoObject = patObject.originalObjectRef();
-    if ( userData->contains( recoObject.id() ) ) {
-      loader_.addData( patObject, input_it->encode(), (*userData)[recoObject]);
-    }
-
-  }
-
-}
-
-template<class ObjectType, typename Operation>
-void
-pat::PATUserDataMerger<ObjectType, Operation>::fillDescription(edm::ParameterSetDescription & iDesc)
-{
-  iDesc.add<std::vector<edm::InputTag> >("src");
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/SimpleIsolator.h b/PhysicsTools/PatAlgos/interface/SimpleIsolator.h
deleted file mode 100644
index 0e3b4f1..0000000
--- a/PhysicsTools/PatAlgos/interface/SimpleIsolator.h
+++ /dev/null
@@ -1,25 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_interface_SimpleIsolator_h
-#define PhysicsTools_PatAlgos_interface_SimpleIsolator_h
-
-#include "PhysicsTools/PatAlgos/interface/BaseIsolator.h"
-
-namespace pat { namespace helper {
-class SimpleIsolator : public BaseIsolator {
-    public:
-        typedef edm::ValueMap<double> IsoValueMap;
-        SimpleIsolator() {}
-        SimpleIsolator(const edm::ParameterSet &conf, bool withCut) ;
-        virtual ~SimpleIsolator() {}
-        virtual void beginEvent(const edm::Event &event, const edm::EventSetup &eventSetup) ;
-        virtual void endEvent() ;
-
-        virtual std::string description() const { return input_.encode(); }
-    protected:
-        edm::Handle<IsoValueMap> handle_;
-        virtual float getValue(const edm::ProductID &id, size_t index) const {
-            return handle_->get(id, index);
-        }
-}; // class SimpleIsolator
-} } // namespaces
-
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/StringResolutionProvider.h b/PhysicsTools/PatAlgos/interface/StringResolutionProvider.h
deleted file mode 100644
index bd7dfc9..0000000
--- a/PhysicsTools/PatAlgos/interface/StringResolutionProvider.h
+++ /dev/null
@@ -1,69 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_StringResolutionProvider_H
-#define PhysicsTools_PatAlgos_StringResolutionProvider_H
-#include "DataFormats/PatCandidates/interface/CandKinResolution.h"
-#include "PhysicsTools/PatAlgos/interface/KinematicResolutionProvider.h"
-#include "DataFormats/Candidate/interface/Candidate.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-#include "CommonTools/Utils/interface/StringObjectFunction.h"
-
-/**
-   \class   StringResolutionProvider StringResolutionProvider.h "PhysicsTools/PatAlgos/interface/StringResolutionProvider.h"
-
-   \brief   Class to provide resolution factors for PAT candidates
-
-   A class to provide resolution functions for PAT candidates. The class is derived from the 
-   KinematicResolutionProvider class. It expects the following parameters:
-
-   * parametrization :   indicates the used representation (e.g. EtEtaPhi). This parameter 
-                         is MANDATORY.
-   * resolutions     :   a vector of edm::ParameterSets, that contain the resolutions func-
-                         tionspotentially in multiple bins of a cetain parameter. For the 
-			 default implementeation we have bins of reco::Candidate's eta in 
-			 mind, though might be any kind of variable that is accessible as 
-			 memeber function of reco::Candidate. This parameter is MANDATORY.
-
-   The edm::ParameterSets of the _resolutions_ parameter are expected to be of form: 
-
-   * bin             :   Indicated the binning compatible with the StringCutObjectSelector. 
-                         If omitted no binning is applied and the obtained resolution func-
-                         tions are assumed to be valid for all candidates. This parameter 
-			 is OPTIONAL.
-   * et/eta/phi      :   Contain the parametrization in et if working in the EtEtaPhi pa-
-                         rametrization. These parameters are OPTIONAL. They are expected to 
-			 be present in the et/eta/phi representation though. 
-   * constraint      :   adding further information on constraints. It needs to investigated 
-                         further what the meaning of this parameter exactly is before we can 
-			 decide about its future. This parameter is OPTIONAL.
-   
-   We expect that cfi files of this form will be generated automatically. edm::ParameterSets 
-   for other represenations will be implemented on request.
-*/
-
-class StringResolutionProvider : public KinematicResolutionProvider {
-
- public:
-  /// short cut within the common namespace
-  typedef StringObjectFunction<reco::Candidate> Function;
-
-  /// default constructor
-  StringResolutionProvider(const edm::ParameterSet& cfg);
-  /// default destructor
-  virtual ~StringResolutionProvider();
-  /// get a CandKinResolution object from the service 
-  virtual pat::CandKinResolution getResolution(const reco::Candidate& cand) const;
-
- private:
-  /// a vector of constrtaints for the CanKinResolution 
-  /// object
-  std::vector<pat::CandKinResolution::Scalar> constraints_;
-  /// a parametrization for the CanKinResolution object
-  /// (this needs an extension)
-  pat::CandKinResolution::Parametrization parametrization_;
-  /// a vector of strings for the binning
-  std::vector<std::string> bins_;
-  /// vectors for the resolution functions
-  std::vector<std::string> funcEt_, funcEta_, funcPhi_;
-};
-
-#endif
diff --git a/PhysicsTools/PatAlgos/interface/VertexingHelper.h b/PhysicsTools/PatAlgos/interface/VertexingHelper.h
deleted file mode 100644
index 88d22c1..0000000
--- a/PhysicsTools/PatAlgos/interface/VertexingHelper.h
+++ /dev/null
@@ -1,113 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_interface_VertexingHelper_h
-#define PhysicsTools_PatAlgos_interface_VertexingHelper_h
-/**
-  \class    pat::helper::VertexingHelper VertexingHelper.h "PhysicsTools/PatAlgos/interface/VertexingHelper.h"
-  \brief    Produces and/or checks pat::VertexAssociation's
-
-   The VertexingHelper produces pat::VertexAssociation, or reads them from the event,
-   and can use them to select if a candidate is good or not. 
-
-  \author   Giovanni Petrucciani
-  \version  $Id: VertexingHelper.h,v 1.1 2008/07/22 12:47:01 gpetrucc Exp $
-*/
-
-
-#include "DataFormats/PatCandidates/interface/Vertexing.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "PhysicsTools/PatUtils/interface/VertexAssociationSelector.h"
-
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Framework/interface/Event.h"
-
-#include "FWCore/Framework/interface/EventSetup.h"
-#include "FWCore/Framework/interface/ESHandle.h"
-#include "TrackingTools/TransientTrack/interface/TransientTrackBuilder.h"
-
-#include "PhysicsTools/UtilAlgos/interface/ParameterAdapter.h"
-namespace reco {
-    namespace modules {
-        /// Helper struct to convert from ParameterSet to ElectronSelection
-        template<> 
-        struct ParameterAdapter<pat::VertexAssociationSelector> { 
-            static pat::VertexAssociationSelector make(const edm::ParameterSet & iConfig) {
-                pat::VertexAssociationSelector::Config assoconf;
-                if (iConfig.existsAs<double>("deltaZ"))  assoconf.dZ = iConfig.getParameter<double>("deltaZ");
-                if (iConfig.existsAs<double>("deltaR"))  assoconf.dR = iConfig.getParameter<double>("deltaR");
-                if (iConfig.existsAs<double>("sigmasZ")) assoconf.sigmasZ = iConfig.getParameter<double>("sigmasZ");
-                if (iConfig.existsAs<double>("sigmasR")) assoconf.sigmasR = iConfig.getParameter<double>("sigmasR");
-                return pat::VertexAssociationSelector(assoconf);
-            }
-        };
-    }
-}
-
-namespace pat { namespace helper {
-    class VertexingHelper {
-        public:
-            VertexingHelper() : enabled_(false) {}
-            VertexingHelper(const edm::ParameterSet &iConfig) ;
-    
-            /// returns true if this was given a non dummy configuration
-            bool enabled() const {  return enabled_; }
-
-            /// To be called for each new event, reads in the vertex collection
-            void newEvent(const edm::Event &event) ;
-
-            /// To be called for each new event, reads in the vertex collection and the tracking info
-            /// You need this if 'useTrack' is true
-            void newEvent(const edm::Event &event, const edm::EventSetup & setup) ;
-
-            /// Return true if this candidate is associated to a valid vertex
-            /// AnyCandRef should be a Ref<>, RefToBase<> or Ptr to a Candidate object
-            template<typename AnyCandRef>
-            pat::VertexAssociation  operator()(const AnyCandRef &) const ;
-
-        private: 
-            /// true if it has non null configuration
-            bool enabled_;
-        
-            /// true if it's just reading the associations from the event
-            bool playback_;
-       
-            /// selector of associations 
-            pat::VertexAssociationSelector assoSelector_;
-
-            //-------- Tools for production of vertex associations -------
-            edm::InputTag vertices_;
-            edm::Handle<reco::VertexCollection > vertexHandle_;
-            /// use tracks inside candidates
-            bool useTracks_;
-            edm::ESHandle<TransientTrackBuilder> ttBuilder_;
-          
-            //--------- Tools for reading vertex associations (playback mode) ----- 
-            edm::InputTag vertexAssociations_;
-            edm::Handle<edm::ValueMap<pat::VertexAssociation> > vertexAssoMap_;
-
-            /// Get out the track from the Candidate / RecoCandidate / PFCandidate
-            reco::TrackBaseRef  getTrack_(const reco::Candidate &c) const ;
-            
-            /// Try to associated this candidate to a vertex. 
-            /// If no association is found passing all cuts, return a null association
-            pat::VertexAssociation associate(const reco::Candidate &) const ;
-
-    }; // class
-
-    template<typename AnyCandRef>
-    pat::VertexAssociation
-    pat::helper::VertexingHelper::operator()(const AnyCandRef &cand) const 
-    {
-        if (playback_) {
-            const pat::VertexAssociation &assoc = (*vertexAssoMap_)[cand];
-            return assoSelector_(assoc) ? assoc : pat::VertexAssociation();
-        } else {
-            return associate( *cand );
-        }
-
-    }
-
-} }
-
-
-
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/BuildFile.xml b/PhysicsTools/PatAlgos/plugins/BuildFile.xml
deleted file mode 100644
index ff45669..0000000
--- a/PhysicsTools/PatAlgos/plugins/BuildFile.xml
+++ /dev/null
@@ -1,28 +0,0 @@
-<export>
-</export>
-<library   name="PhysicsToolsPatAlgos_plugins" file="*.cc">
-  <use   name="PhysicsTools/PatAlgos"/>
-  <use   name="FWCore/Framework"/>
-  <use   name="FWCore/ParameterSet"/>
-  <use   name="FWCore/MessageLogger"/>
-  <use   name="FWCore/MessageService"/>
-  <use   name="L1Trigger/GlobalTriggerAnalyzer"/>
-  <use   name="HLTrigger/HLTcore"/>
-  <use   name="DataFormats/PatCandidates"/>
-  <use   name="DataFormats/BTauReco"/>
-  <use   name="DataFormats/JetReco"/>
-  <use   name="DataFormats/TrackReco"/>
-  <use   name="DataFormats/Candidate"/>
-  <use   name="DataFormats/HeavyIonEvent"/>
-  <use   name="PhysicsTools/PatUtils"/>
-  <use   name="CondFormats/JetMETObjects"/>
-  <use   name="JetMETCorrections/Objects"/>
-  <use   name="TrackingTools/TransientTrack"/>
-  <use   name="SimDataFormats/Track"/>
-  <use   name="SimDataFormats/Vertex"/>
-  <use   name="SimGeneral/HepPDTRecord"/>
-  <use   name="RecoMET/METAlgorithms"/>
-  <use   name="RecoEgamma/EgammaTools"/>
-  <use   name="TrackingTools/IPTools"/> 
-  <use   name="root"/>
-</library>
diff --git a/PhysicsTools/PatAlgos/plugins/CandidateSummaryTable.cc b/PhysicsTools/PatAlgos/plugins/CandidateSummaryTable.cc
deleted file mode 100644
index 03a1d9a..0000000
--- a/PhysicsTools/PatAlgos/plugins/CandidateSummaryTable.cc
+++ /dev/null
@@ -1,139 +0,0 @@
-//
-// $Id: CandidateSummaryTable.cc,v 1.4 2010/02/20 21:00:15 wmtan Exp $
-//
-
-/**
-  \class    pat::CandidateSummaryTable CandidateSummaryTable.h "PhysicsTools/PatAlgos/interface/CandidateSummaryTable.h"
-  \brief    Produce a summary table of some candidate collections
-
-  FIXME FIXME Move to CandAlgos
-
-  \author   Giovanni Petrucciani
-  \version  $Id: CandidateSummaryTable.cc,v 1.4 2010/02/20 21:00:15 wmtan Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDAnalyzer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include <iomanip>
-
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/Candidate/interface/Candidate.h"
-
-namespace pat {
-  class CandidateSummaryTable : public edm::EDAnalyzer {
-    public:
-      explicit CandidateSummaryTable(const edm::ParameterSet & iConfig);
-      ~CandidateSummaryTable();  
-
-      virtual void analyze(const edm::Event & iEvent, const edm::EventSetup & iSetup);
-      virtual void endJob();
-
-    private:
-      struct Record {
-        edm::InputTag src;
-        size_t present, empty, min, max, total;
-        Record(edm::InputTag tag) : src(tag), present(0), empty(0), min(0), max(0), total(0) {}
-
-        void update(const edm::View<reco::Candidate> &items) {
-            present++; 
-            size_t size = items.size();
-            if (size == 0) {
-                empty++;
-            } else  { 
-                if (min > size) min = size;
-                if (max < size) max = size;
-            }
-            total += size;
-        }
-      };
-      std::vector<Record> collections_;
-      size_t totalEvents_;
-      bool perEvent_, perJob_;
-      std::string self_, logName_;
-      bool dumpItems_;
-  };
-
-} // namespace
-
-pat::CandidateSummaryTable::CandidateSummaryTable(const edm::ParameterSet & iConfig) :
-    totalEvents_(0),
-    perEvent_(iConfig.getUntrackedParameter<bool>("perEvent", false)),
-    perJob_(iConfig.getUntrackedParameter<bool>("perJob", true)),
-    self_(iConfig.getParameter<std::string>("@module_label")),
-    logName_(iConfig.getUntrackedParameter<std::string>("logName")),
-    dumpItems_(iConfig.getUntrackedParameter<bool>("dumpItems", false))
-{
-    std::vector<edm::InputTag> inputs = iConfig.getParameter<std::vector<edm::InputTag> >("candidates");
-    for (std::vector<edm::InputTag>::const_iterator it = inputs.begin(); it != inputs.end(); ++it) {
-        collections_.push_back(Record(*it));
-    }
-}
-
-pat::CandidateSummaryTable::~CandidateSummaryTable() {
-}
-
-void 
-pat::CandidateSummaryTable::analyze(const edm::Event & iEvent, const edm::EventSetup & iSetup) {
-  using namespace edm;
-  using std::setw; using std::left; using std::right; using std::setprecision;
-
-  Handle<View<reco::Candidate> > candidates;
-  if (perEvent_) {
-        LogInfo(logName_) << "Per Event Table " << logName_ <<
-                             " (" << self_ << ", run:event " << iEvent.id().run() << ":" << iEvent.id().event() << ")";
-  }
-  totalEvents_++;
-  for (std::vector<Record>::iterator it = collections_.begin(), ed = collections_.end(); it != ed; ++it) {
-    iEvent.getByLabel(it->src, candidates);
-    if (!candidates.failedToGet()) it->update(*candidates);
-    if (perEvent_) {
-        LogVerbatim(logName_) << "    " << setw(30) << left  << it->src.encode() << right;
-        if (dumpItems_) {
-            size_t i = 0;
-            std::ostringstream oss;
-            for (View<reco::Candidate>::const_iterator cand = candidates->begin(), endc = candidates->end(); cand != endc; ++cand, ++i) {
-                oss << "      [" << setw(3) << i << "]" << 
-                        "  pt "  << setw(7) << setprecision(5) << cand->pt()  <<
-                        "  eta " << setw(7) << setprecision(5) << cand->eta() <<
-                        "  phi " << setw(7) << setprecision(5) << cand->phi() <<
-                        "  et "  << setw(7) << setprecision(5) << cand->et()  <<
-                        "  phi " << setw(7) << setprecision(5) << cand->phi() <<
-                        "  charge " << setw(2) << cand->charge() <<
-                        "  id "     << setw(7) << cand->pdgId() <<
-                        "  st "     << setw(7) << cand->status() << "\n";
-            }
-            LogVerbatim(logName_) << oss.str();
-        }
-    }
-  }
-  if (perEvent_) LogInfo(logName_) << "" ;  // add an empty line
-}
-
-
-void 
-pat::CandidateSummaryTable::endJob() { 
-    using std::setw; using std::left; using std::right; using std::setprecision;
-    if (perJob_) {
-        std::ostringstream oss;
-        oss << "Summary Table " << logName_ << " (" << self_ << ", events total " << totalEvents_ << ")\n";
-        for (std::vector<Record>::iterator it = collections_.begin(), ed = collections_.end(); it != ed; ++it) {
-            oss << "    " << setw(30) << left  << it->src.encode() << right << 
-                "  present " << setw(7) << it->present << " (" << setw(4) << setprecision(3) << (it->present*100.0/totalEvents_) << "%)" << 
-                "  empty "   << setw(7) << it->empty   << " (" << setw(4) << setprecision(3) << (it->empty*100.0/totalEvents_)   << "%)" << 
-                "  min "     << setw(7) << it->min     <<  
-                "  max "     << setw(7) << it->max     <<  
-                "  total "   << setw(7) << it->total   <<
-                "  avg "     << setw(5) << setprecision(3) << (it->total/double(totalEvents_)) << "\n";
-        } 
-        oss << "\n";
-        edm::LogVerbatim(logName_) << oss.str();
-    }
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-using pat::CandidateSummaryTable;
-DEFINE_FWK_MODULE(CandidateSummaryTable);
diff --git a/PhysicsTools/PatAlgos/plugins/DuplicatedElectronCleaner.cc b/PhysicsTools/PatAlgos/plugins/DuplicatedElectronCleaner.cc
deleted file mode 100644
index 2d21ec3..0000000
--- a/PhysicsTools/PatAlgos/plugins/DuplicatedElectronCleaner.cc
+++ /dev/null
@@ -1,94 +0,0 @@
-//
-// $Id: DuplicatedElectronCleaner.cc,v 1.4 2010/02/20 21:00:16 wmtan Exp $
-//
-
-/**
-  \class    pat::DuplicatedElectronCleaner DuplicatedElectronCleaner.h "PhysicsTools/PatAlgos/interface/DuplicatedElectronCleaner.h"
-  \brief    Remove duplicates from the list of electrons
-
-   The DuplicatedElectronCleaner removes duplicates from the input collection.
-   Two electrons are considered duplicate if they share the same gsfTrack or the same superCluster.
-   Among the two, the one with |E/P| nearest to 1 is kept.
-   This is performed by the DuplicatedElectronRemover in PhysicsTools/PatUtils
-
-   The output is an edm::RefVector<reco:::GsfElectron>, 
-   which can be read through edm::View<reco::GsfElectron>
-
-  \author   Giovanni Petrucciani
-  \version  $Id: DuplicatedElectronCleaner.cc,v 1.4 2010/02/20 21:00:16 wmtan Exp $
-*/
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-//#include "DataFormats/Common/interface/RefVector.h"
-#include "DataFormats/Common/interface/RefToBaseVector.h"
-//#include "DataFormats/Common/interface/PtrVector.h"
-
-#include "DataFormats/EgammaCandidates/interface/GsfElectron.h"
-#include "DataFormats/EgammaCandidates/interface/GsfElectronFwd.h"
-#include "PhysicsTools/PatUtils/interface/DuplicatedElectronRemover.h"
-
-namespace pat{
-  class DuplicatedElectronCleaner : public edm::EDProducer{
-  public:
-    explicit DuplicatedElectronCleaner(const edm::ParameterSet & iConfig);
-    ~DuplicatedElectronCleaner();  
-    
-    virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-    virtual void endJob();
-    
-  private:
-    edm::InputTag electronSrc_;
-    pat::DuplicatedElectronRemover duplicateRemover_; 
-    uint64_t try_, pass_;
-  };
-} // namespace
-
-pat::DuplicatedElectronCleaner::DuplicatedElectronCleaner(const edm::ParameterSet & iConfig):
-  electronSrc_(iConfig.getParameter<edm::InputTag>("electronSource")),
-  try_(0), pass_(0)
-{
-  //produces<edm::RefVector<reco::GsfElectronCollection> >();
-  produces<edm::RefToBaseVector<reco::GsfElectron> >();
-  //produces<edm::PtrVector<reco::GsfElectron> >();
-}
-
-pat::DuplicatedElectronCleaner::~DuplicatedElectronCleaner()
-{
-}
-
-void 
-pat::DuplicatedElectronCleaner::produce(edm::Event & iEvent, const edm::EventSetup & iSetup)
-{
-  using namespace edm;
-  Handle<View<reco::GsfElectron> > electrons;
-  iEvent.getByLabel(electronSrc_, electrons);
-  try_ += electrons->size();
-  
-  //std::auto_ptr<RefVector<reco::GsfElectronCollection> > result(new RefVector<reco::GsfElectronCollection>());
-  std::auto_ptr<RefToBaseVector<reco::GsfElectron> > result(new RefToBaseVector<reco::GsfElectron>());
-  //std::auto_ptr<PtrVector<reco::GsfElectron> > result(new PtrVector<reco::GsfElectron>());
-  std::auto_ptr< std::vector<size_t> > duplicates = duplicateRemover_.duplicatesToRemove(*electrons);
-  
-  std::vector<size_t>::const_iterator itdup = duplicates->begin(), enddup = duplicates->end();
-  for (size_t i = 0, n = electrons->size(); i < n; ++i) {
-    while ((itdup != enddup) && (*itdup < i)) { ++itdup; }
-    if ((itdup != enddup) && (*itdup == i)) continue;
-    //result->push_back(electrons->refAt(i).castTo<edm::Ref<reco::GsfElectronCollection> >());
-    result->push_back(electrons->refAt(i));
-    //result->push_back(electrons->ptrAt(i));
-  }
-  pass_ += result->size(); 
-  iEvent.put(result);
-}
-
-void 
-pat::DuplicatedElectronCleaner::endJob() 
-{ 
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-using pat::DuplicatedElectronCleaner;
-DEFINE_FWK_MODULE(DuplicatedElectronCleaner);
diff --git a/PhysicsTools/PatAlgos/plugins/JetCorrFactorsProducer.cc b/PhysicsTools/PatAlgos/plugins/JetCorrFactorsProducer.cc
deleted file mode 100644
index 95b0dd8..0000000
--- a/PhysicsTools/PatAlgos/plugins/JetCorrFactorsProducer.cc
+++ /dev/null
@@ -1,286 +0,0 @@
-#include <memory>
-#include <vector>
-#include <string>
-#include <iostream>
-
-#include "FWCore/Framework/interface/ESHandle.h"
-#include "FWCore/Framework/interface/EventSetup.h"
-#include "DataFormats/JetReco/interface/JPTJet.h"
-#include "DataFormats/JetReco/interface/CaloJet.h"
-#include "DataFormats/VertexReco/interface/Vertex.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "PhysicsTools/PatAlgos/plugins/JetCorrFactorsProducer.h"
-#include "JetMETCorrections/Objects/interface/JetCorrectionsRecord.h"
-
-#include "FWCore/ParameterSet/interface/ParameterDescription.h"
-#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
-#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
-
-
-using namespace pat;
-
-JetCorrFactorsProducer::JetCorrFactorsProducer(const edm::ParameterSet& cfg):
-  emf_(cfg.getParameter<bool>( "emf" )), 
-  src_(cfg.getParameter<edm::InputTag>( "src" )),
-  type_ (cfg.getParameter<std::string>("flavorType")),
-  label_(cfg.getParameter<std::string>( "@module_label" )),
-  payload_( cfg.getParameter<std::string>("payload") ),
-  useNPV_(cfg.getParameter<bool>("useNPV")),
-  useRho_(cfg.getParameter<bool>("useRho"))
-{
-
-  std::vector<std::string> levels = cfg.getParameter<std::vector<std::string> >("levels"); 
-  // fill the std::map for levels_, which might be flavor dependent or not; 
-  // flavor dependency is determined from the fact whether the std::string 
-  // L5Flavor or L7Parton can be found in levels; if flavor dependent four
-  // vectors of strings will be filled into the map corresponding to GLUON, 
-  // UDS, CHARM and BOTTOM (according to JetCorrFactors::Flavor), 'L5Flavor'
-  // and 'L7Parton' will be expanded accordingly; if not levels_ is filled 
-  // with only one vector of strings according to NONE. This vector will be 
-  // equivalent to the original vector of strings.
-  if(std::find(levels.begin(), levels.end(), "L5Flavor")!=levels.end() || std::find(levels.begin(), levels.end(), "L7Parton")!=levels.end()){
-    levels_[JetCorrFactors::GLUON ] = expand(levels, JetCorrFactors::GLUON );
-    levels_[JetCorrFactors::UDS   ] = expand(levels, JetCorrFactors::UDS   );
-    levels_[JetCorrFactors::CHARM ] = expand(levels, JetCorrFactors::CHARM );
-    levels_[JetCorrFactors::BOTTOM] = expand(levels, JetCorrFactors::BOTTOM);
-  }
-  else{
-    levels_[JetCorrFactors::NONE  ] = levels;
-  }
-  // if the std::string L1Offset can be found in levels an additional para-
-  // meter primaryVertices is needed, which should pass on the offline pri-
-  // mary vertex collection. The size of this collection is needed for the 
-  // L1Offset correction.
-  if(useNPV_){
-    if(cfg.existsAs<edm::InputTag>("primaryVertices")){
-      primaryVertices_=cfg.getParameter<edm::InputTag>("primaryVertices");
-    }
-    else{
-      throw cms::Exception("No primaryVertices specified") 
-	<< "The configured correction levels contain an L1Offset or L1FastJet correction, \n"
-	<< "which requires the number of offlinePrimaryVertices. Please specify this col- \n"
-	<< "lection as additional optional parameter primaryVertices in the jetCorrFactors\n"
-	<< "module. \n";
-    }
-  }
-  // if the std::string L1FastJet can be found in levels an additional
-  // parameter rho is needed, which should pass on the energy density 
-  // parameter for the corresponding jet collection.
-  if(useRho_){
-    if(std::find(levels.begin(), levels.end(), "L1FastJet")!=levels.end()){
-      if(cfg.existsAs<edm::InputTag>("rho")){
-	rho_=cfg.getParameter<edm::InputTag>("rho");
-      }
-      else{
-	throw cms::Exception("No parameter rho specified") 
-	  << "The configured correction levels contain a L1FastJet correction, which re- \n"
-	  << "quires the energy density parameter rho. Please specify this collection as \n"
-	  << "additional optional parameter rho in the jetCorrFactors module. \n";
-      }
-    }
-    else{
-      edm::LogWarning message( "Parameter rho not used" );
-      message << "Module is configured to use the parameter rho, but but rho is only used \n"
-	      << "for L1FastJet corrections at the moment. The configuration of levels    \n"
-	      << "does not contain L1FastJet corrections though, so rho will not be used  \n"
-	      << "throughout this module. \n";
-    }
-  }
-  produces<JetCorrFactorsMap>();
-}
-
-std::vector<std::string>
-JetCorrFactorsProducer::expand(const std::vector<std::string>& levels, const JetCorrFactors::Flavor& flavor)
-{
-  std::vector<std::string> expand;
-  for(std::vector<std::string>::const_iterator level=levels.begin(); level!=levels.end(); ++level){
-    if((*level)=="L5Flavor" || (*level)=="L7Parton"){
-      if(flavor==JetCorrFactors::GLUON ){
-	if(*level=="L7Parton" && type_=="T"){
-	  edm::LogWarning message( "L7Parton::GLUON not available" );
-	  message << "Jet energy corrections requested for level: L7Parton and type: 'T'. \n"
-		  << "For this combination there is no GLUON correction available. The    \n"
-		  << "correction for this flavor type will be taken from 'J'.";
-	}
-	expand.push_back(std::string(*level).append("_").append("g").append("J"));	
-      }
-      if(flavor==JetCorrFactors::UDS   ) expand.push_back(std::string(*level).append("_").append("q").append(type_));	
-      if(flavor==JetCorrFactors::CHARM ) expand.push_back(std::string(*level).append("_").append("c").append(type_));	
-      if(flavor==JetCorrFactors::BOTTOM) expand.push_back(std::string(*level).append("_").append("b").append(type_));
-    }
-    else{
-      expand.push_back(*level); 
-    }
-  }
-  return expand;
-}
-
-std::vector<JetCorrectorParameters>
-JetCorrFactorsProducer::params(const JetCorrectorParametersCollection& parameters, const std::vector<std::string>& levels) const 
-{
-  std::vector<JetCorrectorParameters> params;
-  for(std::vector<std::string>::const_iterator level=levels.begin(); level!=levels.end(); ++level){ 
-    const JetCorrectorParameters& ip = parameters[*level]; //ip.printScreen();
-    params.push_back(ip); 
-  } 
-  return params;
-}
-
-float
-JetCorrFactorsProducer::evaluate(edm::View<reco::Jet>::const_iterator& jet, boost::shared_ptr<FactorizedJetCorrector>& corrector, int level)
-{
-  // add parameters for JPT corrections
-  const reco::JPTJet* jpt = dynamic_cast<reco::JPTJet const *>( &*jet );
-  if( jpt ){
-    TLorentzVector p4; p4.SetPtEtaPhiE(jpt->getCaloJetRef()->pt(), jpt->getCaloJetRef()->eta(), jpt->getCaloJetRef()->phi(), jpt->getCaloJetRef()->energy());
-    corrector->setJPTrawP4(p4); 
-  }
-  corrector->setJetEta(jet->eta()); corrector->setJetPt(jet->pt()); corrector->setJetE(jet->energy()); 
-  if( emf_ && dynamic_cast<const reco::CaloJet*>(&*jet)){ 
-    corrector->setJetEMF(dynamic_cast<const reco::CaloJet*>(&*jet)->emEnergyFraction()); 
-  }
-  return corrector->getSubCorrections()[level];
-}
-
-std::string
-JetCorrFactorsProducer::payload()
-{
-  return payload_;
-}
-
-void 
-JetCorrFactorsProducer::produce(edm::Event& event, const edm::EventSetup& setup) 
-{
-  // get jet collection from the event
-  edm::Handle<edm::View<reco::Jet> > jets;
-  event.getByLabel(src_, jets);
-
-  // get primary vertices for L1Offset correction level if needed
-  edm::Handle<std::vector<reco::Vertex> > primaryVertices;
-  if(!primaryVertices_.label().empty()) event.getByLabel(primaryVertices_, primaryVertices);
-
-  // get parameter rho for L1FastJet correction level if needed
-  
-  edm::Handle<double> rho;
-  if(!rho_.label().empty()) event.getByLabel(rho_, rho);
-
-  // retreive parameters from the DB 
-  edm::ESHandle<JetCorrectorParametersCollection> parameters;
-  setup.get<JetCorrectionsRecord>().get(payload(), parameters); 
-
-  // initialize jet correctors
-  std::map<JetCorrFactors::Flavor, boost::shared_ptr<FactorizedJetCorrector> > corrector;
-  for(FlavorCorrLevelMap::const_iterator flavor=levels_.begin(); flavor!=levels_.end(); ++flavor){
-    corrector[flavor->first] = boost::shared_ptr<FactorizedJetCorrector>( new FactorizedJetCorrector(params(*parameters, flavor->second)) );
-  }
-
-  // fill the jetCorrFactors
-  std::vector<JetCorrFactors> jcfs;
-  for(edm::View<reco::Jet>::const_iterator jet = jets->begin(); jet!=jets->end(); ++jet){
-    // the JetCorrFactors::CorrectionFactor is a std::pair<std::string, std::vector<float> >
-    // the string corresponds to the label of the correction level, the vector contains four 
-    // floats if flavor dependent and one float else. Per construction jet energy corrections
-    // will be flavor independent up to the first flavor dependent correction and flavor de-
-    // pendent afterwards. The first correction level is predefined with label 'Uncorrected'. 
-    // Per definition it is flavor independent. The correction factor is 1.
-    std::vector<JetCorrFactors::CorrectionFactor> jec;
-    jec.push_back(std::make_pair<std::string, std::vector<float> >(std::string("Uncorrected"), std::vector<float>(1, 1)));
-
-    // pick the first element in the map (which could be the only one) and loop all jec 
-    // levels listed for that element. If this is not the only element all jec levels, which 
-    // are flavor independent will give the same correction factors until the first flavor
-    // dependent correction level is reached. So the first element is still a good choice.
-    FlavorCorrLevelMap::const_iterator corrLevel=levels_.begin();
-    if(corrLevel==levels_.end()){
-      throw cms::Exception("No JECFactors") << "You request to create a jetCorrFactors object with no JEC Levels indicated. \n"
-					    << "This makes no sense, either you should correct this or drop the module from \n"
-					    << "the sequence."; 
-    }
-    for(unsigned int idx=0; idx<corrLevel->second.size(); ++idx){
-      bool flavorDependent=false;
-      std::vector<float> factors;
-      if(flavorDependent || 
-	 corrLevel->second[idx].find("L5Flavor")!=std::string::npos || 
-	 corrLevel->second[idx].find("L7Parton")!=std::string::npos){
-	flavorDependent=true;
-	// after the first encounter all subsequent correction levels are flavor dependent
-	for(FlavorCorrLevelMap::const_iterator flavor=corrLevel; flavor!=levels_.end(); ++flavor){
-	  if(!primaryVertices_.label().empty()){
-	    // if primaryVertices_ has a value the number of primary vertices needs to be 
-	    // specified
-	    corrector.find(flavor->first)->second->setNPV(numberOf(primaryVertices));
-	  }
-	  if(!rho_.label().empty()){
-	    // if rho_ has a value the energy density parameter rho and the jet area need
-	    //  to be specified
-	    corrector.find(flavor->first)->second->setRho(*rho);
-	    corrector.find(flavor->first)->second->setJetA(jet->jetArea());
-	  }
-	  factors.push_back(evaluate(jet, corrector.find(flavor->first)->second, idx)); 
-	}
-      }
-      else{
-	if(!primaryVertices_.label().empty()){
-	  // if primaryVertices_ has a value the number of primary vertices needs to be 
-	  // specified
-	  corrector.find(corrLevel->first)->second->setNPV(numberOf(primaryVertices));
-	}
-	if(!rho_.label().empty()){
-	  // if rho_ has a value the energy density parameter rho and the jet area need
-	  // to be specified
-	  corrector.find(corrLevel->first)->second->setRho(*rho);
-	  corrector.find(corrLevel->first)->second->setJetA(jet->jetArea());
-	}
-	factors.push_back(evaluate(jet, corrector.find(corrLevel->first)->second, idx));
-      }
-      // push back the set of JetCorrFactors: the first entry corresponds to the label 
-      // of the correction level, which is taken from the first element in levels_. For
-      // L5Flavor and L7Parton the part including the first '_' indicating the flavor
-      // of the first element in levels_ is chopped of from the label to avoid confusion 
-      // of the correction levels. The second parameter corresponds to the set of jec 
-      // factors, which might be flavor dependent or not. In the default configuration 
-      // the CorrectionFactor will look like this: 'Uncorrected': 1 ; 'L2Relative': x ; 
-      // 'L3Absolute': x ; 'L5Flavor': v, x, y, z ; 'L7Parton': v, x, y, z 
-      jec.push_back(std::make_pair((corrLevel->second[idx]).substr(0, (corrLevel->second[idx]).find("_")), factors));
-    }
-    // create the actual object with the scale factors we want the valuemap to refer to
-    // label_ corresponds to the label of the module instance
-    JetCorrFactors corrFactors(label_, jec);
-    jcfs.push_back(corrFactors);
-  }
-  // build the value map
-  std::auto_ptr<JetCorrFactorsMap> jetCorrsMap(new JetCorrFactorsMap());
-  JetCorrFactorsMap::Filler filler(*jetCorrsMap);
-  // jets and jetCorrs have their indices aligned by construction
-  filler.insert(jets, jcfs.begin(), jcfs.end());
-  filler.fill(); // do the actual filling
-  // put our produced stuff in the event
-  event.put(jetCorrsMap);
-}
-
-void
-JetCorrFactorsProducer::fillDescriptions(edm::ConfigurationDescriptions & descriptions)
-{
-  edm::ParameterSetDescription iDesc;
-  iDesc.add<bool>("emf", false);
-  iDesc.add<std::string>("flavorType", "J");
-  iDesc.add<edm::InputTag>("src", edm::InputTag("ak5CaloJets"));
-  iDesc.add<std::string>("payload", "AK5Calo");
-  iDesc.add<bool>("useNPV", true);
-  iDesc.add<edm::InputTag>("primaryVertices", edm::InputTag("offlinePrimaryVertices"));
-  iDesc.add<bool>("useRho", true);
-  iDesc.add<edm::InputTag>("rho", edm::InputTag("kt6PFJets", "rho"));
-
-  std::vector<std::string> levels;
-  levels.push_back(std::string("L1Offset"  )); 
-  levels.push_back(std::string("L2Relative")); 
-  levels.push_back(std::string("L3Absolute")); 
-  levels.push_back(std::string("L5Flavor"  )); 
-  levels.push_back(std::string("L7Parton"  )); 
-  iDesc.add<std::vector<std::string> >("levels", levels);
-  descriptions.add("JetCorrFactorsProducer", iDesc);
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(JetCorrFactorsProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/JetCorrFactorsProducer.h b/PhysicsTools/PatAlgos/plugins/JetCorrFactorsProducer.h
deleted file mode 100644
index 0ac9413..0000000
--- a/PhysicsTools/PatAlgos/plugins/JetCorrFactorsProducer.h
+++ /dev/null
@@ -1,134 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_JetCorrFactorsProducer_h
-#define PhysicsTools_PatAlgos_JetCorrFactorsProducer_h
-
-/**
-  \class    pat::JetCorrFactorsProducer JetCorrFactorsProducer.h "PhysicsTools/PatAlgos/interface/JetCorrFactorsProducer.h"
-  \brief    Produces a ValueMap between JetCorrFactors and the to the originating reco jets
-
-   The JetCorrFactorsProducer produces a set of correction factors, defined in the class pat::JetCorrFactors. This vector 
-   is linked to the originating reco jets through an edm::ValueMap. The initializing parameters of the module can be found 
-   in the recoLayer1/jetCorrFactors_cfi.py of the PatAlgos package. In the standard PAT workflow the module has to be run 
-   before the creation of the pat::Jet. The edm::ValueMap will then be embedded into the pat::Jet. 
-
-   Jets corrected up to a given correction level can then be accessed via the pat::Jet member function correctedJet. For 
-   more details have a look into the class description of the pat::Jet.
-
-   ATTENTION: available options for flavor corrections are 
-    * L5Flavor_gJ        L7Parton_gJ         gluon   from dijets
-    * L5Flavor_qJ/_qT    L7Parton_qJ/_qT     quark   from dijets/top
-    * L5Flavor_cJ/_cT    L7Parton_cJ/_cT     charm   from dijets/top
-    * L5Flavor_bJ/_bT    L7Parton_bJ/_bT     beauty  from dijets/top
-    *                    L7Parton_jJ/_tT     mixture from dijets/top
-
-   where mixture refers to the flavor mixture as determined from the MC sample the flavor dependent corrections have been
-   derived from. 'J' and 'T' stand for a typical dijet (ttbar) sample. 
-
-   L1Offset corrections require the collection of _offlinePrimaryVertices_, which are supposed to be added as an additional 
-   optional parameter _primaryVertices_ in the jetCorrFactors_cfi.py file.  
-
-   L1FastJet corrections, which are an alternative to the standard L1Offset correction as recommended by the JetMET PAG the 
-   energy density parameter _rho_ is supposed to be added as an additional optional parameter _rho_ in the 
-   jetCorrFactors_cfi.py file.  
-
-   NOTE:
-    * the mixed mode (mc input mixture from dijets/ttbar) only exists for parton level corrections.
-    * jJ and tT are not covered in this implementation of the JetCorrFactorsProducer
-    * there are no gluon corrections available from the top sample on the L7Parton level.
-*/
-
-#include <map>
-#include <string>
-#include <boost/shared_ptr.hpp>
-
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/JetReco/interface/Jet.h"
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "DataFormats/PatCandidates/interface/JetCorrFactors.h"
-#include "CondFormats/JetMETObjects/interface/FactorizedJetCorrector.h"
-#include "CondFormats/JetMETObjects/interface/JetCorrectorParameters.h"
-
-
-namespace pat {
-
-  class JetCorrFactorsProducer : public edm::EDProducer {
-  public:
-    /// value map for JetCorrFactors (to be written into the event)
-    typedef edm::ValueMap<pat::JetCorrFactors> JetCorrFactorsMap;
-    /// map of correction levels to different flavors
-    typedef std::map<JetCorrFactors::Flavor, std::vector<std::string> > FlavorCorrLevelMap;
-
-  public:
-    /// default constructor
-    explicit JetCorrFactorsProducer(const edm::ParameterSet& cfg);
-    /// default destructor
-    ~JetCorrFactorsProducer() {};
-    /// everything that needs to be done per event
-    virtual void produce(edm::Event& event, const edm::EventSetup& setup);
-    /// description of configuration file parameters
-    static void fillDescriptions(edm::ConfigurationDescriptions& descriptions);
-    
-  private:
-    /// return true if the jec levels contain at least one flavor dependent correction level
-    bool flavorDependent() const { return (levels_.size()>1); }; 
-    /// return the jec parameters as input to the FactorizedJetCorrector for different flavors
-    std::vector<JetCorrectorParameters> params(const JetCorrectorParametersCollection& parameters, const std::vector<std::string>& levels) const;
-    /// return an expanded version of correction levels for different flavors; the result should
-    /// be of type ['L2Relative', 'L3Absolute', 'L5FLavor_gJ', 'L7Parton_gJ']; L7Parton_gT will 
-    /// result in an empty string as this correction level is not available
-    std::vector<std::string> expand(const std::vector<std::string>& levels, const JetCorrFactors::Flavor& flavor);
-    /// evaluate jet correction factor up to a given level
-    float evaluate(edm::View<reco::Jet>::const_iterator& jet, boost::shared_ptr<FactorizedJetCorrector>& corrector, int level);
-    /// determines the number of valid primary vertices for the standard L1Offset correction of JetMET
-    int numberOf(const edm::Handle<std::vector<reco::Vertex> >& primaryVertices);
-    /// map jet algorithm to payload in DB
-    std::string payload();
-    
-  private:
-    /// use electromagnetic fraction for jet energy corrections or not (will only have an effect for jets CaloJets)
-    bool emf_;
-    /// input jet collection
-    edm::InputTag src_;
-    /// type of flavor dependent JEC factors (only 'J' and 'T' are allowed)
-    std::string type_;
-    /// label of jec factors
-    std::string label_;
-    /// label of payload
-    std::string payload_;
-    /// label for L1Offset primaryVertex collection
-    edm::InputTag primaryVertices_;
-    /// label for L1FastJet energy density parameter rho
-    edm::InputTag rho_;
-    /// use the NPV and rho with the JEC? (used for L1Offset/L1FastJet and L1FastJet, resp.)
-    bool useNPV_;
-    bool useRho_;
-    /// jec levels for different flavors. In the default configuration 
-    /// this map would look like this:
-    /// GLUON  : 'L2Relative', 'L3Absolute', 'L5FLavor_jg', L7Parton_jg'
-    /// UDS    : 'L2Relative', 'L3Absolute', 'L5FLavor_jq', L7Parton_jq'
-    /// CHARM  : 'L2Relative', 'L3Absolute', 'L5FLavor_jc', L7Parton_jc'
-    /// BOTTOM : 'L2Relative', 'L3Absolute', 'L5FLavor_jb', L7Parton_jb'
-    /// or just like this:
-    /// NONE   : 'L2Relative', 'L3Absolute', 'L2L3Residual'
-    /// per definition the vectors for all elements in this map should
-    /// have the same size 
-    FlavorCorrLevelMap levels_;
-  };
-
-  inline int 
-  JetCorrFactorsProducer::numberOf(const edm::Handle<std::vector<reco::Vertex> >& primaryVertices)
-  {
-    int npv=0;
-    for(std::vector<reco::Vertex>::const_iterator pv=primaryVertices->begin(); pv!=primaryVertices->end(); ++pv){
-      if(pv->ndof()>=4) ++npv;
-    }
-    return npv;
-  }
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/ObjectEnergyScale.cc b/PhysicsTools/PatAlgos/plugins/ObjectEnergyScale.cc
deleted file mode 100755
index 1859141..0000000
--- a/PhysicsTools/PatAlgos/plugins/ObjectEnergyScale.cc
+++ /dev/null
@@ -1,23 +0,0 @@
-#include "FWCore/Framework/interface/MakerMacros.h"
-#include "DataFormats/PatCandidates/interface/Electron.h"
-#include "DataFormats/PatCandidates/interface/Muon.h"
-#include "DataFormats/PatCandidates/interface/Tau.h"
-#include "DataFormats/PatCandidates/interface/Jet.h"
-#include "DataFormats/PatCandidates/interface/MET.h"
-#include "PhysicsTools/PatAlgos/plugins/ObjectEnergyScale.h"
-
-// namespace pat {
-//   typedef ObjectEnergyScale<pat::Electron> ElectronEnergyScale;
-//   typedef ObjectEnergyScale<pat::Muon>     MuonEnergyScale;
-//   typedef ObjectEnergyScale<pat::Tau>      TauEnergyScale;
-//   typedef ObjectEnergyScale<pat::Jet>      JetEnergyScale;
-//   typedef ObjectEnergyScale<pat::MET>      METEnergyScale;
-// }
-
-// using namespace pat;
-// DEFINE_FWK_MODULE(ElectronEnergyScale);
-// DEFINE_FWK_MODULE(MuonEnergyScale);
-// DEFINE_FWK_MODULE(TauEnergyScale);
-// DEFINE_FWK_MODULE(JetEnergyScale);
-// DEFINE_FWK_MODULE(METEnergyScale);
-
diff --git a/PhysicsTools/PatAlgos/plugins/ObjectEnergyScale.h b/PhysicsTools/PatAlgos/plugins/ObjectEnergyScale.h
deleted file mode 100644
index 3670f4b6..0000000
--- a/PhysicsTools/PatAlgos/plugins/ObjectEnergyScale.h
+++ /dev/null
@@ -1,159 +0,0 @@
-//
-// $Id: ObjectEnergyScale.h,v 1.3 2010/10/20 23:09:25 wmtan Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_ObjectEnergyScale_h
-#define PhysicsTools_PatAlgos_ObjectEnergyScale_h
-
-/**
-  \class    pat::ObjectEnergyScale ObjectEnergyScale.h "PhysicsTools/PatAlgos/interface/ObjectEnergyScale.h"
-  \brief    Energy scale shifting and smearing module
-
-   This class provides energy scale shifting & smearing to objects with
-   resolutions for systematic error studies.
-   A detailed documentation is found in
-     PhysicsTools/PatAlgos/data/ObjectEnergyScale.cfi
-
-  \author   Volker Adler
-  \version  $Id: ObjectEnergyScale.h,v 1.3 2010/10/20 23:09:25 wmtan Exp $
-*/
-
-
-#include "FWCore/Framework/interface/Frameworkfwd.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "FWCore/ServiceRegistry/interface/Service.h"
-#include "FWCore/Utilities/interface/RandomNumberGenerator.h"
-#include "CLHEP/Random/RandGaussQ.h"
-
-
-namespace pat {
-
-
-  template<class T>
-  class ObjectEnergyScale : public edm::EDProducer {
-
-    public:
-
-      explicit ObjectEnergyScale(const edm::ParameterSet& iConfig);
-      ~ObjectEnergyScale();
-
-    private:
-
-      virtual void produce( edm::Event& iEvent, const edm::EventSetup& iSetup);
-
-      float  getSmearing(T& object);
-      void   setScale(T& object);
-
-      edm::InputTag objects_;
-      float         factor_,
-                    shiftFactor_,
-                    iniRes_,
-                    worsenRes_;
-      bool          useFixedMass_,
-                    useDefaultIniRes_,
-                    useIniResByFraction_,
-                    useWorsenResByFactor_;
-
-      CLHEP::RandGaussQ* gaussian_;
-
-  };
-
-
-}
-
-
-template<class T>
-pat::ObjectEnergyScale<T>::ObjectEnergyScale(const edm::ParameterSet& iConfig)
-{
-  objects_              = iConfig.getParameter<edm::InputTag>("scaledObject");
-  useFixedMass_         = iConfig.getParameter<bool>         ("fixMass");
-  shiftFactor_          = iConfig.getParameter<double>       ("shiftFactor");
-  useDefaultIniRes_     = iConfig.getParameter<bool>         ("useDefaultInitialResolution");
-  iniRes_               = iConfig.getParameter<double>       ("initialResolution");
-  useIniResByFraction_  = iConfig.getParameter<bool>         ("initialResolutionByFraction");
-  worsenRes_            = iConfig.getParameter<double>       ("worsenResolution");
-  useWorsenResByFactor_ = iConfig.getParameter<bool>         ("worsenResolutionByFactor");
-
-  edm::Service<edm::RandomNumberGenerator> rng;
-  CLHEP::HepRandomEngine& engine = rng->getEngine();
-  gaussian_ = new CLHEP::RandGaussQ(engine);
-
-  produces<std::vector<T> >();
-}
-
-
-template<class T>
-pat::ObjectEnergyScale<T>::~ObjectEnergyScale()
-{
-  delete gaussian_;
-}
-
-
-template<class T>
-void pat::ObjectEnergyScale<T>::produce(edm::Event& iEvent, const edm::EventSetup& iSetup)
-{
-  edm::Handle<std::vector<T> > objectsHandle;
-  iEvent.getByLabel(objects_, objectsHandle);
-  std::vector<T> objects = *objectsHandle;
-  std::auto_ptr<std::vector<T> > objectsVector(new std::vector<T>);
-  objectsVector->reserve(objectsHandle->size());
-
-  for ( unsigned int i = 0; i < objects.size(); i++ ) {
-    factor_ = shiftFactor_ * ( objects[i].energy() > 0. ?
-                               getSmearing(objects[i])  :
-                               0.);
-    setScale(objects[i]);
-    objectsVector->push_back(objects[i]);
-  }
-  iEvent.put(objectsVector);
-}
-
-
-/// Returns a smearing factor which is multiplied to the initial value then to get it smeared,
-/// sets initial resolution to resolution provided by input object if required
-/// and converts the 'worsenResolution' parameter to protect from meaningless final resolution values.
-template<class T>
-float pat::ObjectEnergyScale<T>::getSmearing(T& object)
-{
-  // overwrite config file parameter 'initialResolution' if required
-  if ( useDefaultIniRes_ ) {
-    // get initial resolution from input object (and calculate relative initial resolution from absolute value)
-    iniRes_ = (1. / sin(object.theta()) * object.resolutionEt() - object.et() * cos(object.theta()) / std::pow(sin(object.theta()),2) * object.resolutionTheta()) / object.energy(); // conversion of resEt and resTheta into energy resolution
-  } else if ( ! useIniResByFraction_ ) {
-    // calculate relative initial resolution from absolute value
-    iniRes_ = iniRes_ / object.energy();
-  }
-  // Is 'worsenResolution' a factor or a summand?
-  float finalRes = useWorsenResByFactor_                            ?
-                    (1.+fabs(1.-fabs(worsenRes_)))   * fabs(iniRes_) :
-                    fabs(worsenRes_)/object.energy() + fabs(iniRes_); // conversion as protection from "finalRes_<iniRes_"
-  // return smearing factor
-  return std::max( gaussian_->fire(1., sqrt(std::pow(finalRes,2)-std::pow(iniRes_,2))), 0. ); // protection from negative smearing factors
-}
-
-
-/// Mutliplies the final factor (consisting of shifting and smearing factors) to the object's 4-vector
-/// and takes care of preserved masses.
-template<class T>
-void pat::ObjectEnergyScale<T>::setScale(T& object)
-{
-  if ( factor_ < 0. ) {
-    factor_ = 0.;
-  }
-  // calculate the momentum factor for fixed or not fixed mass
-  float factorMomentum = useFixedMass_ && object.p() > 0.                                   ?
-                          sqrt(std::pow(factor_*object.energy(),2)-object.massSqr()) / object.p() :
-                          factor_;
-  // set shifted & smeared new 4-vector
-  object.setP4(reco::Particle::LorentzVector(factorMomentum*object.px(),
-                                             factorMomentum*object.py(),
-                                             factorMomentum*object.pz(),
-                                             factor_       *object.energy()));
-}
-
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/ObjectSpatialResolution.cc b/PhysicsTools/PatAlgos/plugins/ObjectSpatialResolution.cc
deleted file mode 100755
index 299c616..0000000
--- a/PhysicsTools/PatAlgos/plugins/ObjectSpatialResolution.cc
+++ /dev/null
@@ -1,24 +0,0 @@
-#include "FWCore/Framework/interface/MakerMacros.h"
-#include "DataFormats/PatCandidates/interface/Electron.h"
-#include "DataFormats/PatCandidates/interface/Muon.h"
-#include "DataFormats/PatCandidates/interface/Tau.h"
-#include "DataFormats/PatCandidates/interface/Jet.h"
-#include "DataFormats/PatCandidates/interface/MET.h"
-#include "PhysicsTools/PatAlgos/plugins/ObjectSpatialResolution.h"
-
-// namespace pat {
-//   typedef ObjectSpatialResolution<pat::Electron> ElectronSpatialResolution;
-//   typedef ObjectSpatialResolution<pat::Muon>     MuonSpatialResolution;
-//   typedef ObjectSpatialResolution<pat::Tau>      TauSpatialResolution;
-//   typedef ObjectSpatialResolution<pat::Jet>      JetSpatialResolution;
-//   typedef ObjectSpatialResolution<pat::MET>      METSpatialResolution;
-// }
-
-// using namespace pat;
-// DEFINE_FWK_MODULE(ElectronSpatialResolution);
-// DEFINE_FWK_MODULE(MuonSpatialResolution);
-// DEFINE_FWK_MODULE(TauSpatialResolution);
-// DEFINE_FWK_MODULE(JetSpatialResolution);
-// DEFINE_FWK_MODULE(METSpatialResolution);
-
-
diff --git a/PhysicsTools/PatAlgos/plugins/ObjectSpatialResolution.h b/PhysicsTools/PatAlgos/plugins/ObjectSpatialResolution.h
deleted file mode 100644
index 5adcd31..0000000
--- a/PhysicsTools/PatAlgos/plugins/ObjectSpatialResolution.h
+++ /dev/null
@@ -1,177 +0,0 @@
-//
-// $Id: ObjectSpatialResolution.h,v 1.3 2010/10/20 23:09:25 wmtan Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_ObjectSpatialResolution_h
-#define PhysicsTools_PatAlgos_ObjectSpatialResolution_h
-
-/**
-  \class    pat::ObjectSpatialResolution ObjectSpatialResolution.h "PhysicsTools/PatAlgos/interface/ObjectSpatialResolution.h"
-  \brief    Energy scale shifting and smearing module
-
-   This class provides angular smearing to objects with resolutions for
-   systematic error studies.
-   A detailed documentation is found in
-     PhysicsTools/PatAlgos/data/ObjectSpatialResolution.cfi
-
-  \author   Volker Adler
-  \version  $Id: ObjectSpatialResolution.h,v 1.3 2010/10/20 23:09:25 wmtan Exp $
-*/
-
-
-#include <cmath>
-
-#include "FWCore/Framework/interface/Frameworkfwd.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "FWCore/ServiceRegistry/interface/Service.h"
-#include "FWCore/Utilities/interface/RandomNumberGenerator.h"
-#include "CLHEP/Random/RandGaussQ.h"
-#include "DataFormats/Math/interface/normalizedPhi.h"
-
-#include <cmath>
-
-
-namespace pat {
-
-
-  template<class T>
-  class ObjectSpatialResolution : public edm::EDProducer {
-
-    public:
-
-      explicit ObjectSpatialResolution(const edm::ParameterSet& iConfig);
-      ~ObjectSpatialResolution();
-
-    private:
-
-      virtual void produce(edm::Event& iEvent, const edm::EventSetup& iSetup);
-
-      void smearAngles(T& object);
-
-      edm::InputTag objects_;
-      double        iniResPolar_,
-                    worsenResPolar_,
-                    iniResPhi_,
-                    worsenResPhi_;
-      bool          useDefaultIniRes_,
-                    usePolarTheta_,
-                    useWorsenResPolarByFactor_,
-                    useWorsenResPhiByFactor_;
-
-      CLHEP::RandGaussQ* gaussian_;
-
-  };
-
-
-}
-
-
-template<class T>
-pat::ObjectSpatialResolution<T>::ObjectSpatialResolution(const edm::ParameterSet& iConfig)
-{
-  objects_                   = iConfig.getParameter<edm::InputTag>("movedObject");
-  useDefaultIniRes_          = iConfig.getParameter<bool>         ("useDefaultInitialResolutions");
-  iniResPhi_                 = iConfig.getParameter<double>       ("initialResolutionPhi");
-  worsenResPhi_              = iConfig.getParameter<double>       ("worsenResolutionPhi");
-  useWorsenResPhiByFactor_   = iConfig.getParameter<bool>         ("worsenResolutionPhiByFactor");
-  usePolarTheta_             = iConfig.getParameter<bool>         ("usePolarTheta");
-  iniResPolar_               = iConfig.getParameter<double>       ("initialResolutionPolar");
-  worsenResPolar_            = iConfig.getParameter<double>       ("worsenResolutionPolar");
-  useWorsenResPolarByFactor_ = iConfig.getParameter<bool>         ("worsenResolutionPolarByFactor");
-
-  edm::Service<edm::RandomNumberGenerator> rng;
-  CLHEP::HepRandomEngine& engine = rng->getEngine();
-  gaussian_ = new CLHEP::RandGaussQ(engine);
-
-  produces<std::vector<T> >();
-}
-
-
-template<class T>
-pat::ObjectSpatialResolution<T>::~ObjectSpatialResolution()
-{
-  delete gaussian_;
-}
-
-
-template<class T>
-void pat::ObjectSpatialResolution<T>::produce(edm::Event& iEvent, const edm::EventSetup& iSetup)
-{
-  edm::Handle<std::vector<T> > objectsHandle;
-  iEvent.getByLabel(objects_, objectsHandle);
-  std::vector<T> objects = *objectsHandle;
-  std::auto_ptr<std::vector<T> > objectsVector(new std::vector<T>);
-  objectsVector->reserve(objectsHandle->size());
-
-  for ( unsigned int i = 0; i < objects.size(); i++ ) {
-    smearAngles(objects[i]);
-    objectsVector->push_back(objects[i]);
-  }
-  iEvent.put(objectsVector);
-}
-
-
-/// Sets initial resolution to resolution provided by input object if required,
-/// smears eta/theta and phi and sets the 4-vector accordingl.
-template<class T>
-void pat::ObjectSpatialResolution<T>::smearAngles(T& object)
-{
-  // overwrite config file parameters 'initialResolution...' if required
-  if ( useDefaultIniRes_ ) {
-    // get initial resolutions from input object
-    iniResPhi_   = object.resolutionPhi();    // overwrites config file parameter "initialResolution"
-    iniResPolar_ = usePolarTheta_      ?
-                   object.resolutionTheta():
-                   object.resolutionEta();    // overwrites config file parameter "initialResolution"
-  }
-  // smear phi
-  double finalResPhi = useWorsenResPhiByFactor_                            ?
-                       (1.+fabs(1.-fabs(worsenResPhi_))) * fabs(iniResPhi_):
-                       fabs(worsenResPhi_) + fabs(iniResPhi_);               // conversions as protection from "finalRes_<iniRes_"
-  double smearedPhi = normalizedPhi( gaussian_->fire(object.phi(), sqrt(std::pow(finalResPhi,2)-std::pow(iniResPhi_,2))) );
-  double finalResPolar = useWorsenResPolarByFactor_                              ?
-                         (1.+fabs(1.-fabs(worsenResPolar_))) * fabs(iniResPolar_):
-                         fabs(worsenResPolar_) + fabs(iniResPolar_);               // conversions as protection from "finalRes_<iniRes_"
-  // smear theta/eta
-  const double thetaMin = 2.*atan(exp(-ROOT::Math::etaMax<double>())); // to be on the safe side; however, etaMax=22765 ==> thetaMin=0 within double precision
-  double smearedTheta,
-         smearedEta;
-  if ( usePolarTheta_ ) {
-    smearedTheta = gaussian_->fire(object.theta(), sqrt(std::pow(finalResPolar,2)-std::pow(iniResPolar_,2)));
-    // 0<theta<Pi needs to be assured to have proper calculation of eta
-    while ( fabs(smearedTheta) > M_PI ) smearedTheta = smearedTheta < 0.     ?
-                                                       smearedTheta + 2.*M_PI:
-                                                       smearedTheta - 2.*M_PI;
-    if ( smearedTheta < 0. ) {
-      smearedTheta = -smearedTheta;
-      smearedPhi   = normalizedPhi(smearedPhi+M_PI);
-    }
-    smearedEta = smearedTheta < thetaMin          ?
-                 ROOT::Math::etaMax<double>()     :
-                 ( smearedTheta > M_PI-thetaMin ?
-                   -ROOT::Math::etaMax<double>():
-                   -log(tan(smearedTheta/2.))    ); // eta not calculable for theta=0,Pi, which could occur
-  } else {
-    smearedEta = gaussian_->fire(object.eta(), sqrt(std::pow(finalResPolar,2)-std::pow(iniResPolar_,2)));
-    if ( fabs(smearedEta) > ROOT::Math::etaMax<double>() ) smearedEta = smearedEta < 0.              ?
-                                                                        -ROOT::Math::etaMax<double>():
-                                                                         ROOT::Math::etaMax<double>();
-    smearedTheta = 2. * atan(exp(-smearedEta)); // since exp(x)>0 && atan() returns solution closest to 0, 0<theta<Pi should be assured.
-  }
-  // set smeared new 4-vector
-  math::PtEtaPhiELorentzVector newLorentzVector(object.p()*sin(smearedTheta),
-                                                smearedEta,
-                                                smearedPhi,
-                                                object.energy());
-  object.setP4(reco::Particle::LorentzVector(newLorentzVector.Px(),
-                                             newLorentzVector.Py(),
-                                             newLorentzVector.Pz(),
-                                             newLorentzVector.E() ));
-}
-
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATCleaner.cc b/PhysicsTools/PatAlgos/plugins/PATCleaner.cc
deleted file mode 100644
index 6f101d6..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATCleaner.cc
+++ /dev/null
@@ -1,23 +0,0 @@
-#include "PhysicsTools/PatAlgos/plugins/PATCleaner.h"
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-namespace pat {
-    typedef pat::PATCleaner<pat::Electron>   PATElectronCleaner;
-    typedef pat::PATCleaner<pat::Muon>       PATMuonCleaner;
-    typedef pat::PATCleaner<pat::Tau>        PATTauCleaner;
-    typedef pat::PATCleaner<pat::Photon>     PATPhotonCleaner;
-    typedef pat::PATCleaner<pat::Jet>        PATJetCleaner;
-    typedef pat::PATCleaner<pat::MET>        PATMETCleaner;
-    typedef pat::PATCleaner<pat::GenericParticle> PATGenericParticleCleaner;
-    //typedef pat::PATCleaner<pat::PFParticle> PATPFParticleCleaner; // I don't think the PF folks need/want this
-                                                                     // but technically it can work
-}
-using namespace pat;
-DEFINE_FWK_MODULE(PATElectronCleaner);
-DEFINE_FWK_MODULE(PATMuonCleaner);
-DEFINE_FWK_MODULE(PATTauCleaner);
-DEFINE_FWK_MODULE(PATPhotonCleaner);
-DEFINE_FWK_MODULE(PATJetCleaner);
-DEFINE_FWK_MODULE(PATMETCleaner);
-DEFINE_FWK_MODULE(PATGenericParticleCleaner);
-//DEFINE_FWK_MODULE(PATPFParticleCleaner);
diff --git a/PhysicsTools/PatAlgos/plugins/PATCleaner.h b/PhysicsTools/PatAlgos/plugins/PATCleaner.h
deleted file mode 100644
index 501dc5f..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATCleaner.h
+++ /dev/null
@@ -1,141 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_plugins_PATCleaner_h
-#define PhysicsTools_PatAlgos_plugins_PATCleaner_h
-//
-// $Id: PATCleaner.h,v 1.3 2010/10/20 23:08:30 wmtan Exp $
-//
-
-/**
-  \class    pat::PATCleaner PATCleaner.h "PhysicsTools/PatAlgos/interface/PATCleaner.h"
-  \brief    PAT Cleaner module for PAT Objects
-            
-            The same module is used for all collections.
-
-  \author   Giovanni Petrucciani
-  \version  $Id: PATCleaner.h,v 1.3 2010/10/20 23:08:30 wmtan Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "CommonTools/Utils/interface/StringObjectFunction.h"
-#include "CommonTools/Utils/interface/StringCutObjectSelector.h"
-
-#include "DataFormats/PatCandidates/interface/Electron.h"
-#include "DataFormats/PatCandidates/interface/Muon.h"
-#include "DataFormats/PatCandidates/interface/Tau.h"
-#include "DataFormats/PatCandidates/interface/Photon.h"
-#include "DataFormats/PatCandidates/interface/Jet.h"
-#include "DataFormats/PatCandidates/interface/MET.h"
-#include "DataFormats/PatCandidates/interface/GenericParticle.h"
-#include "DataFormats/PatCandidates/interface/PFParticle.h"
-
-#include "PhysicsTools/PatAlgos/interface/OverlapTest.h"
-#include <boost/ptr_container/ptr_vector.hpp>
-
-namespace pat {
-
-  template<class PATObjType>
-  class PATCleaner : public edm::EDProducer {
-    public:
-      explicit PATCleaner(const edm::ParameterSet & iConfig);
-      virtual ~PATCleaner() {}
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-    private:
-      typedef StringCutObjectSelector<PATObjType> Selector;
-
-      edm::InputTag src_;
-      bool doPreselection_, doFinalCut_;  
-      Selector preselectionCut_;
-      Selector finalCut_;
-
-      typedef pat::helper::OverlapTest OverlapTest;
-      // make a list of overlap tests (ptr_vector instead of std::vector because they're polymorphic)
-      boost::ptr_vector<OverlapTest> overlapTests_;
-  };
-
-} // namespace
-
-template <class PATObjType>
-pat::PATCleaner<PATObjType>::PATCleaner(const edm::ParameterSet & iConfig) :
-    src_(iConfig.getParameter<edm::InputTag>("src")),
-    preselectionCut_(iConfig.getParameter<std::string>("preselection")),
-    finalCut_(iConfig.getParameter<std::string>("finalCut"))
-{
-    // pick parameter set for overlaps
-    edm::ParameterSet overlapPSet = iConfig.getParameter<edm::ParameterSet>("checkOverlaps");
-    // get all the names of the tests (all nested PSets in this PSet)
-    std::vector<std::string> overlapNames = overlapPSet.getParameterNamesForType<edm::ParameterSet>();
-    // loop on them
-    for (std::vector<std::string>::const_iterator itn = overlapNames.begin(); itn != overlapNames.end(); ++itn) {
-        // retrieve configuration
-        edm::ParameterSet cfg = overlapPSet.getParameter<edm::ParameterSet>(*itn);
-        // skip empty parameter sets
-        if (cfg.empty()) continue; 
-        // get the name of the algorithm to use
-        std::string algorithm = cfg.getParameter<std::string>("algorithm");
-        // create the appropriate OverlapTest
-        if (algorithm == "byDeltaR") {
-            overlapTests_.push_back(new pat::helper::BasicOverlapTest(*itn, cfg));
-        } else if (algorithm == "bySuperClusterSeed") {
-            overlapTests_.push_back(new pat::helper::OverlapBySuperClusterSeed(*itn, cfg));
-        } else {
-            throw cms::Exception("Configuration") << "PATCleaner for " << src_ << ": unsupported algorithm '" << algorithm << "'\n";
-        }
-    }
-        
-
-    produces<std::vector<PATObjType> >();
-}
-
-template <class PATObjType>
-void 
-pat::PATCleaner<PATObjType>::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) {
-
-  // Read the input. We use edm::View<> in case the input happes to be something different than a std::vector<>
-  edm::Handle<edm::View<PATObjType> > candidates;
-  iEvent.getByLabel(src_, candidates);
-
-  // Prepare a collection for the output
-  std::auto_ptr< std::vector<PATObjType> > output(new std::vector<PATObjType>());
-
-  // initialize the overlap tests
-  for (boost::ptr_vector<OverlapTest>::iterator itov = overlapTests_.begin(), edov = overlapTests_.end(); itov != edov; ++itov) {
-    itov->readInput(iEvent,iSetup);
-  }
-
-  for (typename edm::View<PATObjType>::const_iterator it = candidates->begin(), ed = candidates->end(); it != ed; ++it) {
-      // Apply a preselection to the inputs and copy them in the output
-      if (!preselectionCut_(*it)) continue; 
-
-      // Add it to the list and take a reference to it, so it can be modified (e.g. to set the overlaps)
-      // If at some point I'll decide to drop this item, I'll use pop_back to remove it
-      output->push_back(*it);
-      PATObjType &obj = output->back();
-
-      // Look for overlaps
-      bool badForOverlap = false;
-      for (boost::ptr_vector<OverlapTest>::iterator itov = overlapTests_.begin(), edov = overlapTests_.end(); itov != edov; ++itov) {
-        reco::CandidatePtrVector overlaps;
-        bool hasOverlap = itov->fillOverlapsForItem(obj, overlaps);
-        if (hasOverlap && itov->requireNoOverlaps()) { 
-            badForOverlap = true; // mark for discarding
-            break; // no point in checking the others, as this item will be discarded
-        }
-        obj.setOverlaps(itov->name(), overlaps);
-      }
-      if (badForOverlap) { output->pop_back(); continue; }
-
-      // Apply one final selection cut
-      if (!finalCut_(obj)) output->pop_back();
-  }
-
-  iEvent.put(output);
-}
-
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATCompositeCandidateProducer.cc b/PhysicsTools/PatAlgos/plugins/PATCompositeCandidateProducer.cc
deleted file mode 100755
index f8bec7e..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATCompositeCandidateProducer.cc
+++ /dev/null
@@ -1,89 +0,0 @@
-//
-// $Id: PATCompositeCandidateProducer.cc,v 1.3 2009/06/25 23:49:35 gpetrucc Exp $
-//
-
-#include "PhysicsTools/PatAlgos/plugins/PATCompositeCandidateProducer.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "DataFormats/Common/interface/View.h"
-#include "PhysicsTools/CandUtils/interface/AddFourMomenta.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "CommonTools/Utils/interface/StringObjectFunction.h"
-#include "FWCore/Utilities/interface/Exception.h"
-#include <memory>
-
-
-#include <iostream>
-
-using namespace pat;
-using namespace std;
-using namespace edm;
-
-PATCompositeCandidateProducer::PATCompositeCandidateProducer(const ParameterSet & iConfig) :
-  userDataHelper_( iConfig.getParameter<edm::ParameterSet>("userData") )
-{
-  // initialize the configurables
-  src_ = iConfig.getParameter<InputTag>( "src" );
-
-  useUserData_ = false;
-  if ( iConfig.exists("userData") ) {
-    useUserData_ = true;
-  }
-
-  // Efficiency configurables
-  addEfficiencies_ = iConfig.getParameter<bool>("addEfficiencies");
-  if (addEfficiencies_) {
-     efficiencyLoader_ = pat::helper::EfficiencyLoader(iConfig.getParameter<edm::ParameterSet>("efficiencies"));
-  }
-
-  // Resolution configurables
-  addResolutions_ = iConfig.getParameter<bool>("addResolutions");
-  if (addResolutions_) {
-     resolutionLoader_ = pat::helper::KinResolutionsLoader(iConfig.getParameter<edm::ParameterSet>("resolutions"));
-  }
-
-
-  // produces vector of particles
-  produces<vector<pat::CompositeCandidate> >();
-
-}
-
-PATCompositeCandidateProducer::~PATCompositeCandidateProducer() {
-}
-
-void PATCompositeCandidateProducer::produce(Event & iEvent, const EventSetup & iSetup) {
-  // Get the vector of CompositeCandidate's from the event
-  Handle<View<reco::CompositeCandidate> > cands;
-  iEvent.getByLabel(src_, cands);
-
-  if (efficiencyLoader_.enabled()) efficiencyLoader_.newEvent(iEvent);
-  if (resolutionLoader_.enabled()) resolutionLoader_.newEvent(iEvent, iSetup);
-
-  auto_ptr<vector<pat::CompositeCandidate> > myCompositeCandidates ( new vector<pat::CompositeCandidate>() );
-
-  if ( cands.isValid() ) {
-
-    View<reco::CompositeCandidate>::const_iterator ibegin = cands->begin(),
-      iend = cands->end(), i = ibegin;
-    for ( ; i != iend; ++i ) {
-
-      pat::CompositeCandidate cand(*i);
-      
-      if ( useUserData_ ) {
-	userDataHelper_.add( cand, iEvent, iSetup );
-      }
-
-      if (efficiencyLoader_.enabled()) efficiencyLoader_.setEfficiencies( cand, cands->refAt(i - cands->begin()) );
-      if (resolutionLoader_.enabled()) resolutionLoader_.setResolutions(cand);
-
-      myCompositeCandidates->push_back( cand );
-    }
-
-  }// end if the two handles are valid
-
-  iEvent.put(myCompositeCandidates);
-
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATCompositeCandidateProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATCompositeCandidateProducer.h b/PhysicsTools/PatAlgos/plugins/PATCompositeCandidateProducer.h
deleted file mode 100644
index c92f7d1..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATCompositeCandidateProducer.h
+++ /dev/null
@@ -1,68 +0,0 @@
-//
-// $Id: PATCompositeCandidateProducer.h,v 1.3 2009/06/25 23:49:35 gpetrucc Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATCompositeCandidateProducer_h
-#define PhysicsTools_PatAlgos_PATCompositeCandidateProducer_h
-
-/**
-  \class    pat::PATCompositeCandidateProducer PATCompositeCandidateProducer.h "PhysicsTools/PatAlgos/interface/PATCompositeCandidateProducer.h"
-  \brief    Produces the pat::CompositeCandidate
-
-   The PATCompositeCandidateProducer produces the analysis-level pat::CompositeCandidate starting from
-   any collection of Candidates
-
-  \author   Salvatore Rappoccio
-  \version  $Id: PATCompositeCandidateProducer.h,v 1.3 2009/06/25 23:49:35 gpetrucc Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
-#include "DataFormats/Common/interface/Association.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-
-#include "CommonTools/Utils/interface/EtComparator.h"
-
-#include "DataFormats/PatCandidates/interface/CompositeCandidate.h"
-
-#include "PhysicsTools/PatAlgos/interface/PATUserDataHelper.h"
-#include "PhysicsTools/PatAlgos/interface/MultiIsolator.h"
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-#include "PhysicsTools/PatAlgos/interface/VertexingHelper.h"
-
-namespace pat {
-
-  class PATCompositeCandidateProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATCompositeCandidateProducer(const edm::ParameterSet & iConfig);
-      ~PATCompositeCandidateProducer();
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-    private:
-
-      // configurables
-      edm::InputTag src_;     // list of reco::CompositeCandidates
-
-      bool useUserData_;
-      pat::PATUserDataHelper<pat::CompositeCandidate> userDataHelper_;
-
-      bool addEfficiencies_;
-      pat::helper::EfficiencyLoader efficiencyLoader_;
-      
-      bool addResolutions_;
-      pat::helper::KinResolutionsLoader resolutionLoader_;
-  };
-
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATConversionProducer.cc b/PhysicsTools/PatAlgos/plugins/PATConversionProducer.cc
deleted file mode 100755
index 3706676..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATConversionProducer.cc
+++ /dev/null
@@ -1,120 +0,0 @@
-//
-// $Id: PATConversionProducer.cc,v 1.1 2012/04/14 02:12:39 tjkim Exp $
-//
-#include "PhysicsTools/PatAlgos/plugins/PATConversionProducer.h"
-
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "FWCore/ParameterSet/interface/FileInPath.h"
-
-#include "DataFormats/Common/interface/Association.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
-
-#include "DataFormats/ParticleFlowCandidate/interface/PFCandidateFwd.h"
-#include "DataFormats/ParticleFlowCandidate/interface/PFCandidate.h"
-
-#include "PhysicsTools/PatUtils/interface/TrackerIsolationPt.h"
-#include "PhysicsTools/PatUtils/interface/CaloIsolationEnergy.h"
-
-#include "DataFormats/BeamSpot/interface/BeamSpot.h"
-#include "DataFormats/VertexReco/interface/Vertex.h"
-
-#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
-#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
-
-#include "TrackingTools/TransientTrack/interface/TransientTrackBuilder.h"
-#include "TrackingTools/Records/interface/TransientTrackRecord.h"
-#include "TrackingTools/TransientTrack/interface/TransientTrack.h"
-#include "TrackingTools/IPTools/interface/IPTools.h"
-
-#include "DataFormats/GsfTrackReco/interface/GsfTrackFwd.h"
-#include "DataFormats/GsfTrackReco/interface/GsfTrack.h"
-#include "DataFormats/PatCandidates/interface/Conversion.h"
-
-#include "RecoEcal/EgammaCoreTools/interface/EcalClusterLazyTools.h"
-#include "RecoEgamma/EgammaTools/interface/ConversionTools.h"
-#include "DataFormats/Math/interface/LorentzVector.h"
-
-#include <vector>
-#include <memory>
-#include "TMath.h"
-
-using namespace pat;
-using namespace std;
-
-
-PATConversionProducer::PATConversionProducer(const edm::ParameterSet & iConfig){
-
-  // general configurables
-  electronSrc_      = iConfig.getParameter<edm::InputTag>( "electronSource" );
-
-  // produces vector of muons
-  produces<std::vector<Conversion> >();
-
-}
-
-
-PATConversionProducer::~PATConversionProducer() {
-}
-
-
-void PATConversionProducer::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) {
-
-  // Get the collection of electrons from the event
-  edm::Handle<edm::View<reco::GsfElectron> > electrons;
-  iEvent.getByLabel(electronSrc_, electrons);
-
-  edm::Handle<reco::BeamSpot> bsHandle;
-  iEvent.getByLabel("offlineBeamSpot", bsHandle);
-  const reco::BeamSpot &beamspot = *bsHandle.product();
-
-  // for conversion veto selection  
-  edm::Handle<reco::ConversionCollection> hConversions;
-  iEvent.getByLabel("allConversions", hConversions);
-
-  std::vector<Conversion> * patConversions = new std::vector<Conversion>();
-
-  for (reco::ConversionCollection::const_iterator conv = hConversions->begin(); conv!= hConversions->end(); ++conv) {
-
-    reco::Vertex vtx = conv->conversionVertex();
-
-    int index = 0; 
-    for (edm::View<reco::GsfElectron>::const_iterator itElectron = electrons->begin(); itElectron != electrons->end(); ++itElectron) {
-
-      //find matched conversions with electron and save those conversions with matched electron index
-      if (ConversionTools::matchesConversion(*itElectron, *conv)) {
-
-        double vtxProb = TMath::Prob( vtx.chi2(), vtx.ndof());
-        math::XYZVector mom(conv->refittedPairMomentum());
-        double dbsx = vtx.x() - beamspot.position().x();   
-        double dbsy = vtx.y() - beamspot.position().y();
-        double lxy = (mom.x()*dbsx + mom.y()*dbsy)/mom.rho();
-        int nHitsMax = 0;
-
-        for (std::vector<uint8_t>::const_iterator it = conv->nHitsBeforeVtx().begin(); it!=conv->nHitsBeforeVtx().end(); ++it) {
-          if ((*it) > nHitsMax) nHitsMax = (*it);
-        }
-
-        pat::Conversion anConversion( index ); 
-        anConversion.setVtxProb( vtxProb );
-        anConversion.setLxy( lxy );
-        anConversion.setNHitsMax(  nHitsMax );
-
-        patConversions->push_back(anConversion);
-        break;
-      }
-      index++;
-    }
-    
-  }
-
-  // add the electrons to the event output
-  std::auto_ptr<std::vector<Conversion> > ptr(patConversions);
-  iEvent.put(ptr);
-
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATConversionProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATConversionProducer.h b/PhysicsTools/PatAlgos/plugins/PATConversionProducer.h
deleted file mode 100644
index 061bdc5..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATConversionProducer.h
+++ /dev/null
@@ -1,57 +0,0 @@
-//
-// $Id: PATConversionProducer.h,v 1.1 2012/04/14 02:12:39 tjkim Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATConversionProducer_h
-#define PhysicsTools_PatAlgos_PATConversionProducer_h
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "DataFormats/Candidate/interface/CandAssociation.h"
-
-#include "CommonTools/Utils/interface/PtComparator.h"
-
-#include "PhysicsTools/PatAlgos/interface/MultiIsolator.h"
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-
-#include "DataFormats/PatCandidates/interface/Electron.h"
-
-#include "DataFormats/PatCandidates/interface/UserData.h"
-#include "PhysicsTools/PatAlgos/interface/PATUserDataHelper.h"
-
-#include "RecoEcal/EgammaCoreTools/interface/EcalClusterLazyTools.h"
-
-#include "TrackingTools/TransientTrack/interface/TransientTrack.h"
-#include "DataFormats/VertexReco/interface/Vertex.h"
-
-#include <string>
-
-
-namespace pat {
-
-
-  class PATConversionProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATConversionProducer(const edm::ParameterSet & iConfig);
-      ~PATConversionProducer();
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-    private:
-
-      // configurables
-      edm::InputTag electronSrc_;
-
-  };
-
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATElectronProducer.cc b/PhysicsTools/PatAlgos/plugins/PATElectronProducer.cc
deleted file mode 100755
index c5d3b18..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATElectronProducer.cc
+++ /dev/null
@@ -1,1126 +0,0 @@
-//
-// $Id: PATElectronProducer.cc,v 1.60.2.9 2013/04/15 07:52:01 tjkim Exp $
-//
-#include "PhysicsTools/PatAlgos/plugins/PATElectronProducer.h"
-
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "FWCore/ParameterSet/interface/FileInPath.h"
-
-#include "DataFormats/Common/interface/Association.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
-
-#include "DataFormats/ParticleFlowCandidate/interface/PFCandidateFwd.h"
-#include "DataFormats/ParticleFlowCandidate/interface/PFCandidate.h"
-
-#include "PhysicsTools/PatUtils/interface/TrackerIsolationPt.h"
-#include "PhysicsTools/PatUtils/interface/CaloIsolationEnergy.h"
-
-#include "DataFormats/BeamSpot/interface/BeamSpot.h"
-#include "DataFormats/VertexReco/interface/Vertex.h"
-
-
-#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
-#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
-
-#include "TrackingTools/TransientTrack/interface/TransientTrackBuilder.h"
-#include "TrackingTools/Records/interface/TransientTrackRecord.h"
-#include "TrackingTools/TransientTrack/interface/TransientTrack.h"
-#include "TrackingTools/IPTools/interface/IPTools.h"
-
-#include "DataFormats/GsfTrackReco/interface/GsfTrackFwd.h"
-#include "DataFormats/GsfTrackReco/interface/GsfTrack.h"
-
-#include "RecoEcal/EgammaCoreTools/interface/EcalClusterLazyTools.h"
-#include "RecoEgamma/EgammaTools/interface/ConversionTools.h"
-#include "Geometry/CaloEventSetup/interface/CaloTopologyRecord.h"
-#include "Geometry/CaloTopology/interface/CaloTopology.h"
-#include "Geometry/Records/interface/CaloGeometryRecord.h"
-
-#include <vector>
-#include <memory>
-
-
-using namespace pat;
-using namespace std;
-
-
-PATElectronProducer::PATElectronProducer(const edm::ParameterSet & iConfig) :
-  isolator_(iConfig.exists("userIsolation") ? iConfig.getParameter<edm::ParameterSet>("userIsolation") : edm::ParameterSet(), false) ,
-  useUserData_(iConfig.exists("userData"))
-{
-  // general configurables
-  electronSrc_ = iConfig.getParameter<edm::InputTag>( "electronSource" );
-  embedGsfElectronCore_ = iConfig.getParameter<bool>( "embedGsfElectronCore" );
-  embedGsfTrack_ = iConfig.getParameter<bool>( "embedGsfTrack" );
-  embedSuperCluster_ = iConfig.getParameter<bool>         ( "embedSuperCluster"    );
-  embedPflowSuperCluster_ = iConfig.getParameter<bool>    ( "embedPflowSuperCluster"    );
-  embedSeedCluster_ = iConfig.getParameter<bool>( "embedSeedCluster" );
-  embedBasicClusters_ = iConfig.getParameter<bool>( "embedBasicClusters" );
-  embedPreshowerClusters_ = iConfig.getParameter<bool>( "embedPreshowerClusters" );
-  embedPflowBasicClusters_ = iConfig.getParameter<bool>( "embedPflowBasicClusters" );
-  embedPflowPreshowerClusters_ = iConfig.getParameter<bool>( "embedPflowPreshowerClusters" );
-  embedTrack_ = iConfig.getParameter<bool>( "embedTrack" );
-  embedRecHits_ = iConfig.getParameter<bool>( "embedRecHits" );
-  // pflow configurables
-  pfElecSrc_ = iConfig.getParameter<edm::InputTag>( "pfElectronSource" );
-  pfCandidateMap_ = iConfig.getParameter<edm::InputTag>( "pfCandidateMap" );
-  useParticleFlow_ = iConfig.getParameter<bool>( "useParticleFlow" );
-  embedPFCandidate_ = iConfig.getParameter<bool>( "embedPFCandidate" );
-  // mva input variables
-  reducedBarrelRecHitCollection_ = iConfig.getParameter<edm::InputTag>("reducedBarrelRecHitCollection");
-  reducedEndcapRecHitCollection_ = iConfig.getParameter<edm::InputTag>("reducedEndcapRecHitCollection");
-  // MC matching configurables (scheduled mode)
-  addGenMatch_ = iConfig.getParameter<bool>( "addGenMatch" );
-  if (addGenMatch_) {
-    embedGenMatch_ = iConfig.getParameter<bool>( "embedGenMatch" );
-    if (iConfig.existsAs<edm::InputTag>("genParticleMatch")) {
-      genMatchSrc_.push_back(iConfig.getParameter<edm::InputTag>( "genParticleMatch" ));
-    } 
-    else {
-      genMatchSrc_ = iConfig.getParameter<std::vector<edm::InputTag> >( "genParticleMatch" );
-    }
-  }
-  // resolution configurables
-  addResolutions_ = iConfig.getParameter<bool>( "addResolutions" );
-  if (addResolutions_) {
-    resolutionLoader_ = pat::helper::KinResolutionsLoader(iConfig.getParameter<edm::ParameterSet>("resolutions"));
-  }
-  // electron ID configurables
-  addElecID_ = iConfig.getParameter<bool>( "addElectronID" );
-  if (addElecID_) {
-    // it might be a single electron ID
-    if (iConfig.existsAs<edm::InputTag>("electronIDSource")) {
-      elecIDSrcs_.push_back(NameTag("", iConfig.getParameter<edm::InputTag>("electronIDSource")));
-    }
-    // or there might be many of them
-    if (iConfig.existsAs<edm::ParameterSet>("electronIDSources")) {
-      // please don't configure me twice
-      if (!elecIDSrcs_.empty()){ 
-	throw cms::Exception("Configuration") << "PATElectronProducer: you can't specify both 'electronIDSource' and 'electronIDSources'\n";
-      }
-      // read the different electron ID names
-      edm::ParameterSet idps = iConfig.getParameter<edm::ParameterSet>("electronIDSources");
-      std::vector<std::string> names = idps.getParameterNamesForType<edm::InputTag>();
-      for (std::vector<std::string>::const_iterator it = names.begin(), ed = names.end(); it != ed; ++it) {
-	elecIDSrcs_.push_back(NameTag(*it, idps.getParameter<edm::InputTag>(*it)));
-      }
-    }
-    // but in any case at least once
-    if (elecIDSrcs_.empty()){ 
-      throw cms::Exception("Configuration") <<
-	"PATElectronProducer: id addElectronID is true, you must specify either:\n" <<
-	"\tInputTag electronIDSource = <someTag>\n" << "or\n" <<
-	"\tPSet electronIDSources = { \n" <<
-	"\t\tInputTag <someName> = <someTag>   // as many as you want \n " <<
-	"\t}\n";
-    }
-  }
-  // construct resolution calculator
-
-  //   // IsoDeposit configurables
-  //   if (iConfig.exists("isoDeposits")) {
-  //      edm::ParameterSet depconf = iConfig.getParameter<edm::ParameterSet>("isoDeposits");
-  //      if (depconf.exists("tracker")) isoDepositLabels_.push_back(std::make_pair(TrackerIso, depconf.getParameter<edm::InputTag>("tracker")));
-  //      if (depconf.exists("ecal"))    isoDepositLabels_.push_back(std::make_pair(ECalIso, depconf.getParameter<edm::InputTag>("ecal")));
-  //      if (depconf.exists("hcal"))    isoDepositLabels_.push_back(std::make_pair(HCalIso, depconf.getParameter<edm::InputTag>("hcal")));
-
-
-  //      if (depconf.exists("user")) {
-  //         std::vector<edm::InputTag> userdeps = depconf.getParameter<std::vector<edm::InputTag> >("user");
-  //         std::vector<edm::InputTag>::const_iterator it = userdeps.begin(), ed = userdeps.end();
-  //         int key = UserBaseIso;
-  //         for ( ; it != ed; ++it, ++key) {
-  //             isoDepositLabels_.push_back(std::make_pair(IsolationKeys(key), *it));
-  //         }
-  //      }
-  //   }
-
-  // read isoDeposit labels, for direct embedding
-  readIsolationLabels(iConfig, "isoDeposits", isoDepositLabels_);
-  // read isolation value labels, for direct embedding
-  readIsolationLabels(iConfig, "isolationValues", isolationValueLabels_);
-  // read isolation value labels for non PF identified electron, for direct embedding
-  readIsolationLabels(iConfig, "isolationValuesNoPFId", isolationValueLabelsNoPFId_);
-  // Efficiency configurables
-  addEfficiencies_ = iConfig.getParameter<bool>("addEfficiencies");
-  if (addEfficiencies_) {
-    efficiencyLoader_ = pat::helper::EfficiencyLoader(iConfig.getParameter<edm::ParameterSet>("efficiencies"));
-  }
-  // Check to see if the user wants to add user data
-  if ( useUserData_ ) {
-    userDataHelper_ = PATUserDataHelper<Electron>(iConfig.getParameter<edm::ParameterSet>("userData"));
-  }
-  // embed high level selection variables?
-  embedHighLevelSelection_ = iConfig.getParameter<bool>("embedHighLevelSelection");
-  beamLineSrc_ = iConfig.getParameter<edm::InputTag>("beamLineSrc");
-  if ( embedHighLevelSelection_ ) {
-    usePV_ = iConfig.getParameter<bool>("usePV");
-    pvSrc_ = iConfig.getParameter<edm::InputTag>("pvSrc");
-  }
-  // produces vector of muons
-  produces<std::vector<Electron> >();
-  }
-
-
-  PATElectronProducer::~PATElectronProducer() 
-{
-}
-
-
-void PATElectronProducer::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) 
-{
-  // switch off embedding (in unschedules mode)
-  if (iEvent.isRealData()){
-    addGenMatch_ = false;
-    embedGenMatch_ = false;
-  }
-
-  edm::ESHandle<CaloTopology> theCaloTopology;
-  iSetup.get<CaloTopologyRecord>().get(theCaloTopology);
-  ecalTopology_ = & (*theCaloTopology);
-
-  // Get the collection of electrons from the event
-  edm::Handle<edm::View<reco::GsfElectron> > electrons;
-  iEvent.getByLabel(electronSrc_, electrons);
-
-  // for additional mva variables
-  edm::InputTag  reducedEBRecHitCollection(string("reducedEcalRecHitsEB"));
-  edm::InputTag  reducedEERecHitCollection(string("reducedEcalRecHitsEE"));
-  //EcalClusterLazyTools lazyTools(iEvent, iSetup, reducedEBRecHitCollection, reducedEERecHitCollection);
-  EcalClusterLazyTools lazyTools(iEvent, iSetup, reducedBarrelRecHitCollection_, reducedEndcapRecHitCollection_);
-
-  // for conversion veto selection
-  edm::Handle<reco::ConversionCollection> hConversions;
-  iEvent.getByLabel("allConversions", hConversions);
-
-  // Get the ESHandle for the transient track builder, if needed for
-  // high level selection embedding
-  edm::ESHandle<TransientTrackBuilder> trackBuilder;
-
-  if (isolator_.enabled()) isolator_.beginEvent(iEvent,iSetup);
-
-  if (efficiencyLoader_.enabled()) efficiencyLoader_.newEvent(iEvent);
-  if (resolutionLoader_.enabled()) resolutionLoader_.newEvent(iEvent, iSetup);
-
-  IsoDepositMaps deposits(isoDepositLabels_.size());
-  for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-    iEvent.getByLabel(isoDepositLabels_[j].second, deposits[j]);
-  }
-
-  IsolationValueMaps isolationValues(isolationValueLabels_.size());
-  for (size_t j = 0; j<isolationValueLabels_.size(); ++j) {
-    iEvent.getByLabel(isolationValueLabels_[j].second, isolationValues[j]);
-  }
-
-  IsolationValueMaps isolationValuesNoPFId(isolationValueLabelsNoPFId_.size());
-  for (size_t j = 0; j<isolationValueLabelsNoPFId_.size(); ++j) {
-    iEvent.getByLabel(isolationValueLabelsNoPFId_[j].second, isolationValuesNoPFId[j]);
-  }
-
-  // prepare the MC matching
-  GenAssociations  genMatches(genMatchSrc_.size());
-  if (addGenMatch_) {
-    for (size_t j = 0, nd = genMatchSrc_.size(); j < nd; ++j) {
-      iEvent.getByLabel(genMatchSrc_[j], genMatches[j]);
-    }
-  }
-
-  // prepare ID extraction
-  std::vector<edm::Handle<edm::ValueMap<float> > > idhandles;
-  std::vector<pat::Electron::IdPair>               ids;
-  if (addElecID_) {
-    idhandles.resize(elecIDSrcs_.size());
-    ids.resize(elecIDSrcs_.size());
-    for (size_t i = 0; i < elecIDSrcs_.size(); ++i) {
-      iEvent.getByLabel(elecIDSrcs_[i].second, idhandles[i]);
-      ids[i].first = elecIDSrcs_[i].first;
-    }
-  }
-
-
-  // prepare the high level selection:
-  // needs beamline
-  reco::TrackBase::Point beamPoint(0,0,0);
-  reco::Vertex primaryVertex;
-  reco::BeamSpot beamSpot;
-  bool beamSpotIsValid = false;
-  bool primaryVertexIsValid = false;
-
-  // Get the beamspot
-  edm::Handle<reco::BeamSpot> beamSpotHandle;
-  iEvent.getByLabel(beamLineSrc_, beamSpotHandle);
-
-  if ( embedHighLevelSelection_ ) {
-    // Get the primary vertex
-    edm::Handle< std::vector<reco::Vertex> > pvHandle;
-    iEvent.getByLabel( pvSrc_, pvHandle );
-
-    // This is needed by the IPTools methods from the tracking group
-    iSetup.get<TransientTrackRecord>().get("TransientTrackBuilder", trackBuilder);
-
-    if ( ! usePV_ ) {
-
-      if ( beamSpotHandle.isValid() ){
-        beamSpot = *beamSpotHandle;
-        beamSpotIsValid = true;
-      } else{
-        edm::LogError("DataNotAvailable")
-          << "No beam spot available from EventSetup, not adding high level selection \n";
-      }
-
-      double x0 = beamSpot.x0();
-      double y0 = beamSpot.y0();
-      double z0 = beamSpot.z0();
-
-      beamPoint = reco::TrackBase::Point ( x0, y0, z0 );
-    } else {
-      if ( pvHandle.isValid() && !pvHandle->empty() ) {
-	primaryVertex = pvHandle->at(0);
-	primaryVertexIsValid = true;
-      } else {
-	edm::LogError("DataNotAvailable")
-	  << "No primary vertex available from EventSetup, not adding high level selection \n";
-      }
-    }
-  }
-
-  std::vector<Electron> * patElectrons = new std::vector<Electron>();
-
-  if( useParticleFlow_ ) {
-    edm::Handle< reco::PFCandidateCollection >  pfElectrons;
-    iEvent.getByLabel(pfElecSrc_, pfElectrons);
-    unsigned index=0;
-
-    for( reco::PFCandidateConstIterator i = pfElectrons->begin();
-	 i != pfElectrons->end(); ++i, ++index) {
-
-      reco::PFCandidateRef pfRef(pfElectrons, index);
-      reco::PFCandidatePtr ptrToPFElectron(pfElectrons,index);
-//       reco::CandidateBaseRef pfBaseRef( pfRef );
-
-      reco::GsfTrackRef PfTk= i->gsfTrackRef();
-
-      bool Matched=false;
-      bool MatchedToAmbiguousGsfTrack=false;
-      for (edm::View<reco::GsfElectron>::const_iterator itElectron = electrons->begin(); itElectron != electrons->end(); ++itElectron) {
-	unsigned int idx = itElectron - electrons->begin();
-	if (Matched || MatchedToAmbiguousGsfTrack) continue;
-
-	reco::GsfTrackRef EgTk= itElectron->gsfTrack();
-
-	if (itElectron->gsfTrack()==i->gsfTrackRef()){
-	  Matched=true;
-	}
-	else {
-	  for( reco::GsfTrackRefVector::const_iterator it = itElectron->ambiguousGsfTracksBegin() ;
-	       it!=itElectron->ambiguousGsfTracksEnd(); it++ ){
-	    MatchedToAmbiguousGsfTrack |= (bool)(i->gsfTrackRef()==(*it));
-	  }
-	}
-
-	if (Matched || MatchedToAmbiguousGsfTrack){
-
-	  // ptr needed for finding the matched gen particle
-	  reco::CandidatePtr ptrToGsfElectron(electrons,idx);
-
-	  // ref to base needed for the construction of the pat object
-	  const edm::RefToBase<reco::GsfElectron>& elecsRef = electrons->refAt(idx);
-	  Electron anElectron(elecsRef);
-	  anElectron.setPFCandidateRef( pfRef  );
-
-          //it should be always true when particleFlow electrons are used.
-          anElectron.setIsPF( true );
-
-	  if( embedPFCandidate_ ) anElectron.embedPFCandidate();
-
-	  if ( useUserData_ ) {
-	    userDataHelper_.add( anElectron, iEvent, iSetup );
-	  }
-
-          double ip3d = -999; // for mva variable
-
-	  // embed high level selection
-	  if ( embedHighLevelSelection_ ) {
-	    // get the global track
-	    reco::GsfTrackRef track = PfTk;
-
-	    // Make sure the collection it points to is there
-	    if ( track.isNonnull() && track.isAvailable() ) {
-
-	      reco::TransientTrack tt = trackBuilder->build(track);
-	      embedHighLevel( anElectron,
-			      track,
-			      tt,
-			      primaryVertex,
-			      primaryVertexIsValid,
-			      beamSpot,
-			      beamSpotIsValid );
-
-              std::pair<bool,Measurement1D> ip3dpv = IPTools::absoluteImpactParameter3D(tt, primaryVertex);
-              ip3d = ip3dpv.second.value(); // for mva variable
-
-	      if ( !usePV_ ) {
-		double corr_d0 = track->dxy( beamPoint );
-		anElectron.setDB( corr_d0, -1.0 );
-	      } else {
-                 std::pair<bool,Measurement1D> result = IPTools::absoluteTransverseImpactParameter(tt, primaryVertex);
-                double d0_corr = result.second.value();
-                double d0_err = result.second.error();
-		anElectron.setDB( d0_corr, d0_err );
-	      }
-	    }
-	  }
-
-	  //Electron Id
-
-	  if (addElecID_) {
-	    //STANDARD EL ID
-	    for (size_t i = 0; i < elecIDSrcs_.size(); ++i) {
-	      ids[i].second = (*idhandles[i])[elecsRef];
-	    }
-	    //SPECIFIC PF ID
-	    ids.push_back(std::make_pair("pf_evspi",pfRef->mva_e_pi()));
-	    ids.push_back(std::make_pair("pf_evsmu",pfRef->mva_e_mu()));
-	    anElectron.setElectronIDs(ids);
-	  }
-
-          // add missing mva variables
-          double r9 = lazyTools.e3x3( *( itElectron->superCluster()->seed())) / itElectron->superCluster()->rawEnergy() ;
-          double sigmaIphiIphi;
-          double sigmaIetaIphi;
-          std::vector<float> vCov = lazyTools.localCovariances(*( itElectron->superCluster()->seed()));
-          if( !isnan(vCov[2])) sigmaIphiIphi = sqrt(vCov[2]);
-          else sigmaIphiIphi = 0;
-          sigmaIetaIphi = vCov[1];
-          anElectron.setMvaVariables( r9, sigmaIphiIphi, sigmaIetaIphi, ip3d);
-
-	  // get list of EcalDetId within 5x5 around the seed 
-	  bool barrel = itElectron->isEB();
-	  DetId seed = lazyTools.getMaximum(*(itElectron->superCluster()->seed())).first;
-	  std::vector<DetId> selectedCells = (barrel) ? ecalTopology_->getSubdetectorTopology(DetId::Ecal,EcalBarrel)->getWindow(seed,5,5):
-	    ecalTopology_->getSubdetectorTopology(DetId::Ecal,EcalEndcap)->getWindow(seed,5,5);          
-
-	  // Do it for all basic clusters in 5x5
-	  reco::CaloCluster_iterator itscl = itElectron->superCluster()->clustersBegin();
-	  reco::CaloCluster_iterator itsclE = itElectron->superCluster()->clustersEnd();
-	  std::vector<DetId> cellsIn5x5;
-	  for ( ; itscl!= itsclE ; ++ itscl) {
-	    DetId seed=lazyTools.getMaximum(*(*itscl)).first;
-	    bool bcbarrel = seed.subdetId()==EcalBarrel; 
-	    std::vector<DetId> cellsToAdd = (bcbarrel) ? ecalTopology_->getSubdetectorTopology(DetId::Ecal,EcalBarrel)->getWindow(seed,5,5):
-	      ecalTopology_->getSubdetectorTopology(DetId::Ecal,EcalEndcap)->getWindow(seed,5,5);
-	    cellsIn5x5.insert(cellsIn5x5.end(),cellsToAdd.begin(), cellsToAdd.end());
-
-	  }
-
-	  // Add to the list of selectedCells checking that there is no duplicate 
-	  unsigned nCellsIn5x5 = cellsIn5x5.size() ;
-
-	  for(unsigned i=0; i< nCellsIn5x5 ; ++i ) {
-	    std::vector<DetId>::const_iterator itcheck = find(selectedCells.begin(), selectedCells.end(),cellsIn5x5[i]);
-	    if (itcheck == selectedCells.end())
-	      selectedCells.push_back(cellsIn5x5[i]);
-	  }
-
-
-	  // add the DetId of the SC
-	  std::vector< std::pair<DetId, float> >::const_iterator it=itElectron->superCluster()->hitsAndFractions().begin();
-	  std::vector< std::pair<DetId, float> >::const_iterator itend=itElectron->superCluster()->hitsAndFractions().end();
-	  for( ; it!=itend ; ++it) {
-	    DetId id=it->first;
-	    // check if already saved
-	    std::vector<DetId>::const_iterator itcheck = find(selectedCells.begin(),selectedCells.end(),id);
-	    if ( itcheck == selectedCells.end()) {
-	      selectedCells.push_back(id);
-	    }
-	  }
-	  // Retrieve the corresponding RecHits
-
-	  edm::Handle< EcalRecHitCollection > rechitsH ;
-	  if(barrel) 
-	    iEvent.getByLabel(reducedBarrelRecHitCollection_,rechitsH);
-	  else
-	    iEvent.getByLabel(reducedEndcapRecHitCollection_,rechitsH);
-
-	  EcalRecHitCollection selectedRecHits;
-	  const EcalRecHitCollection *recHits = rechitsH.product();
-
-	  unsigned nSelectedCells = selectedCells.size();
-	  for (unsigned icell = 0 ; icell < nSelectedCells ; ++icell) {
-	   EcalRecHitCollection::const_iterator  it = recHits->find( selectedCells[icell] );
-	    if ( it != recHits->end() ) {
-	      selectedRecHits.push_back(*it);
-	    }
-	  }
-	  selectedRecHits.sort();
-	  if (embedRecHits_) anElectron.embedRecHits(& selectedRecHits);
-         
-	    // set conversion veto selection
-          bool passconversionveto = false;
-          if( hConversions.isValid()){
-            // this is recommended method
-            passconversionveto = !ConversionTools::hasMatchedConversion( *itElectron, hConversions, beamSpotHandle->position());
-          }else{
-            // use missing hits without vertex fit method
-            passconversionveto = itElectron->gsfTrack()->trackerExpectedHitsInner().numberOfLostHits() < 1;
-          }
-
-          anElectron.setPassConversionVeto( passconversionveto );
-
-
-// 	  fillElectron(anElectron,elecsRef,pfBaseRef,
-// 		       genMatches, deposits, isolationValues);
-
-	  //COLIN small warning !
-	  // we are currently choosing to take the 4-momentum of the PFCandidate;
-	  // the momentum of the GsfElectron is saved though
-	  // we must therefore match the GsfElectron.
-	  // because of this, we should not change the source of the electron matcher
-	  // to the collection of PFElectrons in the python configuration
-	  // I don't know what to do with the efficiencyLoader, since I don't know
-	  // what this class is for.
-	  fillElectron2( anElectron,
-			 ptrToPFElectron,
-			 ptrToGsfElectron,
-			 ptrToGsfElectron,
-			 genMatches, deposits, isolationValues );
-
-	  //COLIN need to use fillElectron2 in the non-pflow case as well, and to test it.
-
-	  patElectrons->push_back(anElectron);
-	}
-      }
-      //if( !Matched && !MatchedToAmbiguousGsfTrack) std::cout << "!!!!A pf electron could not be matched to a gsf!!!!"  << std::endl;
-    }
-  }
-
-  else{
-    // Try to access PF electron collection
-    edm::Handle<edm::ValueMap<reco::PFCandidatePtr> >ValMapH;
-    bool valMapPresent = iEvent.getByLabel(pfCandidateMap_,ValMapH);
-    // Try to access a PFCandidate collection, as supplied by the user
-    edm::Handle< reco::PFCandidateCollection >  pfElectrons;
-    bool pfCandsPresent = iEvent.getByLabel(pfElecSrc_, pfElectrons);
-
-    for (edm::View<reco::GsfElectron>::const_iterator itElectron = electrons->begin(); itElectron != electrons->end(); ++itElectron) {
-      // construct the Electron from the ref -> save ref to original object
-      //FIXME: looks like a lot of instances could be turned into const refs
-      unsigned int idx = itElectron - electrons->begin();
-      edm::RefToBase<reco::GsfElectron> elecsRef = electrons->refAt(idx);
-      reco::CandidateBaseRef elecBaseRef(elecsRef);
-      Electron anElectron(elecsRef);
-
-      // Is this GsfElectron also identified as an e- in the particle flow?
-      bool pfId = false;
-
-      if ( pfCandsPresent ) {
-	// PF electron collection not available.
-	const reco::GsfTrackRef& trkRef = itElectron->gsfTrack();
-        int index = 0;
-	for( reco::PFCandidateConstIterator ie = pfElectrons->begin();
-	     ie != pfElectrons->end(); ++ie, ++index) {
-	  if(ie->particleId()!=reco::PFCandidate::e) continue;
-	  const reco::GsfTrackRef& pfTrkRef= ie->gsfTrackRef();
-	  if( trkRef == pfTrkRef ) {
-	    pfId = true;
-            reco::PFCandidateRef pfRef(pfElectrons, index);
-            anElectron.setPFCandidateRef( pfRef );
-	    break;
-	  }
-	}
-      }
-      else if ( valMapPresent) {
-        // use value map if PF collection not available
-        const edm::ValueMap<reco::PFCandidatePtr> & myValMap(*ValMapH);
-        // Get the PFCandidate
-        const reco::PFCandidatePtr& pfElePtr(myValMap[elecsRef]);
-        pfId= pfElePtr.isNonnull();
-      }
-      // set PFId function
-      anElectron.setIsPF( pfId ); 
-
-      // add resolution info
-
-      // Isolation
-      if (isolator_.enabled()) {
-        isolator_.fill(*electrons, idx, isolatorTmpStorage_);
-        typedef pat::helper::MultiIsolator::IsolationValuePairs IsolationValuePairs;
-        // better to loop backwards, so the vector is resized less times
-        for (IsolationValuePairs::const_reverse_iterator it = isolatorTmpStorage_.rbegin(), ed = isolatorTmpStorage_.rend(); it != ed; ++it) {
-	  anElectron.setIsolation(it->first, it->second);
-        }
-      }
-
-      for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-        anElectron.setIsoDeposit(isoDepositLabels_[j].first, (*deposits[j])[elecsRef]);
-      }
-
-      // add electron ID info
-      if (addElecID_) {
-        for (size_t i = 0; i < elecIDSrcs_.size(); ++i) {
-	  ids[i].second = (*idhandles[i])[elecsRef];
-        }
-        anElectron.setElectronIDs(ids);
-      }
-
-
-      if ( useUserData_ ) {
-	userDataHelper_.add( anElectron, iEvent, iSetup );
-      }
-
-
-      double ip3d = -999; //for mva variable
-
-      // embed high level selection
-      if ( embedHighLevelSelection_ ) {
-	// get the global track
-	reco::GsfTrackRef track = itElectron->gsfTrack();
-
-	// Make sure the collection it points to is there
-	if ( track.isNonnull() && track.isAvailable() ) {
-
-	  reco::TransientTrack tt = trackBuilder->build(track);
-	  embedHighLevel( anElectron,
-			  track,
-			  tt,
-			  primaryVertex,
-			  primaryVertexIsValid,
-			  beamSpot,
-			  beamSpotIsValid );
-
-          std::pair<bool,Measurement1D> ip3dpv = IPTools::absoluteImpactParameter3D(tt, primaryVertex);
-          ip3d = ip3dpv.second.value(); // for mva variable
-
-	  if ( !usePV_ ) {
-	    double corr_d0 = track->dxy( beamPoint );
-	    anElectron.setDB( corr_d0, -1.0 );
-	  } else {
-            std::pair<bool,Measurement1D> result = IPTools::absoluteTransverseImpactParameter(tt, primaryVertex);
-            double d0_corr = result.second.value();
-            double d0_err = result.second.error();
-	    anElectron.setDB( d0_corr, d0_err );
-	  }
-	}
-      }
-
-      // add mva variables
-      double r9 = lazyTools.e3x3( *( itElectron->superCluster()->seed())) / itElectron->superCluster()->rawEnergy() ;
-      double sigmaIphiIphi;
-      double sigmaIetaIphi;
-      std::vector<float> vCov = lazyTools.localCovariances(*( itElectron->superCluster()->seed()));
-      if( !isnan(vCov[2])) sigmaIphiIphi = sqrt(vCov[2]);
-      else sigmaIphiIphi = 0;
-      sigmaIetaIphi = vCov[1];
-      anElectron.setMvaVariables( r9, sigmaIphiIphi, sigmaIetaIphi, ip3d);
-
-      // get list of EcalDetId within 5x5 around the seed 
-      bool barrel= itElectron->isEB();
-	
-      DetId seed=lazyTools.getMaximum(*(itElectron->superCluster()->seed())).first;
-      std::vector<DetId> selectedCells = (barrel) ? ecalTopology_->getSubdetectorTopology(DetId::Ecal,EcalBarrel)->getWindow(seed,5,5):
-	ecalTopology_->getSubdetectorTopology(DetId::Ecal,EcalEndcap)->getWindow(seed,5,5);
-
-
-      // Do it for all basic clusters in 5x5
-      reco::CaloCluster_iterator itscl = itElectron->superCluster()->clustersBegin();
-      reco::CaloCluster_iterator itsclE = itElectron->superCluster()->clustersEnd();
-      std::vector<DetId> cellsIn5x5;
-      for ( ; itscl!= itsclE ; ++ itscl) {
-	DetId seed=lazyTools.getMaximum(*(*itscl)).first;
-	bool bcbarrel = seed.subdetId()==EcalBarrel; 
-	std::vector<DetId> cellsToAdd = (bcbarrel) ? ecalTopology_->getSubdetectorTopology(DetId::Ecal,EcalBarrel)->getWindow(seed,5,5):
-	  ecalTopology_->getSubdetectorTopology(DetId::Ecal,EcalEndcap)->getWindow(seed,5,5);
-	cellsIn5x5.insert(cellsIn5x5.end(),cellsToAdd.begin(), cellsToAdd.end());
-
-      }
-      // Add to the list of selectedCells checking that there is no duplicate 
-      unsigned nCellsIn5x5 = cellsIn5x5.size() ;
-
-      for(unsigned i=0; i< nCellsIn5x5 ; ++i ) {
-	std::vector<DetId>::const_iterator itcheck = find(selectedCells.begin(), selectedCells.end(),cellsIn5x5[i]);
-	if (itcheck == selectedCells.end())
-	  selectedCells.push_back(cellsIn5x5[i]);
-      }
-
-      // Add all RecHits of the SC if not already present
-      std::vector< std::pair<DetId, float> >::const_iterator it=itElectron->superCluster()->hitsAndFractions().begin();
-      std::vector< std::pair<DetId, float> >::const_iterator itend=itElectron->superCluster()->hitsAndFractions().end();
-      for( ; it!=itend ; ++it) {
-	DetId id=it->first;
-	// check if already saved
-	std::vector<DetId>::const_iterator itcheck = find(selectedCells.begin(),selectedCells.end(),id);
-	if ( itcheck == selectedCells.end()) {
-	  selectedCells.push_back(id);
-	}
-      }
-      // Retrieve the corresponding RecHits
-
-      edm::Handle< EcalRecHitCollection > rechitsH ;
-      if(barrel)
-	iEvent.getByLabel(reducedBarrelRecHitCollection_,rechitsH);
-      else
-	iEvent.getByLabel(reducedEndcapRecHitCollection_,rechitsH);
-
-      EcalRecHitCollection selectedRecHits;
-      const EcalRecHitCollection *recHits = rechitsH.product();
-
-      unsigned nSelectedCells = selectedCells.size();
-      for (unsigned icell = 0 ; icell < nSelectedCells ; ++icell) {
-        EcalRecHitCollection::const_iterator  it = recHits->find( selectedCells[icell] );
-	if ( it != recHits->end() ) {
-	  selectedRecHits.push_back(*it);
-	}
-      }
-      selectedRecHits.sort();
-      if (embedRecHits_) anElectron.embedRecHits(& selectedRecHits);
-
-      // set conversion veto selection
-      bool passconversionveto = false;
-      if( hConversions.isValid()){
-        // this is recommended method
-        passconversionveto = !ConversionTools::hasMatchedConversion( *itElectron, hConversions, beamSpotHandle->position());
-      }else{
-        // use missing hits without vertex fit method
-        passconversionveto = itElectron->gsfTrack()->trackerExpectedHitsInner().numberOfLostHits() < 1;
-      }
-      anElectron.setPassConversionVeto( passconversionveto );
-
-      // add sel to selected
-      fillElectron( anElectron, elecsRef,elecBaseRef,
-		    genMatches, deposits, pfId, isolationValues, isolationValuesNoPFId);
-      patElectrons->push_back(anElectron);
-    }
-  }
-
-  // sort electrons in pt
-  std::sort(patElectrons->begin(), patElectrons->end(), pTComparator_);
-
-  // add the electrons to the event output
-  std::auto_ptr<std::vector<Electron> > ptr(patElectrons);
-  iEvent.put(ptr);
-
-  // clean up
-  if (isolator_.enabled()) isolator_.endEvent();
-
-}
-
-void PATElectronProducer::fillElectron(Electron& anElectron,
-				       const edm::RefToBase<reco::GsfElectron>& elecRef,
-				       const reco::CandidateBaseRef& baseRef,
-				       const GenAssociations& genMatches,
-				       const IsoDepositMaps& deposits,
-                                       const bool pfId,
-				       const IsolationValueMaps& isolationValues,
-				       const IsolationValueMaps& isolationValuesNoPFId
-				       ) const {
-
-  //COLIN: might want to use the PFCandidate 4-mom. Which one is in use now?
-  //   if (useParticleFlow_)
-  //     aMuon.setP4( aMuon.pfCandidateRef()->p4() );
-
-  //COLIN:
-  //In the embedding case, the reference cannot be used to look into a value map.
-  //therefore, one has to had the PFCandidateRef to this function, which becomes a bit
-  //too much specific.
-
-  // in fact, this function needs a baseref or ptr for genmatch
-  // and a baseref or ptr for isodeposits and isolationvalues.
-  // baseref is not needed
-  // the ptrForIsolation and ptrForMatching should be defined upstream.
-
-  // is the concrete elecRef needed for the efficiency loader? what is this loader?
-  // how can we make it compatible with the particle flow electrons?
-
-  if (embedGsfElectronCore_) anElectron.embedGsfElectronCore();
-  if (embedGsfTrack_) anElectron.embedGsfTrack();
-  if (embedSuperCluster_) anElectron.embedSuperCluster();
-  if (embedPflowSuperCluster_) anElectron.embedPflowSuperCluster();
-  if (embedSeedCluster_) anElectron.embedSeedCluster();
-  if (embedBasicClusters_) anElectron.embedBasicClusters();
-  if (embedPreshowerClusters_) anElectron.embedPreshowerClusters();
-  if (embedPflowBasicClusters_ ) anElectron.embedPflowBasicClusters();
-  if (embedPflowPreshowerClusters_ ) anElectron.embedPflowPreshowerClusters();
-  if (embedTrack_) anElectron.embedTrack();
-
-  // store the match to the generated final state muons
-  if (addGenMatch_) {
-    for(size_t i = 0, n = genMatches.size(); i < n; ++i) {
-      if(useParticleFlow_) {
-	reco::GenParticleRef genElectron = (*genMatches[i])[anElectron.pfCandidateRef()];
-	anElectron.addGenParticleRef(genElectron);
-      }
-      else {
-	reco::GenParticleRef genElectron = (*genMatches[i])[elecRef];
-	anElectron.addGenParticleRef(genElectron);
-      }
-    }
-    if (embedGenMatch_) anElectron.embedGenParticle();
-  }
-
-  if (efficiencyLoader_.enabled()) {
-    efficiencyLoader_.setEfficiencies( anElectron, elecRef );
-  }
-
-  if (resolutionLoader_.enabled()) {
-    resolutionLoader_.setResolutions(anElectron);
-  }
-
-  for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-    if(useParticleFlow_) {
-
-      reco::PFCandidateRef pfcandref =  anElectron.pfCandidateRef();
-      assert(!pfcandref.isNull());
-      reco::CandidatePtr source = pfcandref->sourceCandidatePtr(0);
-      anElectron.setIsoDeposit(isoDepositLabels_[j].first,
-			  (*deposits[j])[source]);
-    }
-    else
-      anElectron.setIsoDeposit(isoDepositLabels_[j].first,
-                          (*deposits[j])[elecRef]);
-  }
-
-  for (size_t j = 0; j<isolationValues.size(); ++j) {
-    if(useParticleFlow_) {
-      reco::CandidatePtr source = anElectron.pfCandidateRef()->sourceCandidatePtr(0);
-      anElectron.setIsolation(isolationValueLabels_[j].first,
-			 (*isolationValues[j])[source]);
-    }
-    else
-      if(pfId){
-        anElectron.setIsolation(isolationValueLabels_[j].first,(*isolationValues[j])[elecRef]);
-      }
-  }
-
-  //for electrons not identified as PF electrons
-  for (size_t j = 0; j<isolationValuesNoPFId.size(); ++j) {
-    if( !pfId) {
-      anElectron.setIsolation(isolationValueLabelsNoPFId_[j].first,(*isolationValuesNoPFId[j])[elecRef]);
-    }
-  }
-
-}
-
-void PATElectronProducer::fillElectron2( Electron& anElectron,
-					 const reco::CandidatePtr& candPtrForIsolation,
-					 const reco::CandidatePtr& candPtrForGenMatch,
-					 const reco::CandidatePtr& candPtrForLoader,
-					 const GenAssociations& genMatches,
-					 const IsoDepositMaps& deposits,
-					 const IsolationValueMaps& isolationValues) const {
-
-  //COLIN/Florian: use the PFCandidate 4-mom.
-  anElectron.setEcalDrivenMomentum(anElectron.p4()) ;
-  anElectron.setP4( anElectron.pfCandidateRef()->p4() );
-
-
-  // is the concrete elecRef needed for the efficiency loader? what is this loader?
-  // how can we make it compatible with the particle flow electrons?
-
-  if (embedGsfElectronCore_) anElectron.embedGsfElectronCore();
-  if (embedGsfTrack_) anElectron.embedGsfTrack();
-  if (embedSuperCluster_) anElectron.embedSuperCluster();
-  if (embedPflowSuperCluster_ ) anElectron.embedPflowSuperCluster();
-  if (embedSeedCluster_) anElectron.embedSeedCluster();
-  if (embedBasicClusters_) anElectron.embedBasicClusters();
-  if (embedPreshowerClusters_) anElectron.embedPreshowerClusters();
-  if (embedPflowBasicClusters_ ) anElectron.embedPflowBasicClusters();
-  if (embedPflowPreshowerClusters_ ) anElectron.embedPflowPreshowerClusters();
-  if (embedTrack_) anElectron.embedTrack();
-
-  // store the match to the generated final state muons
-
-  if (addGenMatch_) {
-    for(size_t i = 0, n = genMatches.size(); i < n; ++i) {
-      reco::GenParticleRef genElectron = (*genMatches[i])[candPtrForGenMatch];
-      anElectron.addGenParticleRef(genElectron);
-    }
-    if (embedGenMatch_) anElectron.embedGenParticle();
-  }
-
-  //COLIN what's this? does it have to be GsfElectron specific?
-  if (efficiencyLoader_.enabled()) {
-    efficiencyLoader_.setEfficiencies( anElectron, candPtrForLoader );
-  }
-
-  if (resolutionLoader_.enabled()) {
-    resolutionLoader_.setResolutions(anElectron);
-  }
-
-  for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-    if( isoDepositLabels_[j].first==pat::TrackIso ||
-	isoDepositLabels_[j].first==pat::EcalIso ||
-	isoDepositLabels_[j].first==pat::HcalIso ||
-	deposits[j]->contains(candPtrForGenMatch.id())) {
-      anElectron.setIsoDeposit(isoDepositLabels_[j].first,
- 			       (*deposits[j])[candPtrForGenMatch]);
-    }
-    else if (deposits[j]->contains(candPtrForIsolation.id())) {
-      anElectron.setIsoDeposit(isoDepositLabels_[j].first,
- 			       (*deposits[j])[candPtrForIsolation]);
-    }
-    else {
-      anElectron.setIsoDeposit(isoDepositLabels_[j].first,
-			       (*deposits[j])[candPtrForIsolation->sourceCandidatePtr(0)]);
-    }
-  }
-
-  for (size_t j = 0; j<isolationValues.size(); ++j) {
-    if( isolationValueLabels_[j].first==pat::TrackIso ||
-	isolationValueLabels_[j].first==pat::EcalIso ||
-	isolationValueLabels_[j].first==pat::HcalIso ||
-	isolationValues[j]->contains(candPtrForGenMatch.id())) {
-      anElectron.setIsolation(isolationValueLabels_[j].first,
- 			      (*isolationValues[j])[candPtrForGenMatch]);
-    }
-    else if (isolationValues[j]->contains(candPtrForIsolation.id())) {
-      anElectron.setIsolation(isolationValueLabels_[j].first,
- 			      (*isolationValues[j])[candPtrForIsolation]);
-    }
-    else {
-      anElectron.setIsolation(isolationValueLabels_[j].first,
-			      (*isolationValues[j])[candPtrForIsolation->sourceCandidatePtr(0)]);
-    }
-  }
-}
-
-
-// ParameterSet description for module
-void PATElectronProducer::fillDescriptions(edm::ConfigurationDescriptions & descriptions)
-{
-  edm::ParameterSetDescription iDesc;
-  iDesc.setComment("PAT electron producer module");
-
-  // input source
-  iDesc.add<edm::InputTag>("pfCandidateMap", edm::InputTag("no default"))->setComment("input collection");
-  iDesc.add<edm::InputTag>("electronSource", edm::InputTag("no default"))->setComment("input collection");
-
-  // embedding
-  iDesc.add<bool>("embedGsfElectronCore", true)->setComment("embed external gsf electron core");
-  iDesc.add<bool>("embedGsfTrack", true)->setComment("embed external gsf track");
-  iDesc.add<bool>("embedSuperCluster", true)->setComment("embed external super cluster");
-  iDesc.add<bool>("embedPflowSuperCluster", true)->setComment("embed external super cluster");
-  iDesc.add<bool>("embedSeedCluster", true)->setComment("embed external seed cluster");
-  iDesc.add<bool>("embedBasicClusters", true)->setComment("embed external basic clusters");
-  iDesc.add<bool>("embedPreshowerClusters", true)->setComment("embed external preshower clusters");
-  iDesc.add<bool>("embedPflowBasicClusters", true)->setComment("embed external pflow basic clusters");
-  iDesc.add<bool>("embedPflowPreshowerClusters", true)->setComment("embed external pflow preshower clusters");
-  iDesc.add<bool>("embedTrack", false)->setComment("embed external track");
-  iDesc.add<bool>("embedRecHits", true)->setComment("embed external RecHits");
-
-  // pf specific parameters
-  iDesc.add<edm::InputTag>("pfElectronSource", edm::InputTag("pfElectrons"))->setComment("particle flow input collection");
-  iDesc.add<bool>("useParticleFlow", false)->setComment("whether to use particle flow or not");
-  iDesc.add<bool>("embedPFCandidate", false)->setComment("embed external particle flow object");
-
-  // MC matching configurables
-  iDesc.add<bool>("addGenMatch", true)->setComment("add MC matching");
-  iDesc.add<bool>("embedGenMatch", false)->setComment("embed MC matched MC information");
-  std::vector<edm::InputTag> emptySourceVector;
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("genParticleMatch", edm::InputTag(), true) xor
-                 edm::ParameterDescription<std::vector<edm::InputTag> >("genParticleMatch", emptySourceVector, true)
-		 )->setComment("input with MC match information");
-
-  // electron ID configurables
-  iDesc.add<bool>("addElectronID",true)->setComment("add electron ID variables");
-  edm::ParameterSetDescription electronIDSourcesPSet;
-  electronIDSourcesPSet.setAllowAnything();
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("electronIDSource", edm::InputTag(), true) xor
-                 edm::ParameterDescription<edm::ParameterSetDescription>("electronIDSources", electronIDSourcesPSet, true)
-                 )->setComment("input with electron ID variables");
-
-
-  // IsoDeposit configurables
-  edm::ParameterSetDescription isoDepositsPSet;
-  isoDepositsPSet.addOptional<edm::InputTag>("tracker");
-  isoDepositsPSet.addOptional<edm::InputTag>("ecal");
-  isoDepositsPSet.addOptional<edm::InputTag>("hcal");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfAllParticles");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfChargedHadrons");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfChargedAll");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfPUChargedHadrons");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfNeutralHadrons");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfPhotons");
-  isoDepositsPSet.addOptional<std::vector<edm::InputTag> >("user");
-  iDesc.addOptional("isoDeposits", isoDepositsPSet);
-
-  // isolation values configurables
-  edm::ParameterSetDescription isolationValuesPSet;
-  isolationValuesPSet.addOptional<edm::InputTag>("tracker");
-  isolationValuesPSet.addOptional<edm::InputTag>("ecal");
-  isolationValuesPSet.addOptional<edm::InputTag>("hcal");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfAllParticles");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfChargedHadrons");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfChargedAll");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfPUChargedHadrons");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfNeutralHadrons");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfPhotons");
-  isolationValuesPSet.addOptional<std::vector<edm::InputTag> >("user");
-  iDesc.addOptional("isolationValues", isolationValuesPSet);
-
-  // isolation values configurables
-  edm::ParameterSetDescription isolationValuesNoPFIdPSet;
-  isolationValuesNoPFIdPSet.addOptional<edm::InputTag>("tracker");
-  isolationValuesNoPFIdPSet.addOptional<edm::InputTag>("ecal");
-  isolationValuesNoPFIdPSet.addOptional<edm::InputTag>("hcal");
-  isolationValuesNoPFIdPSet.addOptional<edm::InputTag>("pfAllParticles");
-  isolationValuesNoPFIdPSet.addOptional<edm::InputTag>("pfChargedHadrons");
-  isolationValuesNoPFIdPSet.addOptional<edm::InputTag>("pfChargedAll");
-  isolationValuesNoPFIdPSet.addOptional<edm::InputTag>("pfPUChargedHadrons");
-  isolationValuesNoPFIdPSet.addOptional<edm::InputTag>("pfNeutralHadrons");
-  isolationValuesNoPFIdPSet.addOptional<edm::InputTag>("pfPhotons");
-  isolationValuesNoPFIdPSet.addOptional<std::vector<edm::InputTag> >("user");
-  iDesc.addOptional("isolationValuesNoPFId", isolationValuesNoPFIdPSet);
-
-  // Efficiency configurables
-  edm::ParameterSetDescription efficienciesPSet;
-  efficienciesPSet.setAllowAnything(); // TODO: the pat helper needs to implement a description.
-  iDesc.add("efficiencies", efficienciesPSet);
-  iDesc.add<bool>("addEfficiencies", false);
-
-  // Check to see if the user wants to add user data
-  edm::ParameterSetDescription userDataPSet;
-  PATUserDataHelper<Electron>::fillDescription(userDataPSet);
-  iDesc.addOptional("userData", userDataPSet);
-
-  // electron shapes
-  iDesc.add<bool>("addElectronShapes", true);
-  iDesc.add<edm::InputTag>("reducedBarrelRecHitCollection", edm::InputTag("reducedEcalRecHitsEB"));
-  iDesc.add<edm::InputTag>("reducedEndcapRecHitCollection", edm::InputTag("reducedEcalRecHitsEE"));
-
-  edm::ParameterSetDescription isolationPSet;
-  isolationPSet.setAllowAnything(); // TODO: the pat helper needs to implement a description.
-  iDesc.add("userIsolation", isolationPSet);
-
-  // Resolution configurables
-  pat::helper::KinResolutionsLoader::fillDescription(iDesc);
-
-  iDesc.add<bool>("embedHighLevelSelection", true)->setComment("embed high level selection");
-  edm::ParameterSetDescription highLevelPSet;
-  highLevelPSet.setAllowAnything();
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("beamLineSrc", edm::InputTag(), true)
-                 )->setComment("input with high level selection");
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("pvSrc", edm::InputTag(), true)
-                 )->setComment("input with high level selection");
-  iDesc.addNode( edm::ParameterDescription<bool>("usePV", bool(), true)
-                 )->setComment("input with high level selection, use primary vertex (true) or beam line (false)");
-
-  descriptions.add("PATElectronProducer", iDesc);
-
-}
-
-
-
-void PATElectronProducer::readIsolationLabels( const edm::ParameterSet & iConfig,
-					       const char* psetName,
-					       IsolationLabels& labels) {
-
-  labels.clear();
-
-  if (iConfig.exists( psetName )) {
-    edm::ParameterSet depconf
-      = iConfig.getParameter<edm::ParameterSet>(psetName);
-
-    if (depconf.exists("tracker")) labels.push_back(std::make_pair(pat::TrackIso, depconf.getParameter<edm::InputTag>("tracker")));
-    if (depconf.exists("ecal"))    labels.push_back(std::make_pair(pat::EcalIso, depconf.getParameter<edm::InputTag>("ecal")));
-    if (depconf.exists("hcal"))    labels.push_back(std::make_pair(pat::HcalIso, depconf.getParameter<edm::InputTag>("hcal")));
-    if (depconf.exists("pfAllParticles"))  {
-      labels.push_back(std::make_pair(pat::PfAllParticleIso, depconf.getParameter<edm::InputTag>("pfAllParticles")));
-    }
-    if (depconf.exists("pfChargedHadrons"))  {
-      labels.push_back(std::make_pair(pat::PfChargedHadronIso, depconf.getParameter<edm::InputTag>("pfChargedHadrons")));
-    }
-    if (depconf.exists("pfChargedAll"))  {
-      labels.push_back(std::make_pair(pat::PfChargedAllIso, depconf.getParameter<edm::InputTag>("pfChargedAll")));
-    }
-    if (depconf.exists("pfPUChargedHadrons"))  {
-      labels.push_back(std::make_pair(pat::PfPUChargedHadronIso, depconf.getParameter<edm::InputTag>("pfPUChargedHadrons")));
-    }
-    if (depconf.exists("pfNeutralHadrons"))  {
-      labels.push_back(std::make_pair(pat::PfNeutralHadronIso, depconf.getParameter<edm::InputTag>("pfNeutralHadrons")));
-    }
-    if (depconf.exists("pfPhotons")) {
-      labels.push_back(std::make_pair(pat::PfGammaIso, depconf.getParameter<edm::InputTag>("pfPhotons")));
-    }
-    if (depconf.exists("user")) {
-      std::vector<edm::InputTag> userdeps = depconf.getParameter<std::vector<edm::InputTag> >("user");
-      std::vector<edm::InputTag>::const_iterator it = userdeps.begin(), ed = userdeps.end();
-      int key = UserBaseIso;
-      for ( ; it != ed; ++it, ++key) {
-	labels.push_back(std::make_pair(IsolationKeys(key), *it));
-      }
-    }
-  }
-
-
-}
-
-
-// embed various impact parameters with errors
-// embed high level selection
-void PATElectronProducer::embedHighLevel( pat::Electron & anElectron,
-					  reco::GsfTrackRef track,
-					  reco::TransientTrack & tt,
-					  reco::Vertex & primaryVertex,
-					  bool primaryVertexIsValid,
-					  reco::BeamSpot & beamspot,
-					  bool beamspotIsValid
-					  )
-{
-  // Correct to PV
-
-  // PV2D
-  std::pair<bool,Measurement1D> result =
-    IPTools::signedTransverseImpactParameter(tt,
-					     GlobalVector(track->px(),
-							  track->py(),
-							  track->pz()),
-					     primaryVertex);
-  double d0_corr = result.second.value();
-  double d0_err = primaryVertexIsValid ? result.second.error() : -1.0;
-  anElectron.setDB( d0_corr, d0_err, pat::Electron::PV2D);
-
-
-  // PV3D
-  result =
-    IPTools::signedImpactParameter3D(tt,
-				     GlobalVector(track->px(),
-						  track->py(),
-						  track->pz()),
-				     primaryVertex);
-  d0_corr = result.second.value();
-  d0_err = primaryVertexIsValid ? result.second.error() : -1.0;
-  anElectron.setDB( d0_corr, d0_err, pat::Electron::PV3D);
-
-
-  // Correct to beam spot
-  // make a fake vertex out of beam spot
-  reco::Vertex vBeamspot(beamspot.position(), beamspot.covariance3D());
-
-  // BS2D
-  result =
-    IPTools::signedTransverseImpactParameter(tt,
-					     GlobalVector(track->px(),
-							  track->py(),
-							  track->pz()),
-					     vBeamspot);
-  d0_corr = result.second.value();
-  d0_err = beamspotIsValid ? result.second.error() : -1.0;
-  anElectron.setDB( d0_corr, d0_err, pat::Electron::BS2D);
-
-  // BS3D
-  result =
-    IPTools::signedImpactParameter3D(tt,
-				     GlobalVector(track->px(),
-						  track->py(),
-						  track->pz()),
-				     vBeamspot);
-  d0_corr = result.second.value();
-  d0_err = beamspotIsValid ? result.second.error() : -1.0;
-  anElectron.setDB( d0_corr, d0_err, pat::Electron::BS3D);
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATElectronProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATElectronProducer.h b/PhysicsTools/PatAlgos/plugins/PATElectronProducer.h
deleted file mode 100644
index d2062b7..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATElectronProducer.h
+++ /dev/null
@@ -1,175 +0,0 @@
-//
-// $Id: PATElectronProducer.h,v 1.26.2.4 2013/04/01 18:05:40 tjkim Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATElectronProducer_h
-#define PhysicsTools_PatAlgos_PATElectronProducer_h
-
-/**
-  \class    pat::PATElectronProducer PATElectronProducer.h "PhysicsTools/PatAlgos/interface/PATElectronProducer.h"
-  \brief    Produces pat::Electron's
-
-   The PATElectronProducer produces analysis-level pat::Electron's starting from
-   a collection of objects of reco::GsfElectron.
-
-  \author   Steven Lowette, James Lamb\
-  \version  $Id: PATElectronProducer.h,v 1.26.2.4 2013/04/01 18:05:40 tjkim Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "DataFormats/Candidate/interface/CandAssociation.h"
-
-#include "CommonTools/Utils/interface/PtComparator.h"
-
-#include "PhysicsTools/PatAlgos/interface/MultiIsolator.h"
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-
-#include "DataFormats/PatCandidates/interface/Electron.h"
-
-#include "DataFormats/PatCandidates/interface/UserData.h"
-#include "PhysicsTools/PatAlgos/interface/PATUserDataHelper.h"
-
-#include "RecoEcal/EgammaCoreTools/interface/EcalClusterLazyTools.h"
-#include "TrackingTools/TransientTrack/interface/TransientTrack.h"
-#include "DataFormats/VertexReco/interface/Vertex.h"
-
-#include "Geometry/CaloTopology/interface/CaloSubdetectorTopology.h"
-
-#include <string>
-
-
-namespace pat {
-
-
-  class TrackerIsolationPt;
-  class CaloIsolationEnergy;
-  class LeptonLRCalc;
-
-
-  class PATElectronProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATElectronProducer(const edm::ParameterSet & iConfig);
-      ~PATElectronProducer();
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-      static void fillDescriptions(edm::ConfigurationDescriptions & descriptions);
-
-    private:
-
-      // configurables
-      edm::InputTag electronSrc_;
-      bool          embedGsfElectronCore_;
-      bool          embedGsfTrack_;
-      bool          embedSuperCluster_;
-      bool          embedPflowSuperCluster_;
-      bool          embedSeedCluster_;
-      bool          embedBasicClusters_;
-      bool          embedPreshowerClusters_;
-      bool          embedPflowBasicClusters_;
-      bool          embedPflowPreshowerClusters_;
-      bool          embedTrack_;
-      bool          addGenMatch_;
-      bool          embedGenMatch_;
-      bool          embedRecHits_;
-      
-      std::vector<edm::InputTag> genMatchSrc_;
-
-      /// pflow specific
-      bool          useParticleFlow_;
-      edm::InputTag pfElecSrc_;
-      edm::InputTag pfCandidateMap_;
-      bool          embedPFCandidate_;
-
-      /// mva input variables
-      edm::InputTag reducedBarrelRecHitCollection_;
-      edm::InputTag reducedEndcapRecHitCollection_;
- 
-      /// embed high level selection variables?
-      bool          embedHighLevelSelection_;
-      edm::InputTag beamLineSrc_;
-      bool          usePV_;
-      edm::InputTag pvSrc_;
-
-      typedef std::vector<edm::Handle<edm::Association<reco::GenParticleCollection> > > GenAssociations;
-      typedef edm::RefToBase<reco::GsfElectron> ElectronBaseRef;
-      typedef std::vector< edm::Handle< edm::ValueMap<IsoDeposit> > > IsoDepositMaps;
-      typedef std::vector< edm::Handle< edm::ValueMap<double> > > IsolationValueMaps;
-
-
-      /// common electron filling, for both the standard and PF2PAT case
-      void fillElectron( Electron& aElectron,
-			 const ElectronBaseRef& electronRef,
-			 const reco::CandidateBaseRef& baseRef,
-			 const GenAssociations& genMatches,
-			 const IsoDepositMaps& deposits,
-                         const bool pfId,
-			 const IsolationValueMaps& isolationValues,
-                         const IsolationValueMaps& isolationValuesNoPFId) const;
-
-      void fillElectron2( Electron& anElectron,
-			  const reco::CandidatePtr& candPtrForIsolation,
-			  const reco::CandidatePtr& candPtrForGenMatch,
-			  const reco::CandidatePtr& candPtrForLoader,
-			  const GenAssociations& genMatches,
-			  const IsoDepositMaps& deposits,
-			  const IsolationValueMaps& isolationValues ) const;
-
-    // embed various impact parameters with errors
-    // embed high level selection
-    void embedHighLevel( pat::Electron & anElectron,
-			 reco::GsfTrackRef track,
-			 reco::TransientTrack & tt,
-			 reco::Vertex & primaryVertex,
-			 bool primaryVertexIsValid,
-			 reco::BeamSpot & beamspot,
-			 bool beamspotIsValid );
-
-      typedef std::pair<pat::IsolationKeys,edm::InputTag> IsolationLabel;
-      typedef std::vector<IsolationLabel> IsolationLabels;
-
-      /// fill the labels vector from the contents of the parameter set,
-      /// for the isodeposit or isolation values embedding
-      void readIsolationLabels( const edm::ParameterSet & iConfig,
-				const char* psetName,
-				IsolationLabels& labels);
-
-      bool          addElecID_;
-      typedef std::pair<std::string, edm::InputTag> NameTag;
-      std::vector<NameTag> elecIDSrcs_;
-
-      // tools
-      GreaterByPt<Electron>       pTComparator_;
-
-      pat::helper::MultiIsolator isolator_;
-      pat::helper::MultiIsolator::IsolationValuePairs isolatorTmpStorage_; // better here than recreate at each event
-      IsolationLabels isoDepositLabels_;
-      IsolationLabels isolationValueLabels_;
-      IsolationLabels isolationValueLabelsNoPFId_;
-
-      bool addEfficiencies_;
-      pat::helper::EfficiencyLoader efficiencyLoader_;
-
-      bool addResolutions_;
-      pat::helper::KinResolutionsLoader resolutionLoader_;
-
-      bool useUserData_;
-      pat::PATUserDataHelper<pat::Electron>      userDataHelper_;
-
-      const CaloTopology * ecalTopology_;
-
-  };
-
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATGenCandsFromSimTracksProducer.cc b/PhysicsTools/PatAlgos/plugins/PATGenCandsFromSimTracksProducer.cc
deleted file mode 100644
index 9f3a1b4..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATGenCandsFromSimTracksProducer.cc
+++ /dev/null
@@ -1,354 +0,0 @@
-/**
-  \class    pat::PATGenCandsFromSimTracksProducer PATGenCandsFromSimTracksProducer.h "PhysicsTools/PatAlgos/interface/PATGenCandsFromSimTracksProducer.h"
-  \brief    Produces reco::GenParticle from SimTracks
-
-   The PATGenCandsFromSimTracksProducer produces GenParticles from SimTracks, so they can be used for MC matching.
-   
-
-  \author   Jordan Tucker (original module), Giovanni Petrucciani (PAT integration)
-  \version  $Id: PATGenCandsFromSimTracksProducer.cc,v 1.8 2010/10/20 23:09:25 wmtan Exp $
-*/
-
-#include "FWCore/Framework/interface/Frameworkfwd.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/MakerMacros.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
-#include "SimDataFormats/Track/interface/SimTrackContainer.h"
-#include "SimDataFormats/Vertex/interface/SimVertexContainer.h"
-
-#include "CommonTools/Utils/interface/StringCutObjectSelector.h"
-#include "SimGeneral/HepPDTRecord/interface/PdtEntry.h"
-
-#include <ext/algorithm>
-
-namespace pat {
-class PATGenCandsFromSimTracksProducer : public edm::EDProducer {
-public:
-  explicit PATGenCandsFromSimTracksProducer(const edm::ParameterSet&);
-  ~PATGenCandsFromSimTracksProducer() {}
-
-private:
-  virtual void produce(edm::Event&, const edm::EventSetup&);
-  virtual void endJob() {}
-
-  bool firstEvent_;
-  edm::InputTag src_;
-  int setStatus_;
-  std::set<int>         pdgIds_; // these are the ones we really use
-  std::vector<PdtEntry> pdts_;   // these are needed before we get the EventSetup
-  std::set<int>         motherPdgIds_; // these are the ones we really use
-  std::vector<PdtEntry> motherPdts_;   // these are needed before we get the EventSetup
-
-  typedef StringCutObjectSelector<reco::GenParticle> StrFilter;
-  std::auto_ptr<StrFilter> filter_;
-
-  /// If true, I'll try to make a link from the GEANT particle to a GenParticle  
-  bool makeMotherLink_;
-  /// If true, I'll save GenParticles corresponding to the ancestors of this GEANT particle. Common ancestors are only written once.
-  bool writeAncestors_;
-
-  /// Collection of GenParticles I need to make refs to. It must also have its associated vector<int> of barcodes, aligned with them.
-  edm::InputTag genParticles_;
-
-  /// Global context for all recursive methods
-  struct GlobalContext {
-      GlobalContext(const edm::SimTrackContainer &simtks1,
-                    const edm::SimVertexContainer &simvtxs1,
-                    const edm::Handle<reco::GenParticleCollection> &gens1,
-                    const edm::Handle<std::vector<int> >           &genBarcodes1,
-                    bool                                            barcodesAreSorted1,
-                    reco::GenParticleCollection                     & output1,
-                    const edm::RefProd<reco::GenParticleCollection> & refprod1) :
-          simtks(simtks1), simvtxs(simvtxs1), 
-          gens(gens1), genBarcodes(genBarcodes1), barcodesAreSorted(barcodesAreSorted1),
-          output(output1), refprod(refprod1), simTksProcessed() {}
-      // GEANT info
-      const edm::SimTrackContainer &simtks;
-      const edm::SimVertexContainer &simvtxs;
-      // PYTHIA info
-      const edm::Handle<reco::GenParticleCollection> &gens;
-      const edm::Handle<std::vector<int> >           &genBarcodes;
-      bool                                            barcodesAreSorted;
-      // MY OUTPUT info
-      reco::GenParticleCollection                     & output;
-      const edm::RefProd<reco::GenParticleCollection> & refprod;
-      // BOOK-KEEPING
-      std::map<unsigned int,int> simTksProcessed; // key = sim track id; 
-                                         // val = 0: not processed; 
-                                         //       i>0:  (index+1) in my output
-                                         //       i<0: -(index+1) in pythia [NOT USED]
-  };
-
-  /// Find the mother of a given GEANT track (or NULL if it can't be found).
-  const SimTrack * findGeantMother(const SimTrack &tk, const GlobalContext &g) const ;
-  /// Find the GenParticle reference for a given GEANT or PYTHIA track.
-  ///  - if the track corresponds to a PYTHIA particle, return a ref to that particle
-  ///  - otherwise, if this simtrack has no mother simtrack, return a null ref
-  ///  - otherwise, if writeAncestors is true,  make a GenParticle for it and return a ref to it
-  ///  - otherwise, if writeAncestors is false, return the ref to the GEANT mother of this track
-  edm::Ref<reco::GenParticleCollection> findRef(const SimTrack &tk, GlobalContext &g) const ;
-
-  /// Used by findRef if the track is a PYTHIA particle
-  edm::Ref<reco::GenParticleCollection> generatorRef_(const SimTrack &tk, const GlobalContext &g) const ;
-  /// Make a GenParticle for this SimTrack, with a given mother
-  reco::GenParticle makeGenParticle_(const SimTrack &tk, const edm::Ref<reco::GenParticleCollection> & mother, const GlobalContext &g) const ;
-  
-
-
-  struct LessById {
-    bool operator()(const SimTrack &tk1, const SimTrack &tk2) const { return tk1.trackId() < tk2.trackId(); }
-    bool operator()(const SimTrack &tk1, unsigned int    id ) const { return tk1.trackId() < id;            }
-    bool operator()(unsigned int     id, const SimTrack &tk2) const { return id            < tk2.trackId(); }
-  };
-   
-};
-}
-
-using namespace std;
-using namespace edm;
-using namespace reco;
-using pat::PATGenCandsFromSimTracksProducer;
-
-PATGenCandsFromSimTracksProducer::PATGenCandsFromSimTracksProducer(const ParameterSet& cfg) :
-  firstEvent_(true),
-  src_(cfg.getParameter<InputTag>("src")),            // source sim tracks & vertices
-  setStatus_(cfg.getParameter<int32_t>("setStatus")), // set status of GenParticle to this code
-  makeMotherLink_(cfg.existsAs<bool>("makeMotherLink") ? cfg.getParameter<bool>("makeMotherLink") : false),
-  writeAncestors_(cfg.existsAs<bool>("writeAncestors") ? cfg.getParameter<bool>("writeAncestors") : false),
-  genParticles_(makeMotherLink_ ? cfg.getParameter<InputTag>("genParticles") : edm::InputTag())
-{
-    // Possibly allow a list of particle types
-    if (cfg.exists("particleTypes")) {
-        pdts_ = cfg.getParameter<vector<PdtEntry> >("particleTypes");
-    }
-    if (cfg.exists("motherTypes")) {
-        motherPdts_ = cfg.getParameter<vector<PdtEntry> >("motherTypes");
-    }
-
-    // Possibly allow a string cut
-    if (cfg.existsAs<string>("filter")) {
-        string filter = cfg.getParameter<string>("filter");
-        if (!filter.empty()) {
-            filter_ = auto_ptr<StrFilter>(new StrFilter(filter));
-        }
-    }
-
-    if (writeAncestors_ && !makeMotherLink_) {
-        edm::LogWarning("Configuration") << "PATGenCandsFromSimTracksProducer: " << 
-            "you have set 'writeAncestors' to 'true' and 'makeMotherLink' to false;" <<
-            "GEANT particles with generator level (e.g.PYHIA) mothers won't have mother links.\n";
-    }
-    produces<GenParticleCollection>();
-}
-
-const SimTrack * 
-PATGenCandsFromSimTracksProducer::findGeantMother(const SimTrack &tk, const GlobalContext &g) const {
-   assert(tk.genpartIndex() == -1); // MUST NOT be called with a PYTHIA track
-   if (!tk.noVertex()) {
-       const SimVertex &vtx = g.simvtxs[tk.vertIndex()];
-       if (!vtx.noParent()) {
-           unsigned int idx = vtx.parentIndex();
-           SimTrackContainer::const_iterator it = std::lower_bound(g.simtks.begin(), g.simtks.end(), idx, LessById());
-           if ((it != g.simtks.end()) && (it->trackId() == idx)) {
-                return &*it;
-           }
-       }
-   }
-   return 0;
-}
-
-edm::Ref<reco::GenParticleCollection> 
-PATGenCandsFromSimTracksProducer::findRef(const SimTrack &tk, GlobalContext &g) const {
-    if (tk.genpartIndex() != -1) return makeMotherLink_ ? generatorRef_(tk, g) : edm::Ref<reco::GenParticleCollection>();
-    const SimTrack * simMother = findGeantMother(tk, g);
-
-    edm::Ref<reco::GenParticleCollection> motherRef;
-    if (simMother != 0) motherRef = findRef(*simMother,g);
-
-    if (writeAncestors_) {
-        // If writing ancestors, I need to serialize myself, and then to return a ref to me
-        // But first check if I've already been serialized
-        std::map<unsigned int,int>::const_iterator it = g.simTksProcessed.find(tk.trackId());
-        if (it != g.simTksProcessed.end()) {
-            // just return a ref to it
-            assert(it->second > 0);
-            return edm::Ref<reco::GenParticleCollection>(g.refprod, (it->second) - 1);
-        } else {
-            // make genParticle, save, update the map, and return ref to myself
-            reco::GenParticle p = makeGenParticle_(tk, motherRef, g); 
-            g.output.push_back(p);
-            g.simTksProcessed[tk.trackId()] = g.output.size();
-            return edm::Ref<reco::GenParticleCollection>(g.refprod, g.output.size()-1 );
-        }
-    } else {
-        // Otherwise, I just return a ref to my mum
-        return motherRef; 
-    }
-}
-
-edm::Ref<reco::GenParticleCollection> 
-PATGenCandsFromSimTracksProducer::generatorRef_(const SimTrack &st, const GlobalContext &g) const {
-    assert(st.genpartIndex() != -1);        
-    // Note that st.genpartIndex() is the barcode, not the index within GenParticleCollection, so I have to search the particle
-    std::vector<int>::const_iterator it;
-    if (g.barcodesAreSorted) {
-        it = std::lower_bound(g.genBarcodes->begin(), g.genBarcodes->end(), st.genpartIndex());
-    } else {
-        it = std::find(       g.genBarcodes->begin(), g.genBarcodes->end(), st.genpartIndex());
-    }
-
-    // Check that I found something
-    // I need to check '*it == st.genpartIndex()' because lower_bound just finds the right spot for an item in a sorted list, not the item
-    if ((it != g.genBarcodes->end()) && (*it == st.genpartIndex())) {
-        return reco::GenParticleRef(g.gens, it - g.genBarcodes->begin());
-    } else {
-        return reco::GenParticleRef();
-    }
-}
-
-reco::GenParticle 
-PATGenCandsFromSimTracksProducer::makeGenParticle_(const SimTrack &tk, const edm::Ref<reco::GenParticleCollection> & mother, const GlobalContext &g) const {
-    // Make up a GenParticleCandidate from the GEANT track info.
-    int charge = static_cast<int>(tk.charge());
-    Particle::LorentzVector p4 = tk.momentum();
-    Particle::Point vtx; // = (0,0,0) by default
-    if (!tk.noVertex()) vtx = g.simvtxs[tk.vertIndex()].position();
-    GenParticle gp(charge, p4, vtx, tk.type(), setStatus_, true);
-    if (mother.isNonnull()) gp.addMother(mother);
-    return gp;
-}
-
-
-void PATGenCandsFromSimTracksProducer::produce(Event& event,
-					    const EventSetup& iSetup) {
-
-  if (firstEvent_){
-    if (!pdts_.empty()) {
-      pdgIds_.clear();
-      for (vector<PdtEntry>::iterator itp = pdts_.begin(), edp = pdts_.end(); itp != edp; ++itp) {
-	itp->setup(iSetup); // decode string->pdgId and vice-versa                                                                                                
-	pdgIds_.insert(std::abs(itp->pdgId()));
-      }
-      pdts_.clear();
-    }
-    if (!motherPdts_.empty()) {
-      motherPdgIds_.clear();
-      for (vector<PdtEntry>::iterator itp = motherPdts_.begin(), edp = motherPdts_.end(); itp != edp; ++itp) {
-	itp->setup(iSetup); // decode string->pdgId and vice-versa                                                                                                
-	motherPdgIds_.insert(std::abs(itp->pdgId()));
-      }
-      motherPdts_.clear();
-    }
-    firstEvent_ = false;
-  }
-
-  // Simulated tracks (i.e. GEANT particles).
-  Handle<SimTrackContainer> simtracks;
-  event.getByLabel(src_, simtracks);
-
-  // Need to check that SimTrackContainer is sorted; otherwise, copy and sort :-(
-  std::auto_ptr<SimTrackContainer> simtracksTmp;
-  const SimTrackContainer * simtracksSorted = &* simtracks;
-  if (makeMotherLink_ || writeAncestors_) {
-      if (!__gnu_cxx::is_sorted(simtracks->begin(), simtracks->end(), LessById())) {
-          simtracksTmp.reset(new SimTrackContainer(*simtracks));
-          std::sort(simtracksTmp->begin(), simtracksTmp->end(), LessById());
-          simtracksSorted = &* simtracksTmp;
-      }
-  }
-
-  // Get the associated vertices
-  Handle<SimVertexContainer> simvertices;
-  event.getByLabel(src_, simvertices);
-
-  // Get the GenParticles and barcodes, if needed to set mother links
-  Handle<GenParticleCollection> gens;
-  Handle<std::vector<int> > genBarcodes;
-  bool barcodesAreSorted = true;
-  if (makeMotherLink_) {
-      event.getByLabel(genParticles_, gens);
-      event.getByLabel(genParticles_, genBarcodes);
-      if (gens->size() != genBarcodes->size()) throw cms::Exception("Corrupt data") << "Barcodes not of the same size as GenParticles!\n";
-      barcodesAreSorted = __gnu_cxx::is_sorted(genBarcodes->begin(), genBarcodes->end());
-  }    
-
-
-  // make the output collection
-  auto_ptr<GenParticleCollection> cands(new GenParticleCollection);
-  edm::RefProd<GenParticleCollection> refprod = event.getRefBeforePut<GenParticleCollection>();
-
-  GlobalContext globals(*simtracksSorted, *simvertices, gens, genBarcodes, barcodesAreSorted, *cands, refprod);
-
-  for (SimTrackContainer::const_iterator isimtrk = simtracks->begin();
-          isimtrk != simtracks->end(); ++isimtrk) {
-
-      // Skip PYTHIA tracks.
-      if (isimtrk->genpartIndex() != -1) continue; 
-
-      // Maybe apply the PdgId filter
-      if (!pdgIds_.empty()) { // if we have a filter on pdg ids
-           if (pdgIds_.find(std::abs(isimtrk->type())) == pdgIds_.end()) continue;
-      }
-
-      GenParticle genp = makeGenParticle_(*isimtrk, Ref<GenParticleCollection>(), globals);
-
-      // Maybe apply filter on the particle
-      if (filter_.get() != 0) {
-        if (!(*filter_)(genp)) continue;
-      }
-
-      if (!motherPdgIds_.empty()) {
-           const SimTrack *motherSimTk = findGeantMother(*isimtrk, globals);
-           if (motherSimTk == 0) continue;
-           if (motherPdgIds_.find(std::abs(motherSimTk->type())) == motherPdgIds_.end()) continue;
-      }
-
-      if (makeMotherLink_ || writeAncestors_) {
-          Ref<GenParticleCollection> motherRef;
-          const SimTrack * mother = findGeantMother(*isimtrk, globals);
-          if (mother != 0) motherRef = findRef(*mother, globals); 
-          if (motherRef.isNonnull()) genp.addMother(motherRef);
-      }
-
-      cands->push_back(genp);
-  }
-
-  // Write to the Event, and get back a handle (which can be useful for debugging)
-  edm::OrphanHandle<reco::GenParticleCollection> orphans = event.put(cands);
-
-#ifdef DEBUG_PATGenCandsFromSimTracksProducer
-  std::cout << "Produced a list of " << orphans->size() << " genParticles." << std::endl;
-  for (GenParticleCollection::const_iterator it = orphans->begin(), ed = orphans->end(); it != ed; ++it) {
-      std::cout << "    ";
-      std::cout << "GenParticle #" << (it - orphans->begin()) << ": pdgId " << it->pdgId()
-                << ", pt = " << it->pt() << ", eta = " << it->eta() << ", phi = " << it->phi() 
-                << ", rho = " << it->vertex().Rho() << ", z = " << it->vertex().Z() << std::endl;
-      edm::Ref<GenParticleCollection> mom = it->motherRef();
-      size_t depth = 2;
-      while (mom.isNonnull()) {
-          if (mom.id() == orphans.id()) {
-              // I need to re-make the ref because they are not working until this module returns.
-              mom = edm::Ref<GenParticleCollection>(orphans, mom.key());
-          }
-          for (size_t i = 0; i < depth; ++i) std::cout << "    ";
-          std::cout << "GenParticleRef [" << mom.id() << "/" << mom.key() << "]: pdgId " << mom->pdgId() << ", status = " << mom->status() 
-                    << ", pt = " << mom->pt() << ", eta = " << mom->eta() << ", phi = " << mom->phi() 
-                    << ", rho = " << mom->vertex().Rho() << ", z = " << mom->vertex().Z() << std::endl;
-          if (mom.id() != orphans.id()) break;
-          if ((mom->motherRef().id() == mom.id()) && (mom->motherRef().key() == mom.key())) {
-              throw cms::Exception("Corrupt Data") << "A particle is it's own mother.\n";
-          }
-          mom = mom->motherRef(); 
-          depth++; 
-      }
-  }
-  std::cout << std::endl;
-#endif
-
-}
-
-DEFINE_FWK_MODULE(PATGenCandsFromSimTracksProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATGenericParticleProducer.cc b/PhysicsTools/PatAlgos/plugins/PATGenericParticleProducer.cc
deleted file mode 100755
index 324d391..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATGenericParticleProducer.cc
+++ /dev/null
@@ -1,197 +0,0 @@
-//
-// $Id: PATGenericParticleProducer.cc,v 1.12 2009/10/15 17:17:26 rwolf Exp $
-//
-
-#include "PhysicsTools/PatAlgos/plugins/PATGenericParticleProducer.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "DataFormats/Common/interface/View.h"
-#include <memory>
-
-using namespace pat;
-
-PATGenericParticleProducer::PATGenericParticleProducer(const edm::ParameterSet & iConfig) :
-  isolator_(iConfig.exists("userIsolation") ? iConfig.getParameter<edm::ParameterSet>("userIsolation") : edm::ParameterSet(), false),
-  userDataHelper_ ( iConfig.getParameter<edm::ParameterSet>("userData") )
-{
-  // initialize the configurables
-  src_ = iConfig.getParameter<edm::InputTag>( "src" );
-
-  // RECO embedding
-  embedTrack_        = iConfig.getParameter<bool>( "embedTrack" );
-  embedGsfTrack_     = iConfig.getParameter<bool>( "embedGsfTrack" );
-  embedStandalone_   = iConfig.getParameter<bool>( "embedStandAloneMuon" );
-  embedCombined_     = iConfig.getParameter<bool>( "embedCombinedMuon" );
-  embedSuperCluster_ = iConfig.getParameter<bool>( "embedSuperCluster" );
-  embedTracks_       = iConfig.getParameter<bool>( "embedMultipleTracks" );
-  embedCaloTower_    = iConfig.getParameter<bool>( "embedCaloTower" );
-  
-  // MC matching configurables
-  addGenMatch_   = iConfig.getParameter<bool>( "addGenMatch" );
-  if (addGenMatch_) {
-      embedGenMatch_ = iConfig.getParameter<bool>         ( "embedGenMatch" );
-      if (iConfig.existsAs<edm::InputTag>("genParticleMatch")) {
-          genMatchSrc_.push_back(iConfig.getParameter<edm::InputTag>( "genParticleMatch" ));
-      } else {
-          genMatchSrc_ = iConfig.getParameter<std::vector<edm::InputTag> >( "genParticleMatch" );
-      }
-  }
-
-  // quality
-  addQuality_ = iConfig.getParameter<bool>("addQuality");
-  qualitySrc_ = iConfig.getParameter<edm::InputTag>("qualitySource");
-
-  // produces vector of particles
-  produces<std::vector<GenericParticle> >();
-
-  if (iConfig.exists("isoDeposits")) {
-     edm::ParameterSet depconf = iConfig.getParameter<edm::ParameterSet>("isoDeposits");
-     if (depconf.exists("tracker")) isoDepositLabels_.push_back(std::make_pair(pat::TrackIso, depconf.getParameter<edm::InputTag>("tracker")));
-     if (depconf.exists("ecal"))    isoDepositLabels_.push_back(std::make_pair(pat::EcalIso, depconf.getParameter<edm::InputTag>("ecal")));
-     if (depconf.exists("hcal"))    isoDepositLabels_.push_back(std::make_pair(pat::HcalIso, depconf.getParameter<edm::InputTag>("hcal")));
-     if (depconf.exists("user")) {
-        std::vector<edm::InputTag> userdeps = depconf.getParameter<std::vector<edm::InputTag> >("user");
-        std::vector<edm::InputTag>::const_iterator it = userdeps.begin(), ed = userdeps.end();
-        int key = UserBaseIso;
-        for ( ; it != ed; ++it, ++key) {
-            isoDepositLabels_.push_back(std::make_pair(IsolationKeys(key), *it));
-        }
-     }
-  }
-
-  // Efficiency configurables
-  addEfficiencies_ = iConfig.getParameter<bool>("addEfficiencies");
-  if (addEfficiencies_) {
-     efficiencyLoader_ = pat::helper::EfficiencyLoader(iConfig.getParameter<edm::ParameterSet>("efficiencies"));
-  }
-
-  // Resolution configurables
-  addResolutions_ = iConfig.getParameter<bool>("addResolutions");
-  if (addResolutions_) {
-     resolutionLoader_ = pat::helper::KinResolutionsLoader(iConfig.getParameter<edm::ParameterSet>("resolutions"));
-  }
-
-  if (iConfig.exists("vertexing")) {
-     vertexingHelper_ = pat::helper::VertexingHelper(iConfig.getParameter<edm::ParameterSet>("vertexing")); 
-  }
-
-  // Check to see if the user wants to add user data
-  useUserData_ = false;
-  if ( iConfig.exists("userData") ) {
-    useUserData_ = true;
-  }
-}
-
-PATGenericParticleProducer::~PATGenericParticleProducer() {
-}
-
-void PATGenericParticleProducer::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) {
-  // Get the vector of GenericParticle's from the event
-  edm::Handle<edm::View<reco::Candidate> > cands;
-  iEvent.getByLabel(src_, cands);
-
-  // prepare isolation
-  if (isolator_.enabled()) isolator_.beginEvent(iEvent,iSetup);
-
-  if (efficiencyLoader_.enabled()) efficiencyLoader_.newEvent(iEvent);
-  if (resolutionLoader_.enabled()) resolutionLoader_.newEvent(iEvent, iSetup);
-  if (vertexingHelper_.enabled())  vertexingHelper_.newEvent(iEvent,iSetup);
-
-  // prepare IsoDeposits
-  std::vector<edm::Handle<edm::ValueMap<IsoDeposit> > > deposits(isoDepositLabels_.size());
-  for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-    iEvent.getByLabel(isoDepositLabels_[j].second, deposits[j]);
-  }
-
-  // prepare the MC matching
-  std::vector<edm::Handle<edm::Association<reco::GenParticleCollection> > > genMatches(genMatchSrc_.size());
-  if (addGenMatch_) {
-        for (size_t j = 0, nd = genMatchSrc_.size(); j < nd; ++j) {
-            iEvent.getByLabel(genMatchSrc_[j], genMatches[j]);
-        }
-  }
-
-  // prepare the quality
-  edm::Handle<edm::ValueMap<float> > qualities;
-  if (addQuality_) iEvent.getByLabel(qualitySrc_, qualities);
-
-  // loop over cands
-  std::vector<GenericParticle> * PATGenericParticles = new std::vector<GenericParticle>(); 
-  for (edm::View<reco::Candidate>::const_iterator itGenericParticle = cands->begin(); itGenericParticle != cands->end(); itGenericParticle++) {
-    // construct the GenericParticle from the ref -> save ref to original object
-    unsigned int idx = itGenericParticle - cands->begin();
-    edm::RefToBase<reco::Candidate> candRef = cands->refAt(idx);
-
-    PATGenericParticles->push_back(GenericParticle(candRef));
-    GenericParticle & aGenericParticle = PATGenericParticles->back();
-
-    // embed RECO
-    if (embedTrack_)        aGenericParticle.embedTrack();
-    if (embedGsfTrack_)     aGenericParticle.embedGsfTrack();
-    if (embedTracks_)       aGenericParticle.embedTracks();
-    if (embedStandalone_)   aGenericParticle.embedStandalone();
-    if (embedCombined_)     aGenericParticle.embedCombined();
-    if (embedSuperCluster_) aGenericParticle.embedSuperCluster();
-    if (embedCaloTower_)    aGenericParticle.embedCaloTower();
-
-    // isolation
-    if (isolator_.enabled()) {
-        isolator_.fill(*cands, idx, isolatorTmpStorage_);
-        typedef pat::helper::MultiIsolator::IsolationValuePairs IsolationValuePairs;
-        // better to loop backwards, so the vector is resized less times
-        for (IsolationValuePairs::const_reverse_iterator it = isolatorTmpStorage_.rbegin(), ed = isolatorTmpStorage_.rend(); it != ed; ++it) {
-            aGenericParticle.setIsolation(it->first, it->second);
-        }
-    }
-
-    // isodeposit
-    for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-        aGenericParticle.setIsoDeposit(isoDepositLabels_[j].first, (*deposits[j])[candRef]);
-    }
-
-    // store the match to the generated final state muons
-    if (addGenMatch_) {
-      for(size_t i = 0, n = genMatches.size(); i < n; ++i) {
-          reco::GenParticleRef genGenericParticle = (*genMatches[i])[candRef];
-          aGenericParticle.addGenParticleRef(genGenericParticle);
-      }
-      if (embedGenMatch_) aGenericParticle.embedGenParticle();
-    }
-
-    if (addQuality_) {
-      aGenericParticle.setQuality( (*qualities)[candRef] );
-    }
-
-    if (efficiencyLoader_.enabled()) {
-        efficiencyLoader_.setEfficiencies( aGenericParticle, candRef );
-    }
-
-    if (resolutionLoader_.enabled()) {
-        resolutionLoader_.setResolutions(aGenericParticle);
-    }
-
-    if (vertexingHelper_.enabled()) {
-        aGenericParticle.setVertexAssociation( vertexingHelper_(candRef) );
-    }
-
-    if ( useUserData_ ) {
-        userDataHelper_.add( aGenericParticle, iEvent, iSetup );
-    }
-
-    // PATGenericParticles->push_back(aGenericParticle); // NOOOOO!!!!
-    // We have already pushed_back this generic particle in the collection
-    // (we first push an empty particle and then fill it, to avoid useless copies)
-  }
-
-  // sort GenericParticles in ET
-  std::sort(PATGenericParticles->begin(), PATGenericParticles->end(), eTComparator_);
-
-  // put genEvt object in Event
-  std::auto_ptr<std::vector<GenericParticle> > myGenericParticles(PATGenericParticles);
-  iEvent.put(myGenericParticles);
-  if (isolator_.enabled()) isolator_.endEvent();
-
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATGenericParticleProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATGenericParticleProducer.h b/PhysicsTools/PatAlgos/plugins/PATGenericParticleProducer.h
deleted file mode 100644
index 8eece36..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATGenericParticleProducer.h
+++ /dev/null
@@ -1,90 +0,0 @@
-//
-// $Id: PATGenericParticleProducer.h,v 1.9 2009/06/25 23:49:35 gpetrucc Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATGenericParticleProducer_h
-#define PhysicsTools_PatAlgos_PATGenericParticleProducer_h
-
-/**
-  \class    pat::PATGenericParticleProducer PATGenericParticleProducer.h "PhysicsTools/PatAlgos/interface/PATGenericParticleProducer.h"
-  \brief    Produces the pat::GenericParticle
-
-   The PATGenericParticleProducer produces the analysis-level pat::GenericParticle starting from
-   any collection of Candidates
-
-  \author   Giovanni Petrucciani
-  \version  $Id: PATGenericParticleProducer.h,v 1.9 2009/06/25 23:49:35 gpetrucc Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
-#include "DataFormats/Common/interface/Association.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-
-#include "CommonTools/Utils/interface/EtComparator.h"
-
-#include "DataFormats/PatCandidates/interface/GenericParticle.h"
-
-#include "PhysicsTools/PatAlgos/interface/MultiIsolator.h"
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-#include "PhysicsTools/PatAlgos/interface/VertexingHelper.h"
-
-#include "DataFormats/PatCandidates/interface/UserData.h"
-#include "PhysicsTools/PatAlgos/interface/PATUserDataHelper.h"
-
-namespace pat {
-
-  class PATGenericParticleProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATGenericParticleProducer(const edm::ParameterSet & iConfig);
-      ~PATGenericParticleProducer();
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-    private:
-
-      // configurables
-      edm::InputTag src_;
-
-      // embed RECo objects
-      bool embedSuperCluster_, embedTrack_, embedTracks_, embedGsfTrack_, embedCaloTower_, embedStandalone_, embedCombined_;
-
-      bool addQuality_;
-      edm::InputTag qualitySrc_;
-
-      bool addGenMatch_;
-      bool embedGenMatch_;
-      std::vector<edm::InputTag> genMatchSrc_;
-
-      // tools
-      GreaterByEt<GenericParticle> eTComparator_;
-
-      pat::helper::MultiIsolator isolator_; 
-      pat::helper::MultiIsolator::IsolationValuePairs isolatorTmpStorage_; // better here than recreate at each event
-      std::vector<std::pair<pat::IsolationKeys,edm::InputTag> > isoDepositLabels_;
-
-      bool addEfficiencies_;
-      pat::helper::EfficiencyLoader efficiencyLoader_;
-      
-      bool addResolutions_;
-      pat::helper::KinResolutionsLoader resolutionLoader_;
-
-      pat::helper::VertexingHelper vertexingHelper_;
-
-      bool useUserData_;
-      pat::PATUserDataHelper<pat::GenericParticle> userDataHelper_;
-
-  };
-
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATHeavyIonProducer.cc b/PhysicsTools/PatAlgos/plugins/PATHeavyIonProducer.cc
deleted file mode 100644
index b11f58e..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATHeavyIonProducer.cc
+++ /dev/null
@@ -1,131 +0,0 @@
-// -*- C++ -*-
-//
-// Package:    PATHeavyIonProducer
-// Class:      PATHeavyIonProducer
-// 
-/**\class PATHeavyIonProducer PATHeavyIonProducer.cc yetkin/PATHeavyIonProducer/src/PATHeavyIonProducer.cc
-
- Description: <one line class summary>
-
- Implementation:
-     <Notes on implementation>
-*/
-//
-// Original Author:  Yetkin Yilmaz
-//         Created:  Thu Aug 13 08:39:51 EDT 2009
-// $Id: PATHeavyIonProducer.cc,v 1.3 2010/05/04 16:18:32 yilmaz Exp $
-//
-//
-
-
-// system include files
-#include <memory>
-#include <string>
-#include <iostream>
-
-// user include files
-#include "FWCore/Framework/interface/Frameworkfwd.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "DataFormats/HeavyIonEvent/interface/HeavyIon.h"
-#include "SimDataFormats/GeneratorProducts/interface/HepMCProduct.h"
-
-#include "HepMC/HeavyIon.h"
-
-using namespace std;
-
-//
-// class decleration
-//
-
-class PATHeavyIonProducer : public edm::EDProducer {
-   public:
-      explicit PATHeavyIonProducer(const edm::ParameterSet&);
-      ~PATHeavyIonProducer();
-
-   private:
-      virtual void beginJob() ;
-      virtual void produce(edm::Event&, const edm::EventSetup&);
-      virtual void endJob() ;
-      
-      // ----------member data ---------------------------
-
-   bool doMC_;
-   bool doReco_;
-   std::vector<std::string> hepmcSrc_;
-   edm::InputTag centSrc_;
-   edm::InputTag evtPlaneSrc_;
-
-};
-
-//
-// constants, enums and typedefs
-//
-
-
-//
-// static data member definitions
-//
-
-//
-// constructors and destructor
-//
-PATHeavyIonProducer::PATHeavyIonProducer(const edm::ParameterSet& iConfig)
-{
-   //register your products
-   produces<pat::HeavyIon>();
-
-   //now do what ever other initialization is needed
-   doReco_ = iConfig.getParameter<bool>("doReco");
-   if(doReco_){
-      centSrc_ = iConfig.getParameter<edm::InputTag>("centrality");
-      evtPlaneSrc_ = iConfig.getParameter<edm::InputTag>("evtPlane");
-   }
-
-   doMC_ = iConfig.getParameter<bool>("doMC");
-   if(doMC_){
-      hepmcSrc_ = iConfig.getParameter<std::vector<std::string> >("generators");
-   }
-  
-}
-
-
-PATHeavyIonProducer::~PATHeavyIonProducer()
-{
- 
-   // do anything here that needs to be done at desctruction time
-   // (e.g. close files, deallocate resources etc.)
-
-}
-
-
-//
-// member functions
-//
-
-// ------------ method called to produce the data  ------------
-void
-PATHeavyIonProducer::produce(edm::Event& iEvent, const edm::EventSetup& iSetup)
-{
-
-}
-
-// ------------ method called once each job just before starting event loop  ------------
-void 
-PATHeavyIonProducer::beginJob()
-{
-}
-
-// ------------ method called once each job just after ending the event loop  ------------
-void 
-PATHeavyIonProducer::endJob() {
-}
-
-//define this as a plug-in
-DEFINE_FWK_MODULE(PATHeavyIonProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATHemisphereProducer.cc b/PhysicsTools/PatAlgos/plugins/PATHemisphereProducer.cc
deleted file mode 100644
index 6bdfaec..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATHemisphereProducer.cc
+++ /dev/null
@@ -1,209 +0,0 @@
-
-// -*- C++ -*-
-//
-// Package:    PatShapeAna
-// Class:      PatShapeAna
-// 
-/**\class PatShapeAna PatShapeAna.cc PhysicsTools/PatShapeAna/src/PatShapeAna.cc
-
- Description: <one line class summary>
-
- Implementation:
-     <Notes on implementation>
-*/
-//
-// Original Author:  Tanja Rommerskirchen
-//         Created:  Sat Mar 22 12:58:04 CET 2008
-// $Id: PATHemisphereProducer.cc,v 1.9 2010/01/11 13:36:48 hegner Exp $
-//
-//
-
-
-//system
-#include <vector>
-#include <memory>
-//PAT
-#include "DataFormats/PatCandidates/interface/Jet.h"
-#include "DataFormats/PatCandidates/interface/MET.h"
-#include "DataFormats/PatCandidates/interface/Muon.h"
-#include "DataFormats/PatCandidates/interface/Electron.h"
-#include "DataFormats/PatCandidates/interface/Photon.h"
-#include "DataFormats/PatCandidates/interface/Tau.h"
-#include "DataFormats/PatCandidates/interface/Hemisphere.h"
-//DataFormats
-#include "DataFormats/VertexReco/interface/VertexFwd.h"
-#include "DataFormats/CaloTowers/interface/CaloTowerCollection.h"
-#include "DataFormats/TrackReco/interface/Track.h"
-#include "DataFormats/Candidate/interface/Particle.h"
-//User
-#include  "PhysicsTools/PatAlgos/plugins/PATHemisphereProducer.h"
-
-
-using namespace pat;
-
-
-//
-// constants, enums and typedefs
-//
-
-//
-// static data member definitions
-//
-
-//
-// constructors and destructor
-//
-PATHemisphereProducer::PATHemisphereProducer(const edm::ParameterSet& iConfig) :
-  _patJets       ( iConfig.getParameter<edm::InputTag>( "patJets" ) ),
-  _patMuons      ( iConfig.getParameter<edm::InputTag>( "patMuons" ) ),
-  _patElectrons  ( iConfig.getParameter<edm::InputTag>( "patElectrons" ) ),
-  _patPhotons    ( iConfig.getParameter<edm::InputTag>( "patPhotons" ) ),
-  _patTaus       ( iConfig.getParameter<edm::InputTag>( "patTaus" ) ),
-
-  _minJetEt       ( iConfig.getParameter<double>("minJetEt") ),
-  _minMuonEt       ( iConfig.getParameter<double>("minMuonEt") ),
-  _minElectronEt       ( iConfig.getParameter<double>("minElectronEt") ),
-  _minTauEt       ( iConfig.getParameter<double>("minTauEt") ), 
-  _minPhotonEt       ( iConfig.getParameter<double>("minPhotonEt") ),
-
-  _maxJetEta       ( iConfig.getParameter<double>("maxJetEta") ),
-  _maxMuonEta       ( iConfig.getParameter<double>("maxMuonEta") ),
-  _maxElectronEta       ( iConfig.getParameter<double>("maxElectronEta") ),
-  _maxTauEta       ( iConfig.getParameter<double>("maxTauEta") ), 
-  _maxPhotonEta       ( iConfig.getParameter<double>("maxPhotonEta") ),
-
-  _seedMethod    ( iConfig.getParameter<int>("seedMethod") ),
-  _combinationMethod ( iConfig.getParameter<int>("combinationMethod") )
-
-{
-
-
-  produces< std::vector<pat::Hemisphere> >();
-}
-
-
-PATHemisphereProducer::~PATHemisphereProducer()
-{
- 
-   // do anything here that needs to be done at desctruction time
-   // (e.g. close files, deallocate resources etc.)
-
-}
-
-
-//
-// member functions
-//
-
-// ------------ method called to produce the data  ------------
-void
-PATHemisphereProducer::produce(edm::Event& iEvent, const edm::EventSetup& iSetup)
-{
-   using namespace edm;
-   using namespace std;
-
-   //Jets   
-   Handle<reco::CandidateView> pJets;
-   iEvent.getByLabel(_patJets,pJets);
-
-   //Muons   
-   Handle<reco::CandidateView> pMuons;
-   iEvent.getByLabel(_patMuons,pMuons);
-
-   //Electrons   
-   Handle<reco::CandidateView> pElectrons;
-   iEvent.getByLabel(_patElectrons,pElectrons);
-
-   //Photons   
-   Handle<reco::CandidateView> pPhotons;
-   iEvent.getByLabel(_patPhotons,pPhotons);
-
-   //Taus   
-   Handle<reco::CandidateView> pTaus;
-   iEvent.getByLabel(_patTaus,pTaus);
-
-
-   //fill e,p vector with information from all objects (hopefully cleaned before)
-   for(int i = 0; i < (int) (*pJets).size() ; i++){
-     if((*pJets)[i].pt() <  _minJetEt || fabs((*pJets)[i].eta()) >  _maxJetEta) continue;
-   
-     componentPtrs_.push_back(pJets->ptrAt(i));
-   }
-
-   for(int i = 0; i < (int) (*pMuons).size() ; i++){
-     if((*pMuons)[i].pt() <  _minMuonEt || fabs((*pMuons)[i].eta()) >  _maxMuonEta) continue; 
- 
-     componentPtrs_.push_back(pMuons->ptrAt(i));
-   }
-  
-   for(int i = 0; i < (int) (*pElectrons).size() ; i++){
-     if((*pElectrons)[i].pt() <  _minElectronEt || fabs((*pElectrons)[i].eta()) >  _maxElectronEta) continue;  
-    
-     componentPtrs_.push_back(pElectrons->ptrAt(i));
-   } 
-
-   for(int i = 0; i < (int) (*pPhotons).size() ; i++){
-     if((*pPhotons)[i].pt() <  _minPhotonEt || fabs((*pPhotons)[i].eta()) >  _maxPhotonEta) continue;   
-    
-     componentPtrs_.push_back(pPhotons->ptrAt(i));
-   } 
-
-   //aren't taus included in jets?
-   for(int i = 0; i < (int) (*pTaus).size() ; i++){
-     if((*pTaus)[i].pt() <  _minTauEt || fabs((*pTaus)[i].eta()) >  _maxTauEta) continue;   
-    
-     componentPtrs_.push_back(pTaus->ptrAt(i));
-   }  
-
-   // create product
-   std::auto_ptr< std::vector<Hemisphere> > hemispheres(new std::vector<Hemisphere>);;
-   hemispheres->reserve(2);
-
-  //calls HemiAlgorithm for seed method 3 (transv. inv. Mass) and association method 3 (Lund algo)
-  HemisphereAlgo myHemi(componentPtrs_,_seedMethod,_combinationMethod);
-
-  //get Hemisphere Axis 
-  vA1 = myHemi.getAxis1();
-  vA2 = myHemi.getAxis2();
-
-  reco::Particle::LorentzVector p1(vA1[0]*vA1[3],vA1[1]*vA1[3],vA1[2]*vA1[3],vA1[4]);
-  hemispheres->push_back(Hemisphere(p1));
-
-  reco::Particle::LorentzVector p2(vA2[0]*vA2[3],vA2[1]*vA2[3],vA2[2]*vA2[3],vA2[4]);
-  hemispheres->push_back(Hemisphere(p2));
- 
-  //get information to which Hemisphere each object belongs
-  vgroups = myHemi.getGrouping(); 
-
-  for ( unsigned int i=0; i<vgroups.size(); ++i ) {
-    if ( vgroups[i]==1 ) {
-      (*hemispheres)[0].addDaughter(componentPtrs_[i]);
-    }
-    else {
-      (*hemispheres)[1].addDaughter(componentPtrs_[i]);
-    }
-  }
-
-
-  iEvent.put(hemispheres);
-
-  //clean up
-
-    vPx.clear();
-    vPy.clear();
-    vPz.clear();
-    vE.clear();
-    vgroups.clear();
-    componentPtrs_.clear();
-}
-
-
-
-// ------------ method called once each job just after ending the event loop  ------------
-void 
-PATHemisphereProducer::endJob() {
-  
-}
-
-//define this as a plug-in
-DEFINE_FWK_MODULE(PATHemisphereProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATHemisphereProducer.h b/PhysicsTools/PatAlgos/plugins/PATHemisphereProducer.h
deleted file mode 100644
index 882f917..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATHemisphereProducer.h
+++ /dev/null
@@ -1,91 +0,0 @@
-// -*- C++ -*-
-//
-// Package:    PatShapeAna
-// Class:      PatShapeAna
-// 
-/**\class PatShapeAna PatShapeAna.h PhysicsTools/PatShapeAna/interface/PatShapeAna.h
-
- Description: <one line class summary>
-
- Implementation:
-     <Notes on implementation>
-*/
-//
-// Original Author:  Christian AUTERMANN
-//         Created:  Sat Mar 22 12:58:04 CET 2008
-// $Id: PATHemisphereProducer.h,v 1.7 2010/01/11 13:36:48 hegner Exp $
-//
-//
-
-#ifndef PATHemisphereProducer_h
-#define PATHemisphereProducer_h
-
-// system include files
-#include <memory>
-#include <map>
-#include <utility>//pair
-// user include files
-#include "FWCore/Framework/interface/Frameworkfwd.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/MakerMacros.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "DataFormats/Candidate/interface/CandidateFwd.h"
-#include "PhysicsTools/UtilAlgos/interface/ParameterAdapter.h"
-
-#include "PhysicsTools/PatAlgos/interface/HemisphereAlgo.h" 
-//
-// class decleration
-//
-
-class PATHemisphereProducer : public edm::EDProducer {
-   public:
-      explicit PATHemisphereProducer(const edm::ParameterSet&);
-      ~PATHemisphereProducer();
-
-   private:
-      virtual void produce(edm::Event&, const edm::EventSetup&);
-      virtual void endJob() ;
-      
-      // ----------member data ---------------------------
-      /// Input: All PAT objects that are to cross-clean  or needed for that
-      edm::InputTag _patJets;
-      edm::InputTag _patMets;
-      edm::InputTag _patMuons;
-      edm::InputTag _patElectrons;
-      edm::InputTag _patPhotons;
-      edm::InputTag _patTaus;
-
-  float _minJetEt;
-  float _minMuonEt;       
-  float _minElectronEt;       
-  float _minTauEt;       
-  float _minPhotonEt;      
-
-  float _maxJetEta;      
-  float _maxMuonEta;       
-  float _maxElectronEta;     
-  float _maxTauEta;       
-  float _maxPhotonEta;      
-
-      int _seedMethod; 
-      int _combinationMethod;
-
-      HemisphereAlgo* myHemi;
-      
-      std::vector<float> vPx, vPy, vPz, vE; 
-      std::vector<float> vA1, vA2;
-      std::vector<int> vgroups;
-  std::vector<reco::CandidatePtr> componentPtrs_;
-
-  
-  typedef std::vector<float> HemiAxis;
- 
-      
-   
-    
-};
-
-#endif
-
-
diff --git a/PhysicsTools/PatAlgos/plugins/PATJetProducer.cc b/PhysicsTools/PatAlgos/plugins/PATJetProducer.cc
deleted file mode 100755
index dee6a60..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATJetProducer.cc
+++ /dev/null
@@ -1,478 +0,0 @@
-//
-// $Id: PATJetProducer.cc,v 1.54 2012/05/20 20:12:25 rwolf Exp $
-
-
-#include "PhysicsTools/PatAlgos/plugins/PATJetProducer.h"
-
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "FWCore/ParameterSet/interface/FileInPath.h"
-
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "DataFormats/Common/interface/Association.h"
-#include "DataFormats/Candidate/interface/CandAssociation.h"
-
-#include "DataFormats/JetReco/interface/JetTracksAssociation.h"
-#include "DataFormats/BTauReco/interface/JetTag.h"
-#include "DataFormats/BTauReco/interface/TrackProbabilityTagInfo.h"
-#include "DataFormats/BTauReco/interface/TrackIPTagInfo.h"
-#include "DataFormats/BTauReco/interface/TrackCountingTagInfo.h"
-#include "DataFormats/BTauReco/interface/SecondaryVertexTagInfo.h"
-#include "DataFormats/BTauReco/interface/SoftLeptonTagInfo.h"
-
-#include "DataFormats/Candidate/interface/CandMatchMap.h"
-#include "SimDataFormats/JetMatching/interface/JetFlavourMatching.h"
-
-#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
-
-#include "DataFormats/Math/interface/deltaR.h"
-
-#include "DataFormats/PatCandidates/interface/JetCorrFactors.h"
-
-#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
-#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
-
-#include "FWCore/Framework/interface/Selector.h"
-
-#include <vector>
-#include <memory>
-#include <algorithm>
-
-
-using namespace pat;
-
-
-PATJetProducer::PATJetProducer(const edm::ParameterSet& iConfig)  :
-  useUserData_(iConfig.exists("userData"))
-{
-  // initialize configurables
-  jetsSrc_ = iConfig.getParameter<edm::InputTag>( "jetSource" );
-  embedCaloTowers_ = iConfig.getParameter<bool>( "embedCaloTowers" );
-  embedPFCandidates_ = iConfig.getParameter<bool>( "embedPFCandidates" );
-  getJetMCFlavour_ = iConfig.getParameter<bool>( "getJetMCFlavour" );
-  jetPartonMapSource_ = iConfig.getParameter<edm::InputTag>( "JetPartonMapSource" );
-  addGenPartonMatch_ = iConfig.getParameter<bool>( "addGenPartonMatch" );
-  embedGenPartonMatch_ = iConfig.getParameter<bool>( "embedGenPartonMatch" );
-  genPartonSrc_ = iConfig.getParameter<edm::InputTag>( "genPartonMatch" );
-  addGenJetMatch_ = iConfig.getParameter<bool>( "addGenJetMatch" );
-  embedGenJetMatch_ = iConfig.getParameter<bool>( "embedGenJetMatch" );
-  genJetSrc_ = iConfig.getParameter<edm::InputTag>( "genJetMatch" );
-  addPartonJetMatch_ = iConfig.getParameter<bool>( "addPartonJetMatch" );
-  partonJetSrc_ = iConfig.getParameter<edm::InputTag>( "partonJetSource" );
-  addJetCorrFactors_ = iConfig.getParameter<bool>( "addJetCorrFactors" );
-  jetCorrFactorsSrc_ = iConfig.getParameter<std::vector<edm::InputTag> >( "jetCorrFactorsSource" );
-  addBTagInfo_ = iConfig.getParameter<bool>( "addBTagInfo" );
-  addDiscriminators_ = iConfig.getParameter<bool>( "addDiscriminators" );
-  discriminatorTags_ = iConfig.getParameter<std::vector<edm::InputTag> >( "discriminatorSources" );
-  addTagInfos_ = iConfig.getParameter<bool>( "addTagInfos" );
-  tagInfoTags_ = iConfig.getParameter<std::vector<edm::InputTag> >( "tagInfoSources" );
-  addAssociatedTracks_ = iConfig.getParameter<bool>( "addAssociatedTracks" ); 
-  trackAssociation_ = iConfig.getParameter<edm::InputTag>( "trackAssociationSource" );
-  addJetCharge_ = iConfig.getParameter<bool>( "addJetCharge" ); 
-  jetCharge_ = iConfig.getParameter<edm::InputTag>( "jetChargeSource" );
-  addJetID_ = iConfig.getParameter<bool>( "addJetID");
-  jetIDMapLabel_ = iConfig.getParameter<edm::InputTag>( "jetIDMap");
-  // Efficiency configurables
-  addEfficiencies_ = iConfig.getParameter<bool>("addEfficiencies");
-  if (addEfficiencies_) {
-     efficiencyLoader_ = pat::helper::EfficiencyLoader(iConfig.getParameter<edm::ParameterSet>("efficiencies"));
-  }
-  // Resolution configurables
-  addResolutions_ = iConfig.getParameter<bool>("addResolutions");
-  if (addResolutions_) {
-     resolutionLoader_ = pat::helper::KinResolutionsLoader(iConfig.getParameter<edm::ParameterSet>("resolutions"));
-  }
-  if (discriminatorTags_.empty()) { 
-    addDiscriminators_ = false; 
-  } else {
-    for (std::vector<edm::InputTag>::const_iterator it = discriminatorTags_.begin(), ed = discriminatorTags_.end(); it != ed; ++it) {
-        std::string label = it->label();
-        std::string::size_type pos = label.find("JetTags");
-        if ((pos !=  std::string::npos) && (pos != label.length() - 7)) {
-            label.erase(pos+7); // trim a tail after "JetTags"
-        }
-        discriminatorLabels_.push_back(label);
-    }
-  }
-  if (tagInfoTags_.empty()) { 
-    addTagInfos_ = false; 
-  } else {
-    for (std::vector<edm::InputTag>::const_iterator it = tagInfoTags_.begin(), ed = tagInfoTags_.end(); it != ed; ++it) {
-        std::string label = it->label();
-        std::string::size_type pos = label.find("TagInfos");
-        if ((pos !=  std::string::npos) && (pos != label.length() - 8)) {
-            label.erase(pos+8); // trim a tail after "TagInfos"
-        }
-        tagInfoLabels_.push_back(label);
-    }
-  }
-  if (!addBTagInfo_) { addDiscriminators_ = false; addTagInfos_ = false; }
-  // Check to see if the user wants to add user data
-  if ( useUserData_ ) {
-    userDataHelper_ = PATUserDataHelper<Jet>(iConfig.getParameter<edm::ParameterSet>("userData"));
-  }
-  // produces vector of jets
-  produces<std::vector<Jet> >();
-  produces<reco::GenJetCollection> ("genJets");
-  produces<std::vector<CaloTower>  > ("caloTowers");
-  produces<reco::PFCandidateCollection > ("pfCandidates");
-  produces<edm::OwnVector<reco::BaseTagInfo> > ("tagInfos");
-}
-
-
-PATJetProducer::~PATJetProducer() {
-
-}
-
-
-void PATJetProducer::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) 
-{
-  // check whether dealing with MC or real data
-  if (iEvent.isRealData()){
-    getJetMCFlavour_   = false;
-    addGenPartonMatch_ = false;
-    addGenJetMatch_    = false;
-    addPartonJetMatch_ = false;
-  }
-  
-  // Get the vector of jets
-  edm::Handle<edm::View<reco::Jet> > jets;
-  iEvent.getByLabel(jetsSrc_, jets);
-
-  if (efficiencyLoader_.enabled()) efficiencyLoader_.newEvent(iEvent);
-  if (resolutionLoader_.enabled()) resolutionLoader_.newEvent(iEvent, iSetup);
-
-  // for jet flavour
-  edm::Handle<reco::JetFlavourMatchingCollection> jetFlavMatch;
-  if (getJetMCFlavour_) iEvent.getByLabel (jetPartonMapSource_, jetFlavMatch);
-
-  // Get the vector of generated particles from the event if needed
-  edm::Handle<edm::Association<reco::GenParticleCollection> > partonMatch;
-  if (addGenPartonMatch_) iEvent.getByLabel(genPartonSrc_,  partonMatch);
-  // Get the vector of GenJets from the event if needed
-  edm::Handle<edm::Association<reco::GenJetCollection> > genJetMatch;
-  if (addGenJetMatch_) iEvent.getByLabel(genJetSrc_, genJetMatch);
-/* TO BE IMPLEMENTED FOR >= 1_5_X
-  // Get the vector of PartonJets from the event if needed
-  edm::Handle<edm::View<reco::SomePartonJetType> > partonJets;
-  if (addPartonJetMatch_) iEvent.getByLabel(partonJetSrc_, partonJets);
-*/
-
-  // read in the jet correction factors ValueMap
-  std::vector<edm::ValueMap<JetCorrFactors> > jetCorrs;
-  if (addJetCorrFactors_) {
-    for ( size_t i = 0; i < jetCorrFactorsSrc_.size(); ++i ) {
-      edm::Handle<edm::ValueMap<JetCorrFactors> > jetCorr;
-      iEvent.getByLabel(jetCorrFactorsSrc_[i], jetCorr);
-      jetCorrs.push_back( *jetCorr );
-    }
-  }  
-
-  // Get the vector of jet tags with b-tagging info
-  std::vector<edm::Handle<reco::JetFloatAssociation::Container> > jetDiscriminators;
-  if (addBTagInfo_ && addDiscriminators_) {
-    jetDiscriminators.resize(discriminatorTags_.size());
-    for (size_t i = 0; i < discriminatorTags_.size(); ++i) {
-        iEvent.getByLabel(discriminatorTags_[i], jetDiscriminators[i]);
-    }
-  }
-  std::vector<edm::Handle<edm::View<reco::BaseTagInfo> > > jetTagInfos;
-  if (addBTagInfo_ && addTagInfos_) {
-    jetTagInfos.resize(tagInfoTags_.size());
-    for (size_t i = 0; i < tagInfoTags_.size(); ++i) {
-      iEvent.getByLabel(tagInfoTags_[i], jetTagInfos[i]);
-    }
-  }
- 
-  // tracks Jet Track Association
-  edm::Handle<reco::JetTracksAssociation::Container > hTrackAss;
-  if (addAssociatedTracks_) iEvent.getByLabel(trackAssociation_, hTrackAss);
-  edm::Handle<reco::JetFloatAssociation::Container > hJetChargeAss;
-  if (addJetCharge_) iEvent.getByLabel(jetCharge_, hJetChargeAss);
-
-  // jet ID handle
-  edm::Handle<reco::JetIDValueMap> hJetIDMap;
-  if ( addJetID_ ) iEvent.getByLabel( jetIDMapLabel_, hJetIDMap );
-
-  // loop over jets
-  std::auto_ptr< std::vector<Jet> > patJets ( new std::vector<Jet>() ); 
-
-  std::auto_ptr<reco::GenJetCollection > genJetsOut ( new reco::GenJetCollection() );
-  std::auto_ptr<std::vector<CaloTower>  >  caloTowersOut( new std::vector<CaloTower> () );
-  std::auto_ptr<reco::PFCandidateCollection > pfCandidatesOut( new reco::PFCandidateCollection() );
-  std::auto_ptr<edm::OwnVector<reco::BaseTagInfo> > tagInfosOut ( new edm::OwnVector<reco::BaseTagInfo>() );  
-
-
-  edm::RefProd<reco::GenJetCollection > h_genJetsOut = iEvent.getRefBeforePut<reco::GenJetCollection >( "genJets" );
-  edm::RefProd<std::vector<CaloTower>  >  h_caloTowersOut = iEvent.getRefBeforePut<std::vector<CaloTower>  > ( "caloTowers" );
-  edm::RefProd<reco::PFCandidateCollection > h_pfCandidatesOut = iEvent.getRefBeforePut<reco::PFCandidateCollection > ( "pfCandidates" );
-  edm::RefProd<edm::OwnVector<reco::BaseTagInfo> > h_tagInfosOut = iEvent.getRefBeforePut<edm::OwnVector<reco::BaseTagInfo> > ( "tagInfos" );
-
-
-  
-
-  bool first=true; // this is introduced to issue warnings only for the first jet
-  for (edm::View<reco::Jet>::const_iterator itJet = jets->begin(); itJet != jets->end(); itJet++) {
-
-    // construct the Jet from the ref -> save ref to original object
-    unsigned int idx = itJet - jets->begin();
-    edm::RefToBase<reco::Jet> jetRef = jets->refAt(idx);
-    edm::Ptr<reco::Jet> jetPtr = jets->ptrAt(idx); 
-    Jet ajet(jetRef);
-
-    // add the FwdPtrs to the CaloTowers
-    if ( (ajet.isCaloJet() || ajet.isJPTJet() ) && embedCaloTowers_) {
-      const reco::CaloJet *cj = 0;
-      const reco::JPTJet * jptj = 0;
-      if ( ajet.isCaloJet()) cj = dynamic_cast<const reco::CaloJet *>(jetRef.get());      
-      else { 
-	jptj = dynamic_cast<const reco::JPTJet *>(jetRef.get() );
-	cj = dynamic_cast<const reco::CaloJet *>(jptj->getCaloJetRef().get() );
-      }
-      pat::CaloTowerFwdPtrCollection itowersRef;
-      std::vector< CaloTowerPtr > itowers = cj->getCaloConstituents();
-      for ( std::vector<CaloTowerPtr>::const_iterator towBegin = itowers.begin(),
-	      towEnd = itowers.end(), itow = towBegin;
-	    itow != towEnd; ++itow ) {
-	caloTowersOut->push_back( **itow );
-	// set the "forward" ref to the thinned collection
-	edm::Ref<std::vector<CaloTower> > caloTowerRef( h_caloTowersOut, caloTowersOut->size() - 1);
-	edm::Ptr<CaloTower> caloForwardRef ( h_caloTowersOut.id(), caloTowerRef.key(), h_caloTowersOut.productGetter() );
-	// set the "backward" ref to the original collection for association
-	edm::Ptr<CaloTower> caloBackRef ( *itow );	
-	// add to the list of FwdPtr's
-	itowersRef.push_back( pat::CaloTowerFwdPtrCollection::value_type ( caloForwardRef, caloBackRef ) );
-	
-      }
-      ajet.setCaloTowers( itowersRef );
-    }
-
-    // add the FwdPtrs to the PFCandidates
-    if (ajet.isPFJet() && embedPFCandidates_) {
-      const reco::PFJet *cj = dynamic_cast<const reco::PFJet *>(jetRef.get());
-      pat::PFCandidateFwdPtrCollection iparticlesRef;
-      std::vector< reco::PFCandidatePtr > iparticles = cj->getPFConstituents();
-      for ( std::vector<reco::PFCandidatePtr>::const_iterator partBegin = iparticles.begin(),
-	      partEnd = iparticles.end(), ipart = partBegin;
-	    ipart != partEnd; ++ipart ) {
-	pfCandidatesOut->push_back( **ipart );
-	// set the "forward" ref to the thinned collection
-	edm::Ref<reco::PFCandidateCollection> pfCollectionRef( h_pfCandidatesOut, pfCandidatesOut->size() - 1);
-	edm::Ptr<reco::PFCandidate> pfForwardRef ( h_pfCandidatesOut.id(), pfCollectionRef.key(),  h_pfCandidatesOut.productGetter() );
-	// set the "backward" ref to the original collection for association
-	edm::Ptr<reco::PFCandidate> pfBackRef ( *ipart );
-	// add to the list of FwdPtr's
-	iparticlesRef.push_back( pat::PFCandidateFwdPtrCollection::value_type ( pfForwardRef, pfBackRef ) );
-      }
-      ajet.setPFCandidates( iparticlesRef );
-    }
-
-    if (addJetCorrFactors_) {
-      // add additional JetCorrs to the jet 
-      for ( unsigned int i=0; i<jetCorrFactorsSrc_.size(); ++i ) {
-	const JetCorrFactors& jcf = jetCorrs[i][jetRef];
-	// uncomment for debugging
-	// jcf.print();
-	ajet.addJECFactors(jcf);
-      }
-      std::vector<std::string> levels = jetCorrs[0][jetRef].correctionLabels();
-      if(std::find(levels.begin(), levels.end(), "L2L3Residual")!=levels.end()){
-	ajet.initializeJEC(jetCorrs[0][jetRef].jecLevel("L2L3Residual"));
-      }
-      else if(std::find(levels.begin(), levels.end(), "L3Absolute")!=levels.end()){
-	ajet.initializeJEC(jetCorrs[0][jetRef].jecLevel("L3Absolute"));
-      }
-      else{
-	ajet.initializeJEC(jetCorrs[0][jetRef].jecLevel("Uncorrected"));
-	if(first){	  
-	  edm::LogWarning("L3Absolute not found") << "L2L3Residual and L3Absolute are not part of the correction applied jetCorrFactors \n"
-						  << "of module " <<  jetCorrs[0][jetRef].jecSet() << " jets will remain"
-						  << " uncorrected."; first=false;
-	}
-      }
-    }
-
-    // get the MC flavour information for this jet
-    if (getJetMCFlavour_) {
-        ajet.setPartonFlavour( (*jetFlavMatch)[edm::RefToBase<reco::Jet>(jetRef)].getFlavour() );
-    }
-    // store the match to the generated partons
-    if (addGenPartonMatch_) {
-      reco::GenParticleRef parton = (*partonMatch)[jetRef];
-      if (parton.isNonnull() && parton.isAvailable()) {
-          ajet.setGenParton(parton, embedGenPartonMatch_);
-      } // leave empty if no match found
-    }
-    // store the match to the GenJets
-    if (addGenJetMatch_) {
-      reco::GenJetRef genjet = (*genJetMatch)[jetRef];
-      if (genjet.isNonnull() && genjet.isAvailable()) {
-	genJetsOut->push_back( *genjet );
-	// set the "forward" ref to the thinned collection
-	edm::Ref<reco::GenJetCollection > genForwardRef ( h_genJetsOut, genJetsOut->size() - 1 );
-	// set the "backward" ref to the original collection
-	edm::Ref<reco::GenJetCollection > genBackRef ( genjet );
-	// make the FwdPtr
-	edm::FwdRef<reco::GenJetCollection > genjetFwdRef ( genForwardRef, genBackRef );
-	ajet.setGenJetRef(genjetFwdRef );
-      } // leave empty if no match found
-    }
-
-    if (efficiencyLoader_.enabled()) {
-        efficiencyLoader_.setEfficiencies( ajet, jetRef );
-    }
-
-    // IMPORTANT: DO THIS AFTER JES CORRECTIONS
-    if (resolutionLoader_.enabled()) {
-        resolutionLoader_.setResolutions(ajet);
-    }
-
-    // TO BE IMPLEMENTED FOR >=1_5_X: do the PartonJet matching
-    if (addPartonJetMatch_) {
-    }
-
-    // add b-tag info if available & required
-    if (addBTagInfo_) {
-        if (addDiscriminators_) {
-            for (size_t k=0; k<jetDiscriminators.size(); ++k) {
-                float value = (*jetDiscriminators[k])[jetRef];
-                ajet.addBDiscriminatorPair(std::make_pair(discriminatorLabels_[k], value));
-            }
-        }    
-        if (addTagInfos_) {
-	  for (size_t k=0; k<jetTagInfos.size(); ++k) {
-	    const edm::View<reco::BaseTagInfo> & taginfos = *jetTagInfos[k];
-	    // This is not associative, so we have to search the jet
-	    edm::Ptr<reco::BaseTagInfo> match;
-	    // Try first by 'same index'
-	    if ((idx < taginfos.size()) && (taginfos[idx].jet() == jetRef)) {
-	      match = taginfos.ptrAt(idx);
-	    } else {
-	      // otherwise fail back to a simple search
-	      for (edm::View<reco::BaseTagInfo>::const_iterator itTI = taginfos.begin(), edTI = taginfos.end(); itTI != edTI; ++itTI) {
-		if (itTI->jet() == jetRef) { match = taginfos.ptrAt( itTI - taginfos.begin() ); break; }
-	      }
-	    }
-	    if (match.isNonnull()) {
-	      tagInfosOut->push_back( match->clone() );
-	      // set the "forward" ptr to the thinned collection
-	      edm::Ptr<reco::BaseTagInfo> tagInfoForwardPtr ( h_tagInfosOut.id(), &tagInfosOut->back(), tagInfosOut->size() - 1 );
-	      // set the "backward" ptr to the original collection for association
-	      edm::Ptr<reco::BaseTagInfo> tagInfoBackPtr ( match );
-	      // make FwdPtr
-	      TagInfoFwdPtrCollection::value_type tagInfoFwdPtr( tagInfoForwardPtr, tagInfoBackPtr ) ;
-	      ajet.addTagInfo(tagInfoLabels_[k], tagInfoFwdPtr );
-	    }
-	  }
-        }    
-    }
-    
-    if (addAssociatedTracks_) ajet.setAssociatedTracks( (*hTrackAss)[jetRef] );
-
-    if (addJetCharge_) ajet.setJetCharge( (*hJetChargeAss)[jetRef] );
-
-    // add jet ID for calo jets
-    if (addJetID_ && ajet.isCaloJet() ) {
-      reco::JetID jetId = (*hJetIDMap)[ jetRef ];
-      ajet.setJetID( jetId );
-    }
-    // add jet ID jpt jets
-    else if ( addJetID_ && ajet.isJPTJet() ){
-      const reco::JPTJet *jptj = dynamic_cast<const reco::JPTJet *>(jetRef.get());
-      reco::JetID jetId = (*hJetIDMap)[ jptj->getCaloJetRef() ];
-      ajet.setJetID( jetId );
-    } 
-    if ( useUserData_ ) {
-      userDataHelper_.add( ajet, iEvent, iSetup );
-    }
-    patJets->push_back(ajet);
-  }
-
-  // sort jets in pt
-  std::sort(patJets->begin(), patJets->end(), pTComparator_);
-
-  // put genEvt  in Event
-  iEvent.put(patJets);
-
-  iEvent.put( genJetsOut, "genJets" );
-  iEvent.put( caloTowersOut, "caloTowers" );
-  iEvent.put( pfCandidatesOut, "pfCandidates" );
-  iEvent.put( tagInfosOut, "tagInfos" );
-  
-
-}
-
-// ParameterSet description for module
-void PATJetProducer::fillDescriptions(edm::ConfigurationDescriptions & descriptions)
-{
-  edm::ParameterSetDescription iDesc;
-  iDesc.setComment("PAT jet producer module");
-
-  // input source 
-  iDesc.add<edm::InputTag>("jetSource", edm::InputTag("no default"))->setComment("input collection");
-
-  // embedding
-  iDesc.add<bool>("embedCaloTowers", true)->setComment("embed external calo towers");
-  iDesc.add<bool>("embedPFCandidates", true)->setComment("embed external PFCandidates");
-
-  // MC matching configurables
-  iDesc.add<bool>("addGenPartonMatch", true)->setComment("add MC matching");
-  iDesc.add<bool>("embedGenPartonMatch", false)->setComment("embed MC matched MC information");
-  iDesc.add<edm::InputTag>("genPartonMatch", edm::InputTag())->setComment("input with MC match information");
-
-  iDesc.add<bool>("addGenJetMatch", true)->setComment("add MC matching");
-  iDesc.add<bool>("embedGenJetMatch", false)->setComment("embed MC matched MC information");
-  iDesc.add<edm::InputTag>("genJetMatch", edm::InputTag())->setComment("input with MC match information");
-
-  iDesc.add<bool>("addJetCharge", true);
-  iDesc.add<edm::InputTag>("jetChargeSource", edm::InputTag("patJetCharge"));
-  
-  // jet id
-  iDesc.add<bool>("addJetID", true)->setComment("Add jet ID information");
-  iDesc.add<edm::InputTag>("jetIDMap", edm::InputTag())->setComment("jet id map");
-
-  iDesc.add<bool>("addPartonJetMatch", false);
-  iDesc.add<edm::InputTag>("partonJetSource", edm::InputTag("NOT IMPLEMENTED"));
-
-  // track association
-  iDesc.add<bool>("addAssociatedTracks", true);
-  iDesc.add<edm::InputTag>("trackAssociationSource", edm::InputTag("ic5JetTracksAssociatorAtVertex"));
-
-  // tag info
-  iDesc.add<bool>("addTagInfos", true);
-  std::vector<edm::InputTag> emptyVInputTags;
-  iDesc.add<std::vector<edm::InputTag> >("tagInfoSources", emptyVInputTags);
-
-  // jet energy corrections
-  iDesc.add<bool>("addJetCorrFactors", true);
-  iDesc.add<std::vector<edm::InputTag> >("jetCorrFactorsSource", emptyVInputTags);
-
-  // btag discriminator tags
-  iDesc.add<bool>("addBTagInfo",true);
-  iDesc.add<bool>("addDiscriminators", true);
-  iDesc.add<std::vector<edm::InputTag> >("discriminatorSources", emptyVInputTags);
-
-  // jet flavour idetification configurables
-  iDesc.add<bool>("getJetMCFlavour", true);
-  iDesc.add<edm::InputTag>("JetPartonMapSource", edm::InputTag("jetFlavourAssociation"));
-
-  pat::helper::KinResolutionsLoader::fillDescription(iDesc);
-
-  // Efficiency configurables
-  edm::ParameterSetDescription efficienciesPSet;
-  efficienciesPSet.setAllowAnything(); // TODO: the pat helper needs to implement a description.
-  iDesc.add("efficiencies", efficienciesPSet);
-  iDesc.add<bool>("addEfficiencies", false);
-
-  // Check to see if the user wants to add user data
-  edm::ParameterSetDescription userDataPSet;
-  PATUserDataHelper<Jet>::fillDescription(userDataPSet);
-  iDesc.addOptional("userData", userDataPSet);
-
-  descriptions.add("PATJetProducer", iDesc);
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATJetProducer);
-
diff --git a/PhysicsTools/PatAlgos/plugins/PATJetProducer.h b/PhysicsTools/PatAlgos/plugins/PATJetProducer.h
deleted file mode 100644
index 451c05f..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATJetProducer.h
+++ /dev/null
@@ -1,108 +0,0 @@
-//
-// $Id: PATJetProducer.h,v 1.26 2010/08/09 18:13:54 srappocc Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATJetProducer_h
-#define PhysicsTools_PatAlgos_PATJetProducer_h
-
-/**
-  \class    pat::PATJetProducer PATJetProducer.h "PhysicsTools/PatAlgos/interface/PATJetProducer.h"
-  \brief    Produces pat::Jet's
-
-   The PATJetProducer produces analysis-level pat::Jet's starting from
-   a collection of objects of JetType.
-
-  \author   Steven Lowette, Jeremy Andrea
-  \version  $Id: PATJetProducer.h,v 1.26 2010/08/09 18:13:54 srappocc Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "DataFormats/Common/interface/View.h"
-
-#include "CommonTools/Utils/interface/PtComparator.h"
-
-#include "DataFormats/PatCandidates/interface/Jet.h"
-#include "DataFormats/PatCandidates/interface/Electron.h"
-#include "DataFormats/PatCandidates/interface/Muon.h"
-
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-
-#include "RecoJets/JetProducers/interface/JetIDHelper.h"
-
-#include "DataFormats/PatCandidates/interface/UserData.h"
-#include "PhysicsTools/PatAlgos/interface/PATUserDataHelper.h"
-
-class JetFlavourIdentifier;
-
-
-namespace pat {
-
-  class PATJetProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATJetProducer(const edm::ParameterSet & iConfig);
-      ~PATJetProducer();
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-      static void fillDescriptions(edm::ConfigurationDescriptions & descriptions);
-
-    private:
-
-      // configurables
-      edm::InputTag            jetsSrc_;
-      bool                     embedCaloTowers_;
-      bool                     embedPFCandidates_;
-      bool                     getJetMCFlavour_;
-      edm::InputTag            jetPartonMapSource_;
-      bool                     addGenPartonMatch_;
-      bool                     embedGenPartonMatch_;
-      edm::InputTag            genPartonSrc_;
-      bool                     addGenJetMatch_;
-      bool                     embedGenJetMatch_;
-      edm::InputTag            genJetSrc_;
-      bool                     addPartonJetMatch_;
-      edm::InputTag            partonJetSrc_;
-      bool                     addJetCorrFactors_;
-      std::vector<edm::InputTag> jetCorrFactorsSrc_;
-
-      bool                       addBTagInfo_;
-      bool                       addDiscriminators_; 
-      std::vector<edm::InputTag> discriminatorTags_;
-      std::vector<std::string>   discriminatorLabels_;
-      bool                       addTagInfos_; 
-      std::vector<edm::InputTag> tagInfoTags_;
-      std::vector<std::string>   tagInfoLabels_;
-      bool                       addAssociatedTracks_;
-      edm::InputTag              trackAssociation_;
-      bool                       addJetCharge_;
-      edm::InputTag              jetCharge_;
-      bool                       addJetID_;
-      edm::InputTag              jetIDMapLabel_;
-      // tools
-      GreaterByPt<Jet>                   pTComparator_;
-      GreaterByPt<CaloTower>             caloPTComparator_;
-
-      bool addEfficiencies_;
-      pat::helper::EfficiencyLoader efficiencyLoader_;
-
-      bool                     addResolutions_;
-      pat::helper::KinResolutionsLoader resolutionLoader_;
-
-      bool useUserData_;
-      pat::PATUserDataHelper<pat::Jet>      userDataHelper_;
-
-      
-
-  };
-
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATJetSelector.h b/PhysicsTools/PatAlgos/plugins/PATJetSelector.h
deleted file mode 100644
index deba1db..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATJetSelector.h
+++ /dev/null
@@ -1,209 +0,0 @@
-//
-// $Id: PATJetSelector.h,v 1.6 2010/08/10 01:54:55 srappocc Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATJetSelector_h
-#define PhysicsTools_PatAlgos_PATJetSelector_h
-
-#include "FWCore/Framework/interface/EDFilter.h"
-
-#include "DataFormats/Common/interface/RefVector.h"
-
-#include "CommonTools/UtilAlgos/interface/StringCutObjectSelector.h"
-#include "CommonTools/UtilAlgos/interface/SingleObjectSelector.h"
-#include "CommonTools/UtilAlgos/interface/ObjectSelector.h"
-#include "CommonTools/UtilAlgos/interface/SingleElementCollectionSelector.h"
-
-#include "DataFormats/PatCandidates/interface/Jet.h"
-
-
-#include <vector>
-
-
-namespace pat {
-
-  class PATJetSelector : public edm::EDFilter {
-  public:
-
-
-  PATJetSelector( edm::ParameterSet const & params ) : 
-    edm::EDFilter( ),
-      src_( params.getParameter<edm::InputTag>("src") ),
-      cut_( params.getParameter<std::string>("cut") ),
-      filter_(false),
-      selector_( cut_ )
-      {
-	produces< std::vector<pat::Jet> >();
-	produces<reco::GenJetCollection> ("genJets");
-	produces<std::vector<CaloTower>  > ("caloTowers");
-	produces<reco::PFCandidateCollection > ("pfCandidates");
-	produces<edm::OwnVector<reco::BaseTagInfo> > ("tagInfos");
-
-	if ( params.exists("filter") ) {
-	  filter_ = params.getParameter<bool>("filter");
-	}
-      }
-
-    virtual ~PATJetSelector() {}
-
-    virtual void beginJob() {}
-    virtual void endJob() {}
-    
-    virtual bool filter(edm::Event& iEvent, const edm::EventSetup& iSetup) {
-
-      std::auto_ptr< std::vector<Jet> > patJets ( new std::vector<Jet>() ); 
-
-      std::auto_ptr<reco::GenJetCollection > genJetsOut ( new reco::GenJetCollection() );
-      std::auto_ptr<std::vector<CaloTower>  >  caloTowersOut( new std::vector<CaloTower> () );
-      std::auto_ptr<reco::PFCandidateCollection > pfCandidatesOut( new reco::PFCandidateCollection() );
-      std::auto_ptr<edm::OwnVector<reco::BaseTagInfo> > tagInfosOut ( new edm::OwnVector<reco::BaseTagInfo>() );  
-
-
-      edm::RefProd<reco::GenJetCollection > h_genJetsOut = iEvent.getRefBeforePut<reco::GenJetCollection >( "genJets" );
-      edm::RefProd<std::vector<CaloTower>  >  h_caloTowersOut = iEvent.getRefBeforePut<std::vector<CaloTower>  > ( "caloTowers" );
-      edm::RefProd<reco::PFCandidateCollection > h_pfCandidatesOut = iEvent.getRefBeforePut<reco::PFCandidateCollection > ( "pfCandidates" );
-      edm::RefProd<edm::OwnVector<reco::BaseTagInfo> > h_tagInfosOut = iEvent.getRefBeforePut<edm::OwnVector<reco::BaseTagInfo> > ( "tagInfos" );
-
-      edm::Handle< edm::View<pat::Jet> > h_jets;
-      iEvent.getByLabel( src_, h_jets );
-
-      // First loop over the products and make the secondary output collections
-      for ( edm::View<pat::Jet>::const_iterator ibegin = h_jets->begin(),
-	      iend = h_jets->end(), ijet = ibegin;
-	    ijet != iend; ++ijet ) {
-
-	// Check the selection
-	if ( selector_(*ijet) ) {	  
-	  // Copy over the calo towers
-	  for ( CaloTowerFwdPtrVector::const_iterator itowerBegin = ijet->caloTowersFwdPtr().begin(),
-		  itowerEnd = ijet->caloTowersFwdPtr().end(), itower = itowerBegin;
-		itower != itowerEnd; ++itower ) {
-	    // Add to global calo tower list
-	    caloTowersOut->push_back( **itower );
-	  }
-
-	  
-	  // Copy over the pf candidates
-	  for ( reco::PFCandidateFwdPtrVector::const_iterator icandBegin = ijet->pfCandidatesFwdPtr().begin(),
-		  icandEnd = ijet->pfCandidatesFwdPtr().end(), icand = icandBegin;
-		icand != icandEnd; ++icand ) {
-	    // Add to global pf candidate list
-	    pfCandidatesOut->push_back( **icand );
-	  }
-	  
-	  // Copy the tag infos
-	  for ( TagInfoFwdPtrCollection::const_iterator iinfoBegin = ijet->tagInfosFwdPtr().begin(),
-		  iinfoEnd = ijet->tagInfosFwdPtr().end(), iinfo = iinfoBegin;
-		iinfo != iinfoEnd; ++iinfo ) {
-	    // Add to global calo tower list
-	    tagInfosOut->push_back( **iinfo );
-	  }
-
-	  // Copy the gen jet
-	  if ( ijet->genJet() != 0 ) {
-	    genJetsOut->push_back( *(ijet->genJet()) );
-	  }
-
-	}
-      }
-
-
-      // Output the secondary collections. 
-      edm::OrphanHandle<reco::GenJetCollection>  oh_genJetsOut = iEvent.put( genJetsOut, "genJets" );
-      edm::OrphanHandle<std::vector<CaloTower> > oh_caloTowersOut = iEvent.put( caloTowersOut, "caloTowers" );
-      edm::OrphanHandle<reco::PFCandidateCollection> oh_pfCandidatesOut = iEvent.put( pfCandidatesOut, "pfCandidates" );
-      edm::OrphanHandle<edm::OwnVector<reco::BaseTagInfo> > oh_tagInfosOut = iEvent.put( tagInfosOut, "tagInfos" );
-
-
-
-
-
-      unsigned int caloTowerIndex = 0;
-      unsigned int pfCandidateIndex = 0;
-      unsigned int tagInfoIndex = 0;
-      unsigned int genJetIndex = 0;
-      // Now set the Ptrs with the orphan handles. 
-      for ( edm::View<pat::Jet>::const_iterator ibegin = h_jets->begin(),
-	      iend = h_jets->end(), ijet = ibegin;
-	    ijet != iend; ++ijet ) {
-
-	// Check the selection
-	if ( selector_(*ijet) ) {
-	  // Add the jets that pass to the output collection
-	  patJets->push_back( *ijet );
-	  
-	  // Copy over the calo towers
-	  for ( CaloTowerFwdPtrVector::const_iterator itowerBegin = ijet->caloTowersFwdPtr().begin(),
-		  itowerEnd = ijet->caloTowersFwdPtr().end(), itower = itowerBegin;
-		itower != itowerEnd; ++itower ) {
-	    // Update the "forward" bit of the FwdPtr to point at the new tower collection. 
-
-	    //  ptr to "this" tower in the global list	
-	    edm::Ptr<CaloTower> outPtr( oh_caloTowersOut, caloTowerIndex);     
-	    patJets->back().updateFwdCaloTowerFwdPtr( itower - itowerBegin,// index of "this" tower in the jet 
-						      outPtr
-						      );
-	    ++caloTowerIndex;
-	  }
-
-	  
-	  // Copy over the pf candidates
-	  for ( reco::PFCandidateFwdPtrVector::const_iterator icandBegin = ijet->pfCandidatesFwdPtr().begin(),
-		  icandEnd = ijet->pfCandidatesFwdPtr().end(), icand = icandBegin;
-		icand != icandEnd; ++icand ) {
-	    // Update the "forward" bit of the FwdPtr to point at the new tower collection. 
-
-	    // ptr to "this" cand in the global list
-	    edm::Ptr<reco::PFCandidate> outPtr( oh_pfCandidatesOut, pfCandidateIndex );
-	    patJets->back().updateFwdPFCandidateFwdPtr( icand - icandBegin,// index of "this" tower in the jet 
-							outPtr
-							);
-	    ++pfCandidateIndex;
-	  }
-	  
-	  // Copy the tag infos
-	  for ( TagInfoFwdPtrCollection::const_iterator iinfoBegin = ijet->tagInfosFwdPtr().begin(),
-		  iinfoEnd = ijet->tagInfosFwdPtr().end(), iinfo = iinfoBegin;
-		iinfo != iinfoEnd; ++iinfo ) {
-	    // Update the "forward" bit of the FwdPtr to point at the new tower collection. 
-
-	    // ptr to "this" info in the global list
-	    edm::Ptr<reco::BaseTagInfo > outPtr( oh_tagInfosOut, tagInfoIndex );
-	    patJets->back().updateFwdTagInfoFwdPtr( iinfo - iinfoBegin,// index of "this" tower in the jet 
-						    outPtr
-						    );
-	    ++tagInfoIndex;
-	  }
-
-	  // Copy the gen jet
-	  if ( ijet->genJet() != 0 ) {
-	    patJets->back().updateFwdGenJetFwdRef( edm::Ref<reco::GenJetCollection>( oh_genJetsOut, genJetIndex) // ref to "this" genjet in the global list
-						   );
-	    ++genJetIndex;
-	  }
-
-	}
-      }
-
-
-      // put genEvt  in Event
-      bool pass = patJets->size() > 0;
-      iEvent.put(patJets);
-
-      if ( filter_ ) 
-	return pass;
-      else 
-	return true;
-    }
-
-  protected:
-    edm::InputTag                  src_;
-    std::string                    cut_;
-    bool                           filter_;
-    StringCutObjectSelector<Jet>   selector_;
-  };
-
-}
-
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATLeptonCountFilter.cc b/PhysicsTools/PatAlgos/plugins/PATLeptonCountFilter.cc
deleted file mode 100755
index 9dda7ca..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATLeptonCountFilter.cc
+++ /dev/null
@@ -1,50 +0,0 @@
-//
-// $Id: PATLeptonCountFilter.cc,v 1.1 2008/03/06 09:23:10 llista Exp $
-//
-
-#include "PhysicsTools/PatAlgos/plugins/PATLeptonCountFilter.h"
-
-#include "DataFormats/Common/interface/Handle.h"
-#include "DataFormats/Common/interface/View.h"
-
-#include "DataFormats/PatCandidates/interface/Electron.h"
-#include "DataFormats/PatCandidates/interface/Muon.h"
-#include "DataFormats/PatCandidates/interface/Tau.h"
-
-
-using namespace pat;
-
-
-PATLeptonCountFilter::PATLeptonCountFilter(const edm::ParameterSet & iConfig) {
-  electronSource_ = iConfig.getParameter<edm::InputTag>( "electronSource" );
-  muonSource_     = iConfig.getParameter<edm::InputTag>( "muonSource" );
-  tauSource_      = iConfig.getParameter<edm::InputTag>( "tauSource" );
-  countElectrons_ = iConfig.getParameter<bool>         ( "countElectrons" );
-  countMuons_     = iConfig.getParameter<bool>         ( "countMuons" );
-  countTaus_      = iConfig.getParameter<bool>         ( "countTaus" );
-  minNumber_      = iConfig.getParameter<unsigned int> ( "minNumber" );
-  maxNumber_      = iConfig.getParameter<unsigned int> ( "maxNumber" );
-}
-
-
-PATLeptonCountFilter::~PATLeptonCountFilter() {
-}
-
-
-bool PATLeptonCountFilter::filter(edm::Event & iEvent, const edm::EventSetup & iSetup) {
-  edm::Handle<edm::View<Electron> > electrons;
-  if (countElectrons_) iEvent.getByLabel(electronSource_, electrons);
-  edm::Handle<edm::View<Muon> > muons;
-  if (countMuons_) iEvent.getByLabel(muonSource_, muons);
-  edm::Handle<edm::View<Tau> > taus;
-  if (countTaus_) iEvent.getByLabel(tauSource_, taus);
-  unsigned int nrLeptons = 0;
-  nrLeptons += (countElectrons_ ? electrons->size() : 0);
-  nrLeptons += (countMuons_     ? muons->size()     : 0);
-  nrLeptons += (countTaus_      ? taus->size()      : 0);
-  return nrLeptons >= minNumber_ && nrLeptons <= maxNumber_;
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-DEFINE_FWK_MODULE(PATLeptonCountFilter);
-
diff --git a/PhysicsTools/PatAlgos/plugins/PATLeptonCountFilter.h b/PhysicsTools/PatAlgos/plugins/PATLeptonCountFilter.h
deleted file mode 100644
index 099643f..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATLeptonCountFilter.h
+++ /dev/null
@@ -1,44 +0,0 @@
-//
-// $Id: PATLeptonCountFilter.h,v 1.1 2008/03/06 09:23:10 llista Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATLeptonCountFilter_h
-#define PhysicsTools_PatAlgos_PATLeptonCountFilter_h
-
-#include "FWCore/Framework/interface/EDFilter.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/EventSetup.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-
-namespace pat {
-
-
-  class PATLeptonCountFilter : public edm::EDFilter {
-
-    public:
-
-      explicit PATLeptonCountFilter(const edm::ParameterSet & iConfig);
-      virtual ~PATLeptonCountFilter();
-
-    private:
-
-      virtual bool filter(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-    private:
-
-      edm::InputTag electronSource_;
-      edm::InputTag muonSource_;
-      edm::InputTag tauSource_;
-      bool          countElectrons_;
-      bool          countMuons_;
-      bool          countTaus_;
-      unsigned int  minNumber_;
-      unsigned int  maxNumber_;
-
-  };
-
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATMETProducer.cc b/PhysicsTools/PatAlgos/plugins/PATMETProducer.cc
deleted file mode 100755
index 1c3d070..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATMETProducer.cc
+++ /dev/null
@@ -1,144 +0,0 @@
-//
-// $Id: PATMETProducer.cc,v 1.14 2009/06/25 23:49:35 gpetrucc Exp $
-//
-
-#include "PhysicsTools/PatAlgos/plugins/PATMETProducer.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "FWCore/ParameterSet/interface/FileInPath.h"
-#include "DataFormats/Common/interface/View.h"
-
-#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
-#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
-
-#include <memory>
-
-
-using namespace pat;
-
-
-PATMETProducer::PATMETProducer(const edm::ParameterSet & iConfig):
-  useUserData_(iConfig.exists("userData"))
-{
-  // initialize the configurables
-  metSrc_         = iConfig.getParameter<edm::InputTag>("metSource");
-  addGenMET_      = iConfig.getParameter<bool>         ("addGenMET");
-  genMETSrc_      = iConfig.getParameter<edm::InputTag>("genMETSource");
-  addResolutions_ = iConfig.getParameter<bool>         ("addResolutions");
-
-  // Efficiency configurables
-  addEfficiencies_ = iConfig.getParameter<bool>("addEfficiencies");
-  if (addEfficiencies_) {
-     efficiencyLoader_ = pat::helper::EfficiencyLoader(iConfig.getParameter<edm::ParameterSet>("efficiencies"));
-  }
-
-  // Resolution configurables
-  addResolutions_ = iConfig.getParameter<bool>("addResolutions");
-  if (addResolutions_) {
-     resolutionLoader_ = pat::helper::KinResolutionsLoader(iConfig.getParameter<edm::ParameterSet>("resolutions"));
-  }
-
-  // Check to see if the user wants to add user data
-  if ( useUserData_ ) {
-    userDataHelper_ = PATUserDataHelper<MET>(iConfig.getParameter<edm::ParameterSet>("userData"));
-  }
-
-  
-  // produces vector of mets
-  produces<std::vector<MET> >();
-}
-
-
-PATMETProducer::~PATMETProducer() {
-}
-
-
-void PATMETProducer::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) {
- 
-  // Get the vector of MET's from the event
-  edm::Handle<edm::View<reco::MET> > mets;
-  iEvent.getByLabel(metSrc_, mets);
-
-  if (mets->size() != 1) throw cms::Exception("Corrupt Data") << "The input MET collection " << metSrc_.encode() << " has size " << mets->size() << " instead of 1 as it should.\n";
-  if (efficiencyLoader_.enabled()) efficiencyLoader_.newEvent(iEvent);
-  if (resolutionLoader_.enabled()) resolutionLoader_.newEvent(iEvent, iSetup);
-
-  // Get the vector of generated met from the event if needed
-  edm::Handle<edm::View<reco::GenMET> > genMETs;
-  if (addGenMET_) {
-    iEvent.getByLabel(genMETSrc_, genMETs);
-  }
-
-  // loop over mets
-  std::vector<MET> * patMETs = new std::vector<MET>(); 
-  for (edm::View<reco::MET>::const_iterator itMET = mets->begin(); itMET != mets->end(); itMET++) {
-    // construct the MET from the ref -> save ref to original object
-    unsigned int idx = itMET - mets->begin();
-    edm::RefToBase<reco::MET> metsRef = mets->refAt(idx);
-    edm::Ptr<reco::MET> metsPtr = mets->ptrAt(idx);
-    MET amet(metsRef);
-    // add the generated MET
-    if (addGenMET_) amet.setGenMET((*genMETs)[idx]);
-
-    if (efficiencyLoader_.enabled()) {
-        efficiencyLoader_.setEfficiencies( amet, metsRef );
-    }
-
-    if (resolutionLoader_.enabled()) {
-        resolutionLoader_.setResolutions(amet);
-    }
-
-
-    if ( useUserData_ ) {
-      userDataHelper_.add( amet, iEvent, iSetup );
-    }
-    
-
-    // correct for muons if demanded... never more: it's now done by JetMETCorrections
-    // add the MET to the vector of METs
-    patMETs->push_back(amet);
-  }
-
-  // sort MET in ET .. don't mess with this
-  //  std::sort(patMETs->begin(), patMETs->end(), eTComparator_);
-
-  // put genEvt object in Event
-  std::auto_ptr<std::vector<MET> > myMETs(patMETs);
-  iEvent.put(myMETs);
-
-}
-
-// ParameterSet description for module
-void PATMETProducer::fillDescriptions(edm::ConfigurationDescriptions & descriptions)
-{
-  edm::ParameterSetDescription iDesc;
-  iDesc.setComment("PAT MET producer module");
-
-  // input source 
-  iDesc.add<edm::InputTag>("metSource", edm::InputTag("no default"))->setComment("input collection");
-
-  // MC configurations
-  iDesc.add<bool>("addGenMET", false);
-  iDesc.add<edm::InputTag>("genMETSource", edm::InputTag("genMetCalo"));
-
-  pat::helper::KinResolutionsLoader::fillDescription(iDesc);
-
-  // Efficiency configurables
-  edm::ParameterSetDescription efficienciesPSet;
-  efficienciesPSet.setAllowAnything(); // TODO: the pat helper needs to implement a description.
-  iDesc.add("efficiencies", efficienciesPSet);
-  iDesc.add<bool>("addEfficiencies", false);
-
-  // Check to see if the user wants to add user data
-  edm::ParameterSetDescription userDataPSet;
-  PATUserDataHelper<MET>::fillDescription(userDataPSet);
-  iDesc.addOptional("userData", userDataPSet);
-
-  // muon correction
-  iDesc.add<bool>("addMuonCorrections", false);
-  iDesc.add<edm::InputTag>("muonSource", edm::InputTag("muons"));
-
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATMETProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATMETProducer.h b/PhysicsTools/PatAlgos/plugins/PATMETProducer.h
deleted file mode 100644
index 2cede7c..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATMETProducer.h
+++ /dev/null
@@ -1,73 +0,0 @@
-//
-// $Id: PATMETProducer.h,v 1.10 2009/06/25 23:49:35 gpetrucc Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATMETProducer_h
-#define PhysicsTools_PatAlgos_PATMETProducer_h
-
-/**
-  \class    pat::PATMETProducer PATMETProducer.h "PhysicsTools/PatAlgos/interface/PATMETProducer.h"
-  \brief    Produces the pat::MET
-
-   The PATMETProducer produces the analysis-level pat::MET starting from
-   a collection of objects of METType.
-
-  \author   Steven Lowette
-  \version  $Id: PATMETProducer.h,v 1.10 2009/06/25 23:49:35 gpetrucc Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-#include "CommonTools/Utils/interface/EtComparator.h"
-
-#include "DataFormats/PatCandidates/interface/MET.h"
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-
-
-#include "DataFormats/PatCandidates/interface/UserData.h"
-#include "PhysicsTools/PatAlgos/interface/PATUserDataHelper.h"
-
-
-namespace pat {
-
-  class PATMETProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATMETProducer(const edm::ParameterSet & iConfig);
-      ~PATMETProducer();
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-      static void fillDescriptions(edm::ConfigurationDescriptions & descriptions);
-
-    private:
-
-      // configurables
-      edm::InputTag metSrc_;
-      bool          addGenMET_;
-      edm::InputTag genMETSrc_;
-      bool          addResolutions_;
-      pat::helper::KinResolutionsLoader resolutionLoader_;
-      bool          addMuonCorr_;
-      edm::InputTag muonSrc_;
-      // tools
-      GreaterByEt<MET> eTComparator_;
-
-      bool addEfficiencies_;
-      pat::helper::EfficiencyLoader efficiencyLoader_;
-
-      bool useUserData_;
-      pat::PATUserDataHelper<pat::MET>      userDataHelper_;
-
-
-  };
-
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATMHTProducer.cc b/PhysicsTools/PatAlgos/plugins/PATMHTProducer.cc
deleted file mode 100755
index 41f043b..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATMHTProducer.cc
+++ /dev/null
@@ -1,511 +0,0 @@
-//
-// $Id: PATMHTProducer.cc,v 1.7 2010/01/11 13:36:48 hegner Exp $
-//
-
-#include "PhysicsTools/PatAlgos/plugins/PATMHTProducer.h"
-
-pat::PATMHTProducer::PATMHTProducer(const edm::ParameterSet & iConfig){
-
-  // Initialize the configurables
-  verbose_ = iConfig.getParameter<double>("verbose");
-
-  jetLabel_ = iConfig.getUntrackedParameter<edm::InputTag>("jetTag");
-  eleLabel_ = iConfig.getUntrackedParameter<edm::InputTag>("electronTag");
-  muoLabel_ = iConfig.getUntrackedParameter<edm::InputTag>("muonTag");
-  tauLabel_ = iConfig.getUntrackedParameter<edm::InputTag>("tauTag");
-  phoLabel_ = iConfig.getUntrackedParameter<edm::InputTag>("photonTag");
-  
-  uncertaintyScaleFactor_ = iConfig.getParameter<double>( "uncertaintyScaleFactor") ;
-  controlledUncertainty_  = iConfig.getParameter<bool>( "controlledUncertainty") ;
-
-  jetPtMin_     = iConfig.getParameter<double>("jetPtMin");
-  jetEtaMax_    = iConfig.getParameter<double>("jetEtaMax");
-  jetEMfracMax_ = iConfig.getParameter<double>("jetEMfracMax");
-  elePtMin_     = iConfig.getParameter<double>("elePtMin");
-  eleEtaMax_    = iConfig.getParameter<double>("eleEtaMax");
-  muonPtMin_    = iConfig.getParameter<double>("muonPtMin");
-  muonEtaMax_   = iConfig.getParameter<double>("muonEtaMax");
-
-  jetEtUncertaintyParameter0_ =  iConfig.getParameter<double>( "jetEtUncertaintyParameter0") ; 
-  jetEtUncertaintyParameter1_ =  iConfig.getParameter<double>( "jetEtUncertaintyParameter1") ; 
-  jetEtUncertaintyParameter2_ =  iConfig.getParameter<double>( "jetEtUncertaintyParameter2") ; 
-  jetPhiUncertaintyParameter0_=  iConfig.getParameter<double>( "jetPhiUncertaintyParameter0"); 
-  jetPhiUncertaintyParameter1_=  iConfig.getParameter<double>( "jetPhiUncertaintyParameter1"); 
-  jetPhiUncertaintyParameter2_=  iConfig.getParameter<double>( "jetPhiUncertaintyParameter2"); 
-    
-  eleEtUncertaintyParameter0_  =  iConfig.getParameter<double>( "eleEtUncertaintyParameter0") ; 
-  elePhiUncertaintyParameter0_ =  iConfig.getParameter<double>( "elePhiUncertaintyParameter0") ; 
-
-  muonEtUncertaintyParameter0_  =  iConfig.getParameter<double>( "muonEtUncertaintyParameter0") ; 
-  muonPhiUncertaintyParameter0_ =  iConfig.getParameter<double>( "muonPhiUncertaintyParameter0") ; 
-
-  CaloTowerTag_  = iConfig.getParameter<edm::InputTag>("CaloTowerTag");
-  noHF_ = iConfig.getParameter<bool>( "noHF"); 
-  
-  //  muonCalo_ = iConfig.getParameter<bool>("muonCalo");
-  towerEtThreshold_ = iConfig.getParameter<double>( "towerEtThreshold") ; 
-  useHO_ = iConfig.getParameter<bool>("useHO");
-
-  produces<pat::MHTCollection>();
-
-}
-
-
-pat::PATMHTProducer::~PATMHTProducer() {
-}
-
-void pat::PATMHTProducer::beginJob() {
-  setUncertaintyParameters();
-}
-void pat::PATMHTProducer::beginRun(const edm::EventSetup& iSetup) {
-}
-
-void pat::PATMHTProducer::endJob() {
-}
-
-
-void 
-pat::PATMHTProducer::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) 
-{
-  // make sure the SigInputObj container is empty
-  while(physobjvector_.size()>0){
-    physobjvector_.erase(physobjvector_.begin(),physobjvector_.end());
-  }
-
-  // Clean the clustered towers 
-  s_clusteredTowers.clear();
-
-  double number_of_jets = getJets(iEvent, iSetup);
-
-  double number_of_electrons = getElectrons(iEvent, iSetup);
-
-  double number_of_muons = getMuons(iEvent, iSetup);
-
-  if (verbose_ == 1.) {
-    std::cout << ">>>---> Number of jets: "  <<  number_of_jets << std::endl;
-    std::cout << ">>>---> Number of electrons: "  <<  number_of_jets << std::endl;
-    std::cout << ">>>---> Number of muons: " <<  number_of_muons << std::endl;
-  }
-
-  double met_x=0;
-  double met_y=0;
-  double met_et=0;
-  double met_phi=0;
-  double met_set=0;
-  
-  
-  std::auto_ptr<pat::MHTCollection>  themetsigcoll (new pat::MHTCollection);
-
-  if(physobjvector_.size() >= 1) { // Only when the vector is not empty 
-
-    // calculate the MHT significance
-
-    metsig::significanceAlgo signifAlgo;
-    signifAlgo.addObjects(physobjvector_);
-    double significance = signifAlgo.significance(met_et,met_phi,met_set);
-    
-    met_x=met_et*cos(met_phi);
-    met_y=met_et*sin(met_phi);
-  
-    if (verbose_ == 1.) {
-      std::cout << ">>>----> MHT Sgificance = " << significance << std::endl;
-    }
- 
-    pat::MHT themetsigobj(reco::Particle::LorentzVector(met_x,met_y,0,met_et),met_set,significance);
-
-
-    // Store the number of jets, electrons, muons
-    themetsigobj.setNumberOfJets(number_of_jets);
-    themetsigobj.setNumberOfElectrons(number_of_electrons);
-    themetsigobj.setNumberOfMuons(number_of_muons);
-
-    themetsigcoll->push_back(themetsigobj);
-
-  } // If the vector is empty, just put empty product. 
-
-
-  iEvent.put( themetsigcoll);
-
-  
-}  
-
-// --------------------------------------------------
-//  Fill Input Vector with Jets
-// --------------------------------------------------
-double 
-pat::PATMHTProducer::getJets(edm::Event& iEvent, const edm::EventSetup & iSetup){
-
-  std::string objectname="jet";
-
-  double number_of_jets_ = 0.0;
-
-  edm::Handle<edm::View<pat::Jet> > jetHandle;
-  iEvent.getByLabel(jetLabel_,jetHandle);
-  edm::View<pat::Jet> jets = *jetHandle;
-
-  // Fill Input Vector with Jets 
-  for(edm::View<pat::Jet>::const_iterator jet_iter = jets.begin(); jet_iter!=jets.end(); ++jet_iter){
-    
-    if( (jet_iter->pt()  < jetPtMin_) ||
-	(TMath::Abs(jet_iter->eta()) > jetEtaMax_) || 
-        (jet_iter->emEnergyFraction() > jetEMfracMax_ ) )
-      continue; 
-    
-    double jet_et = jet_iter->et();
-    double jet_phi = jet_iter->phi();
-    
-    if (verbose_ == 3.) {
-      std::cout << "jet pt : " << jet_iter->pt() << " eta : " << jet_iter->eta() 
-		<< " EMF: "  << jet_iter->emEnergyFraction() <<  std::endl;
-    }
-    
-    double sigma_et, sigma_phi ;
-
-    if (controlledUncertainty_) {
-      sigma_et  = jetUncertainty.etUncertainty->Eval(jet_et);
-      sigma_phi = jetUncertainty.phiUncertainty->Eval(jet_et);
-    } 
-    else {
-      sigma_et = 0.0 ; // jet_iter->resolutionEt();
-      sigma_phi =  0.0 ; //jet_iter->resolutionPhi();
-    }
-
-    if (verbose_ == 3.) {
-      std::cout << "jet sigma_et : " << sigma_et << ", jet sigma_phi : " << sigma_phi <<  std::endl;
-    }
-
-    if(sigma_et<=0 || sigma_phi<=0)
-      edm::LogWarning("PATMHTProducer") << 
-	" uncertainties for "  << objectname <<
-	" are (et, phi): " << sigma_et << "," << sigma_phi << " (et,phi): " << jet_et << "," << jet_phi;
-    // try to read out the jet resolution from the root file at PatUtils
-    //-- Store jet for Significance Calculation --//
-    
-    if (uncertaintyScaleFactor_ != 1.0){
-      sigma_et  = sigma_et  * uncertaintyScaleFactor_;
-      sigma_phi = sigma_phi * uncertaintyScaleFactor_;
-      // edm::LogWarning("PATMHTProducer") << " using uncertainty scale factor: " << uncertaintyScaleFactor_ <<
-      //" , uncertainties for " << objectname <<" changed to (et, phi): " << sigma_et << "," << sigma_phi; 
-    }
-
-
-    if (verbose_ == 101.) { // Study the Jets behavior
-
-      std::cout << "v101> " <<  number_of_jets_ << "  " 
-		<< jet_et   << "  "  <<  sigma_et << "  "
-		<< jet_phi  << "  "  <<  sigma_phi << std::endl;
-    }
-  
-
-    metsig::SigInputObj tmp_jet(objectname,jet_et,jet_phi,sigma_et,sigma_phi);
-    physobjvector_.push_back(tmp_jet);
-    number_of_jets_ ++;
-
-    //-- Store tower DetId's to be removed from Calo Tower sum later --//
-    std::vector<CaloTowerPtr> v_towers = jet_iter->getCaloConstituents();
-    //std::cout << "tower size = " << v_towers.size() << std::endl;
-
-    for (unsigned int ii=0; ii < v_towers.size(); ii++) {
-      s_clusteredTowers.insert( (*v_towers.at(ii)).id() );
-      //std::cout << "tower id = " << (*v_towers.at(ii)).id() << std::endl;
-    }
-
-  }
-  
-  if (verbose_ == 101.) { // Study the Jets behavior - seperate events
-    std::cout << "v101> --------------------------------------------" << std::endl;
-  }
- 
-  return number_of_jets_;
-
-}
-
-
-// --------------------------------------------------
-//  Fill Input Vector with Electrons
-// --------------------------------------------------
-double
-pat::PATMHTProducer::getElectrons(edm::Event& iEvent, const edm::EventSetup & iSetup){
-
-  std::string objectname="electron";
-
-  double number_of_electrons_ = 0.0;
-
-  // edm::ESHandle<CaloTowerConstituentsMap> cttopo;
-  // iSetup.get<IdealGeometryRecord>().get(cttopo);
-  // const CaloTowerConstituentsMap* caloTowerMap = cttopo.product();
-
-  edm::Handle<edm::View<pat::Electron> > electronHandle;
-  iEvent.getByLabel(eleLabel_,electronHandle);
-  edm::View<pat::Electron> electrons = *electronHandle;
-  DetId nullDetId;
-
-  // Fill Input Vector with Electrons 
-  for(edm::View<pat::Electron>::const_iterator electron_iter = electrons.begin(); electron_iter!=electrons.end(); ++electron_iter){
-
-    // Select electrons
-    if (electron_iter->et() < elePtMin_ || 
-	TMath::Abs(electron_iter->eta()) > eleEtaMax_  ) continue; 
-
-    if (verbose_ == 3.) {
-      std::cout << "electron pt = " << electron_iter->pt()  << " eta : " << electron_iter->eta() 
-		<<  std::endl;
-    }
-
-    double electron_et  = electron_iter->et();
-    double electron_phi = electron_iter->phi();
-
-    double sigma_et, sigma_phi ;
-
-    if (controlledUncertainty_) {
-      sigma_et  = eleUncertainty.etUncertainty->Eval(electron_et);
-      sigma_phi = eleUncertainty.phiUncertainty->Eval(electron_et);
-    } 
-    else {
-      sigma_et = 0.0; //electron_iter->resolutionEt();
-      sigma_phi = 0.0; // electron_iter->resolutionPhi();
-    }
-
-    if (verbose_ == 3.) {
-      std::cout << "electron sigma_et : " << sigma_et << ", electron sigma_phi : " << sigma_phi
-		<<  std::endl;}
-
-    if(sigma_et< 0 || sigma_phi< 0)
-      edm::LogWarning("PATMHTProducer") << " uncertainties for "  << objectname 
-					<<" are (et, phi): " << sigma_et 
-					<< "," << sigma_phi <<  " (et,phi): " 
-					<< electron_et << "," << electron_phi;
-    
-    if (uncertaintyScaleFactor_ != 1.0){
-      sigma_et  = sigma_et  * uncertaintyScaleFactor_;
-      sigma_phi = sigma_phi * uncertaintyScaleFactor_;
-    }
-
-    metsig::SigInputObj tmp_electron(objectname,electron_et,electron_phi,sigma_et,sigma_phi);
-    physobjvector_.push_back(tmp_electron);
-    number_of_electrons_ ++; 
-    
-    //-- Store tower DetId's to be removed from Calo Tower sum later --//
-    /*
-    const reco::SuperCluster& eleSC = *( electron_iter->superCluster() );
-    
-    std::vector<DetId> v_eleDetIds = eleSC.getHitsByDetId();
-    
-    //-- Convert cells to calo towers and add to set --//
-    for( std::vector<DetId>::iterator cellId = v_eleDetIds.begin();
-         cellId != v_eleDetIds.end();
-         cellId++) {
-
-      CaloTowerDetId towerId = caloTowerMap->towerOf(*cellId);
-      if (towerId != nullDetId) {
-	//std::cout << ">>> electron towerId: " << towerId << std::endl;
-	std::pair<std::_Rb_tree_const_iterator<CaloTowerDetId>,bool> p1 = s_clusteredTowers.insert(towerId);
-      }
-      else
-	std::cerr<<"No matching tower found for electron cell!\n";
-    }
-
-    */
-
-  }
-
-  return number_of_electrons_; 
-}
-
-
-
-// --------------------------------------------------
-//  Fill Input Vector with Muons
-// --------------------------------------------------
-
-double pat::PATMHTProducer::getMuons(edm::Event& iEvent, const edm::EventSetup & iSetup){
-
-  std::string objectname="muon";
-  edm::Handle<edm::View<pat::Muon> > muonHandle;
-  iEvent.getByLabel(muoLabel_,muonHandle);
-  edm::View<pat::Muon> muons = *muonHandle;
-
-  if ( !muonHandle.isValid() ) {
-    std::cout << ">>> PATMHTSelector not valid muon Handle!" << std::endl;
-    return 0.0;
-  }
-
-
-  double number_of_muons_ = 0.0;
-
-  for(edm::View<pat::Muon>::const_iterator muon_iter = muons.begin(); muon_iter!=muons.end(); ++muon_iter){
-
-    if (muon_iter->pt() < muonPtMin_ || TMath::Abs(muon_iter->eta()) > muonEtaMax_  ) continue; 
-
-    if (verbose_ == 3.) {
-      std::cout << "muon pt = " << muon_iter->pt() << " eta : " << muon_iter->eta() <<  std::endl;
-    }
-
-    double muon_pt  = muon_iter->pt();
-    double muon_phi = muon_iter->phi();
-
-    double sigma_et, sigma_phi ;
-
-    if (controlledUncertainty_) {
-       sigma_et  = muonUncertainty.etUncertainty->Eval(muon_pt);
-       sigma_phi = muonUncertainty.phiUncertainty->Eval(muon_pt);
-    } 
-    else {
-      sigma_et  = 0.0; //muon_iter->resolutionEt();
-      sigma_phi = 0.0; // muon_iter->resolutionPhi();
-    }
-
-    if (verbose_ == 3.) {
-      std::cout << "muon sigma_et : " << sigma_et
-		<< ", muon sigma_phi : " << sigma_phi
-		<<  std::endl;}
-
-   if(sigma_et< 0 || sigma_phi< 0)
-      edm::LogWarning("PATMHTProducer") << 
-	" uncertainties for "  << objectname << " are (et, phi): " << sigma_et << "," <<
-	sigma_phi << " (pt,phi): " << muon_pt << "," << muon_phi;
-
-    if (uncertaintyScaleFactor_ != 1.0){
-      sigma_et  = sigma_et  * uncertaintyScaleFactor_;
-      sigma_phi = sigma_phi * uncertaintyScaleFactor_;
-    }
-
-    metsig::SigInputObj tmp_muon(objectname,muon_pt,muon_phi,sigma_et,sigma_phi);
-    physobjvector_.push_back(tmp_muon);
-    number_of_muons_ ++;
-
-  }// end Muon loop
-
-  return number_of_muons_;
-}
-
-
-//=== Uncertainty Functions ===============================================
-void pat::PATMHTProducer::setUncertaintyParameters(){
-
-  // set the various functions here:
-
-  //-- For Et functions, [0]= par_n, [1]=par_s, [2]= par_c ---//
-  //-- Ecal Uncertainty Functions ------------------------------------//
-  //-- From: FastSimulation/Calorimetry/data/HcalResponse.cfi --//
-  //-- Ecal Barrel --//
-  ecalEBUncertainty.etUncertainty = new TF1("ecalEBEtFunc","x*sqrt(([0]*[0]/(x*x))+([1]*[1]/x)+([2]*[2]))",3);
-  ecalEBUncertainty.etUncertainty->SetParameter(0,0.2);
-  ecalEBUncertainty.etUncertainty->SetParameter(1,0.03);
-  ecalEBUncertainty.etUncertainty->SetParameter(2,0.005);
-
-  ecalEBUncertainty.phiUncertainty = new TF1("ecalEBphiFunc","[0]*x",1);
-  ecalEBUncertainty.phiUncertainty->SetParameter(0,0.0174);
-
-  //-- Ecal Endcap --//
-  ecalEEUncertainty.etUncertainty = new TF1("ecalEEEtFunc","x*sqrt(([0]*[0]/(x*x))+([1]*[1]/x)+([2]*[2]))",3);
-  ecalEEUncertainty.etUncertainty->SetParameter(0,0.2);
-  ecalEEUncertainty.etUncertainty->SetParameter(1,0.03);
-  ecalEEUncertainty.etUncertainty->SetParameter(2,0.005);
-
-  ecalEEUncertainty.phiUncertainty = new TF1("ecalEEphiFunc","[0]*x",1);
-  ecalEEUncertainty.phiUncertainty->SetParameter(0,0.087);
-
-  //-- Hcal Uncertainty Functions --------------------------------------//
-  //-- From: FastSimulation/Calorimetry/data/HcalResponse.cfi --//
-  //-- Hcal Barrel --//
-  hcalHBUncertainty.etUncertainty = new TF1("hcalHBEtFunc","x*sqrt(([0]*[0]/(x*x))+([1]*[1]/x)+([2]*[2]))",3);
-  hcalHBUncertainty.etUncertainty->SetParameter(0,0.);
-  hcalHBUncertainty.etUncertainty->SetParameter(1,1.22);
-  hcalHBUncertainty.etUncertainty->SetParameter(2,0.05);
-
-  hcalHBUncertainty.phiUncertainty = new TF1("ecalHBphiFunc","[0]*x",1);
-  hcalHBUncertainty.phiUncertainty->SetParameter(0,0.087);
-
-  //-- Hcal Endcap --//
-  hcalHEUncertainty.etUncertainty = new TF1("hcalHEEtFunc","x*sqrt(([0]*[0]/(x*x))+([1]*[1]/x)+([2]*[2]))",3);
-  hcalHEUncertainty.etUncertainty->SetParameter(0,0.);
-  hcalHEUncertainty.etUncertainty->SetParameter(1,1.3);
-  hcalHEUncertainty.etUncertainty->SetParameter(2,0.05);
-
-  hcalHEUncertainty.phiUncertainty = new TF1("ecalHEphiFunc","[0]*x",1);
-  hcalHEUncertainty.phiUncertainty->SetParameter(0,0.087);
-
-  //-- Hcal Outer --//
-  hcalHOUncertainty.etUncertainty = new TF1("hcalHOEtFunc","x*sqrt(([0]*[0]/(x*x))+([1]*[1]/x)+([2]*[2]))",3);
-  hcalHOUncertainty.etUncertainty->SetParameter(0,0.);
-  hcalHOUncertainty.etUncertainty->SetParameter(1,1.82);
-  hcalHOUncertainty.etUncertainty->SetParameter(2,0.09);
-
-  hcalHOUncertainty.phiUncertainty = new TF1("ecalHOphiFunc","[0]*x",1);
-  hcalHOUncertainty.phiUncertainty->SetParameter(0,0.087);
-
-  //-- Hcal Forward --//
-  hcalHFUncertainty.etUncertainty = new TF1("hcalHFEtFunc","x*sqrt(([0]*[0]/(x*x))+([1]*[1]/x)+([2]*[2]))",3);
-  hcalHFUncertainty.etUncertainty->SetParameter(0,0.);
-  hcalHFUncertainty.etUncertainty->SetParameter(1,1.82);
-  hcalHFUncertainty.etUncertainty->SetParameter(2,0.09);
-
-  hcalHFUncertainty.phiUncertainty = new TF1("ecalHFphiFunc","[0]*x",1);
-  hcalHFUncertainty.phiUncertainty->SetParameter(0,0.174);
-
-  //--- Jet Uncertainty Functions --------------------------------------//
-  jetUncertainty.etUncertainty = new TF1("jetEtFunc","x*sqrt(([0]*[0]/(x*x))+([1]*[1]/x)+([2]*[2]))",3);
-  //-- values from PTDR 1, ch 11.4 --//
-  jetUncertainty.etUncertainty->SetParameter(0, jetEtUncertaintyParameter0_);
-  jetUncertainty.etUncertainty->SetParameter(1, jetEtUncertaintyParameter1_);
-  jetUncertainty.etUncertainty->SetParameter(2, jetEtUncertaintyParameter2_);
-
-
-  //-- phi value from our own fits --//
-  //jetUncertainty.phiUncertainty = new TF1("jetPhiFunc","[0]*x",1);
-  //jetUncertainty.phiUncertainty->SetParameter(0, jetPhiUncertaintyParameter0_);
-
-  //-- phi Functions and values from 
-  // http://indico.cern.ch/getFile.py/access?contribId=9&sessionId=0&resId=0&materialId=slides&confId=46394
-  jetUncertainty.phiUncertainty = new TF1("jetPhiFunc","x*sqrt(([0]*[0]/(x*x))+([1]*[1]/x)+([2]*[2]))",3);
-  jetUncertainty.phiUncertainty->SetParameter(0, jetPhiUncertaintyParameter0_);
-  jetUncertainty.phiUncertainty->SetParameter(1, jetPhiUncertaintyParameter1_);
-  jetUncertainty.phiUncertainty->SetParameter(2, jetPhiUncertaintyParameter2_);
-  
-
-
-  //-- Jet corrections are assumed not to have an error --//
-  /*jetCorrUncertainty.etUncertainty = new TF1("jetCorrEtFunc","[0]*x",1);
-  jetCorrUncertainty.etUncertainty->SetParameter(0,0.0);
-  jetCorrUncertainty.phiUncertainty = new TF1("jetCorrPhiFunc","[0]*x",1);
-  jetCorrUncertainty.phiUncertainty->SetParameter(0,0.0*(3.14159/180.));*/
-
-
-  //--- Electron Uncertainty Functions ---------------------------------//
-  // completely ambiguious values for electron-like jets...
-  // the egamma group keeps track of these here:
-  // https://twiki.cern.ch/twiki/bin/view/CMS/EgammaCMSSWVal
-  // electron resolution in energy is around 3.4%, measured for 10 < pT < 50 at realistic events with pile-up.
-  
-  eleUncertainty.etUncertainty = new TF1("eleEtFunc","[0] * x",1);
-  //  eleUncertainty.etUncertainty->SetParameter(0,0.034); 
-  eleUncertainty.etUncertainty->SetParameter(0, eleEtUncertaintyParameter0_); 
-
-
-  eleUncertainty.phiUncertainty = new TF1("elePhiFunc","[0] * x",1);
-  //  eleUncertainty.phiUncertainty->SetParameter(0,1*(3.14159/180.));
-  eleUncertainty.phiUncertainty->SetParameter(0, elePhiUncertaintyParameter0_);
-
-  //--- Muon Uncertainty Functions ------------------------------------//
-  // and ambiguious values for the muons...
-  
-  muonUncertainty.etUncertainty = new TF1("muonEtFunc","[0] * x",1);
-  //  muonUncertainty.etUncertainty->SetParameter(0,0.01);
-  muonUncertainty.etUncertainty->SetParameter(0, muonEtUncertaintyParameter0_);
-  muonUncertainty.phiUncertainty = new TF1("muonPhiFunc","[0] * x",1);
-  //  muonUncertainty.phiUncertainty->SetParameter(0,1*(3.14159/180.));
-  muonUncertainty.phiUncertainty->SetParameter(0, muonPhiUncertaintyParameter0_);
-
-  //-- Muon calo deposites are assumed not to have an error --//
-  /*muonCorrUncertainty.etUncertainty = new TF1("muonCorrEtFunc","[0] * x",1);
-  muonCorrUncertainty.etUncertainty->SetParameter(0,0.0);
-  muonCorrUncertainty.phiUncertainty = new TF1("muonCorrPhiFunc","[0] * x",1);
-  muonCorrUncertainty.phiUncertainty->SetParameter(0,0.0*(3.14159/180.)); */
- 
-}
-
-
-using namespace pat; 
-DEFINE_FWK_MODULE(PATMHTProducer);
-
diff --git a/PhysicsTools/PatAlgos/plugins/PATMHTProducer.h b/PhysicsTools/PatAlgos/plugins/PATMHTProducer.h
deleted file mode 100644
index 9238d45..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATMHTProducer.h
+++ /dev/null
@@ -1,186 +0,0 @@
-// -*- C++ -*-
-//
-// Package:    PATMHTProducer
-// Class:      PATMHTProducer
-// 
-/**\class PATMHTProducer 
-
- Description: <one line class summary>
-
- Implementation:
-     <Notes on implementation>
-*/
-//
-// Original Author:  Xin Shi & Freya Blekman, Cornell University
-//         Created:  Fri Sep 12 17:58:29 CEST 2008
-// $Id: PATMHTProducer.h,v 1.5 2010/02/20 21:00:24 wmtan Exp $
-//
-//
-
-#ifndef PhysicsTools_PatAlgos_PATMHTProducer_h
-#define PhysicsTools_PatAlgos_PATMHTProducer_h
-
-
-
-// system include files
-#include <memory>
-
-// user include files
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Frameworkfwd.h"
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-
-#include "FWCore/ParameterSet/interface/FileInPath.h"
-#include "FWCore/Utilities/interface/InputTag.h" 
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-
-#include "DataFormats/Candidate/interface/Candidate.h"
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/Math/interface/LorentzVector.h"
-#include "DataFormats/PatCandidates/interface/MHT.h"
-#include "DataFormats/PatCandidates/interface/Jet.h"
-#include "DataFormats/PatCandidates/interface/Photon.h"
-#include "DataFormats/PatCandidates/interface/Tau.h"
-#include "DataFormats/PatCandidates/interface/Electron.h"
-#include "DataFormats/PatCandidates/interface/Muon.h"
-
-
-#include "RecoMET/METAlgorithms/interface/SigInputObj.h"
-#include "RecoMET/METAlgorithms/interface/SignAlgoResolutions.h"
-#include "RecoMET/METAlgorithms/interface/significanceAlgo.h"
-
-
-#include "TF1.h"
-#include "TMath.h"
-
-//
-// class declaration
-//
-
-namespace pat {
-  class PATMHTProducer : public edm::EDProducer {
-  public:
-    explicit PATMHTProducer(const edm::ParameterSet&);
-    ~PATMHTProducer();
-    
-  private:
-    virtual void beginJob() ;
-    virtual void beginRun(const edm::EventSetup&) ;
-    virtual void produce(edm::Event&, const edm::EventSetup&);
-    virtual void endJob() ;
-    
-    double getJets(edm::Event&, const edm::EventSetup&);
-    double getElectrons(edm::Event&, const edm::EventSetup&);
-    double getMuons(edm::Event&, const edm::EventSetup&);
-    void   getTowers(edm::Event&, const edm::EventSetup&);
-    
-    
-    // ----------member data ---------------------------
-    
-    double verbose_;
-    
-    // input tags.
-    edm::InputTag mhtLabel_;
-    edm::InputTag jetLabel_;
-    edm::InputTag eleLabel_;
-    edm::InputTag muoLabel_;
-    edm::InputTag tauLabel_;
-    edm::InputTag phoLabel_;
-  
-    std::vector<metsig::SigInputObj> physobjvector_ ;
-
-    double uncertaintyScaleFactor_; // scale factor for the uncertainty parameters.
-    bool    controlledUncertainty_; // use controlled uncertainty parameters.
-
- 
-    //--- test the uncertainty parameters ---//
-
-    class uncertaintyFunctions{
-    public:
-      TF1 *etUncertainty;
-      TF1 *phiUncertainty;
-    };
-
-    void setUncertaintyParameters();// fills the following uncertaintyFunctions objects:
-    uncertaintyFunctions ecalEBUncertainty;
-    uncertaintyFunctions ecalEEUncertainty;
-    uncertaintyFunctions hcalHBUncertainty;
-    uncertaintyFunctions hcalHEUncertainty;
-    uncertaintyFunctions hcalHOUncertainty;
-    uncertaintyFunctions hcalHFUncertainty;
-
-    uncertaintyFunctions jetUncertainty;
-    uncertaintyFunctions jetCorrUncertainty;
-    uncertaintyFunctions eleUncertainty;
-    uncertaintyFunctions muonUncertainty;
-    uncertaintyFunctions muonCorrUncertainty;
-
-    //--- tags and parameters ---//
-
-    bool useCaloTowers_;
-    bool useJets_;
-    bool useElectrons_;
-    bool useMuons_;
-    std::set<CaloTowerDetId> s_clusteredTowers; 
-
-    bool noHF_;
-
-    double jetPtMin_;
-    double jetEtaMax_;
-    double jetEMfracMax_;
-
-    double elePtMin_;
-    double eleEtaMax_;
-
-    double muonPtMin_;
-    double muonEtaMax_;
-    double muonTrackD0Max_;
-    double muonTrackDzMax_;
-    int muonNHitsMin_;
-    double muonDPtMax_;
-    double muonChiSqMax_;
-
-    //  double uncertaintyScaleFactor_; // scale factor for the uncertainty parameters.
-
-    double jetEtUncertaintyParameter0_ ; 
-    double jetEtUncertaintyParameter1_ ; 
-    double jetEtUncertaintyParameter2_ ; 
-
-    double jetPhiUncertaintyParameter0_ ; 
-    double jetPhiUncertaintyParameter1_ ; 
-    double jetPhiUncertaintyParameter2_ ; 
-
-    double eleEtUncertaintyParameter0_ ; 
-    double elePhiUncertaintyParameter0_ ; 
-
-    double muonEtUncertaintyParameter0_ ; 
-    double muonPhiUncertaintyParameter0_ ; 
-
-    edm::InputTag CaloJetAlgorithmTag_; 
-    edm::InputTag CorJetAlgorithmTag_;
-    std::string   JetCorrectionService_;
-    edm::InputTag MuonTag_;
-    edm::InputTag ElectronTag_;
-    edm::InputTag CaloTowerTag_;
-    std::string metCollectionLabel_;
-    std::string significanceLabel_;
-
-    //--- For Muon Calo Deposits ---//
-    //TrackDetectorAssociator   trackAssociator_; 
-    //TrackAssociatorParameters trackAssociatorParameters_;
-
-    double towerEtThreshold_ ; 
-    bool useHO_ ; 
-
-
-  };
-  //define this as a plug-in
-
-} //end of namespace
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATMuonProducer.cc b/PhysicsTools/PatAlgos/plugins/PATMuonProducer.cc
deleted file mode 100755
index 905febc..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATMuonProducer.cc
+++ /dev/null
@@ -1,646 +0,0 @@
-//
-// $Id: PATMuonProducer.cc,v 1.49.2.2 2012/09/21 15:49:27 vadler Exp $
-//
-
-#include "PhysicsTools/PatAlgos/plugins/PATMuonProducer.h"
-
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "FWCore/ParameterSet/interface/FileInPath.h"
-#include "FWCore/Utilities/interface/Exception.h"
-
-#include "DataFormats/MuonReco/interface/Muon.h"
-#include "DataFormats/MuonReco/interface/MuonFwd.h"
-#include "DataFormats/MuonReco/interface/MuonCocktails.h"
-
-#include "DataFormats/TrackReco/interface/TrackToTrackMap.h"
-
-#include "DataFormats/ParticleFlowCandidate/interface/IsolatedPFCandidateFwd.h"
-#include "DataFormats/ParticleFlowCandidate/interface/IsolatedPFCandidate.h"
-
-#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
-
-#include "DataFormats/Common/interface/Association.h"
-
-#include "DataFormats/BeamSpot/interface/BeamSpot.h"
-#include "DataFormats/VertexReco/interface/Vertex.h"
-
-
-#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
-#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
-
-#include "TrackingTools/TransientTrack/interface/TransientTrackBuilder.h"
-#include "TrackingTools/Records/interface/TransientTrackRecord.h"
-#include "TrackingTools/TransientTrack/interface/TransientTrack.h"
-#include "TrackingTools/IPTools/interface/IPTools.h"
-
-
-#include "TMath.h"
-
-#include <vector>
-#include <memory>
-
-
-using namespace pat;
-using namespace std;
-
-
-PATMuonProducer::PATMuonProducer(const edm::ParameterSet & iConfig) : useUserData_(iConfig.exists("userData")),
-  isolator_(iConfig.exists("userIsolation") ? iConfig.getParameter<edm::ParameterSet>("userIsolation") : edm::ParameterSet(), false)
-{
-  // input source
-  muonSrc_ = iConfig.getParameter<edm::InputTag>( "muonSource" );
-  // embedding of tracks
-  embedBestTrack_ = iConfig.getParameter<bool>( "embedMuonBestTrack" );
-  embedImprovedBestTrack_ = iConfig.getParameter<bool>( "embedImprovedMuonBestTrack" );
-  embedTrack_ = iConfig.getParameter<bool>( "embedTrack" );
-  embedCombinedMuon_ = iConfig.getParameter<bool>( "embedCombinedMuon"   );
-  embedStandAloneMuon_ = iConfig.getParameter<bool>( "embedStandAloneMuon" );
-  // embedding of muon MET correction information
-  embedCaloMETMuonCorrs_ = iConfig.getParameter<bool>("embedCaloMETMuonCorrs" );
-  embedTcMETMuonCorrs_ = iConfig.getParameter<bool>("embedTcMETMuonCorrs"   );
-  caloMETMuonCorrs_ = iConfig.getParameter<edm::InputTag>("caloMETMuonCorrs" );
-  tcMETMuonCorrs_ = iConfig.getParameter<edm::InputTag>("tcMETMuonCorrs"   );
-  // pflow specific configurables
-  useParticleFlow_ = iConfig.getParameter<bool>( "useParticleFlow" );
-  embedPFCandidate_ = iConfig.getParameter<bool>( "embedPFCandidate" );
-  pfMuonSrc_ = iConfig.getParameter<edm::InputTag>( "pfMuonSource" );
-  // embedding of tracks from TeV refit
-  embedPickyMuon_ = iConfig.getParameter<bool>( "embedPickyMuon" );
-  embedTpfmsMuon_ = iConfig.getParameter<bool>( "embedTpfmsMuon" );
-  embedDytMuon_ = iConfig.getParameter<bool>( "embedDytMuon" );
-  // Monte Carlo matching
-  addGenMatch_ = iConfig.getParameter<bool>( "addGenMatch" );
-  if(addGenMatch_){
-    embedGenMatch_ = iConfig.getParameter<bool>( "embedGenMatch" );
-    if(iConfig.existsAs<edm::InputTag>("genParticleMatch")){
-      genMatchSrc_.push_back(iConfig.getParameter<edm::InputTag>( "genParticleMatch" ));
-    } else {
-      genMatchSrc_ = iConfig.getParameter<std::vector<edm::InputTag> >( "genParticleMatch" );
-    }
-  }
-  // efficiencies
-  addEfficiencies_ = iConfig.getParameter<bool>("addEfficiencies");
-  if(addEfficiencies_){
-    efficiencyLoader_ = pat::helper::EfficiencyLoader(iConfig.getParameter<edm::ParameterSet>("efficiencies"));
-  }
-  // resolutions
-  addResolutions_ = iConfig.getParameter<bool>("addResolutions");
-  if (addResolutions_) {
-    resolutionLoader_ = pat::helper::KinResolutionsLoader(iConfig.getParameter<edm::ParameterSet>("resolutions"));
-  }
-  // read isoDeposit labels, for direct embedding
-  readIsolationLabels(iConfig, "isoDeposits", isoDepositLabels_);
-  // read isolation value labels, for direct embedding
-  readIsolationLabels(iConfig, "isolationValues", isolationValueLabels_);
-  // check to see if the user wants to add user data
-  if( useUserData_ ){
-    userDataHelper_ = PATUserDataHelper<Muon>(iConfig.getParameter<edm::ParameterSet>("userData"));
-  }
-  // embed high level selection variables
-  usePV_ = true;
-  embedHighLevelSelection_ = iConfig.getParameter<bool>("embedHighLevelSelection");
-  if ( embedHighLevelSelection_ ) {
-    beamLineSrc_ = iConfig.getParameter<edm::InputTag>("beamLineSrc");
-    usePV_ = iConfig.getParameter<bool>("usePV");
-    pvSrc_ = iConfig.getParameter<edm::InputTag>("pvSrc");
-  }
-  // produces vector of muons
-  produces<std::vector<Muon> >();
-}
-
-
-PATMuonProducer::~PATMuonProducer()
-{
-}
-
-void PATMuonProducer::produce(edm::Event & iEvent, const edm::EventSetup & iSetup)
-{
-  // switch off embedding (in unschedules mode)
-  if (iEvent.isRealData()){
-    addGenMatch_   = false;
-    embedGenMatch_ = false;
-  }
-
-  edm::Handle<edm::View<reco::Muon> > muons;
-  iEvent.getByLabel(muonSrc_, muons);
-
-  // get the ESHandle for the transient track builder,
-  // if needed for high level selection embedding
-  edm::ESHandle<TransientTrackBuilder> trackBuilder;
-
-  if(isolator_.enabled()) isolator_.beginEvent(iEvent,iSetup);
-  if(efficiencyLoader_.enabled()) efficiencyLoader_.newEvent(iEvent);
-  if(resolutionLoader_.enabled()) resolutionLoader_.newEvent(iEvent, iSetup);
-
-  IsoDepositMaps deposits(isoDepositLabels_.size());
-  for (size_t j = 0; j<isoDepositLabels_.size(); ++j) {
-    iEvent.getByLabel(isoDepositLabels_[j].second, deposits[j]);
-  }
-
-  IsolationValueMaps isolationValues(isolationValueLabels_.size());
-  for (size_t j = 0; j<isolationValueLabels_.size(); ++j) {
-    iEvent.getByLabel(isolationValueLabels_[j].second, isolationValues[j]);
-  }
-
-  // prepare the MC matching
-  GenAssociations  genMatches(genMatchSrc_.size());
-  if (addGenMatch_) {
-    for (size_t j = 0, nd = genMatchSrc_.size(); j < nd; ++j) {
-      iEvent.getByLabel(genMatchSrc_[j], genMatches[j]);
-    }
-  }
-
-  // prepare the high level selection: needs beamline
-  // OR primary vertex, depending on user selection
-  reco::TrackBase::Point beamPoint(0,0,0);
-  reco::Vertex primaryVertex;
-  reco::BeamSpot beamSpot;
-  bool beamSpotIsValid = false;
-  bool primaryVertexIsValid = false;
-  if ( embedHighLevelSelection_ ) {
-    // get the beamspot
-    edm::Handle<reco::BeamSpot> beamSpotHandle;
-    iEvent.getByLabel(beamLineSrc_, beamSpotHandle);
-
-    // get the primary vertex
-    edm::Handle< std::vector<reco::Vertex> > pvHandle;
-    iEvent.getByLabel( pvSrc_, pvHandle );
-
-    if( beamSpotHandle.isValid() ){
-      beamSpot = *beamSpotHandle;
-      beamSpotIsValid = true;
-    } else{
-      edm::LogError("DataNotAvailable")
-	<< "No beam spot available from EventSetup, not adding high level selection \n";
-    }
-    beamPoint = reco::TrackBase::Point ( beamSpot.x0(), beamSpot.y0(), beamSpot.z0() );
-    if( pvHandle.isValid() && !pvHandle->empty() ) {
-      primaryVertex = pvHandle->at(0);
-      primaryVertexIsValid = true;
-    } else {
-      edm::LogError("DataNotAvailable")
-	<< "No primary vertex available from EventSetup, not adding high level selection \n";
-    }
-    // this is needed by the IPTools methods from the tracking group
-    iSetup.get<TransientTrackRecord>().get("TransientTrackBuilder", trackBuilder);
-  }
-
-  // this will be the new object collection
-  std::vector<Muon> * patMuons = new std::vector<Muon>();
-
-  if( useParticleFlow_ ){
-    // get the PFCandidates of type muons
-    edm::Handle< reco::PFCandidateCollection >  pfMuons;
-    iEvent.getByLabel(pfMuonSrc_, pfMuons);
-
-    unsigned index=0;
-    for( reco::PFCandidateConstIterator i = pfMuons->begin(); i != pfMuons->end(); ++i, ++index) {
-      const reco::PFCandidate& pfmu = *i;
-      //const reco::IsolaPFCandidate& pfmu = *i;
-      const reco::MuonRef& muonRef = pfmu.muonRef();
-      assert( muonRef.isNonnull() );
-
-      MuonBaseRef muonBaseRef(muonRef);
-      Muon aMuon(muonBaseRef);
-
-      if ( useUserData_ ) {
-	userDataHelper_.add( aMuon, iEvent, iSetup );
-      }
-
-      // embed high level selection
-      if ( embedHighLevelSelection_ ) {
-	// get the tracks
-	reco::TrackRef innerTrack = muonBaseRef->innerTrack();
-	reco::TrackRef globalTrack= muonBaseRef->globalTrack();
-	reco::TrackRef bestTrack  = muon::muonBestTrack(*muonBaseRef, reco::defaultTuneP).first;
-
-	// Make sure the collection it points to is there
-	if ( bestTrack.isNonnull() && bestTrack.isAvailable() ) {
-	  unsigned int nhits = bestTrack->numberOfValidHits(); // ????
-	  aMuon.setNumberOfValidHits( nhits );
-
-	  reco::TransientTrack tt = trackBuilder->build(bestTrack);
-	  embedHighLevel( aMuon,
-			  bestTrack,
-			  tt,
-			  primaryVertex,
-			  primaryVertexIsValid,
-			  beamSpot,
-			  beamSpotIsValid );
-
-	  // Correct to PV, or beam spot
-	  if ( !usePV_ ) {
-	    double corr_d0 = -1.0 * bestTrack->dxy( beamPoint );
-	    aMuon.setDB( corr_d0, -1.0 );
-	  } else {
-	    std::pair<bool,Measurement1D> result = IPTools::absoluteTransverseImpactParameter(tt, primaryVertex);
-	    double d0_corr = result.second.value();
-	    double d0_err = result.second.error();
-	    aMuon.setDB( d0_corr, d0_err );
-	  }
-	}
-
-	if ( globalTrack.isNonnull() && globalTrack.isAvailable() ) {
-	  double norm_chi2 = globalTrack->chi2() / globalTrack->ndof();
-	  aMuon.setNormChi2( norm_chi2 );
-	}
-      }
-      reco::PFCandidateRef pfRef(pfMuons,index);
-      //reco::PFCandidatePtr ptrToMother(pfMuons,index);
-      reco::CandidateBaseRef pfBaseRef( pfRef );
-
-      aMuon.setPFCandidateRef( pfRef  );
-      if( embedPFCandidate_ ) aMuon.embedPFCandidate();
-      fillMuon( aMuon, muonBaseRef, pfBaseRef, genMatches, deposits, isolationValues );
-      patMuons->push_back(aMuon);
-    }
-  }
-  else {
-    edm::Handle<edm::View<reco::Muon> > muons;
-    iEvent.getByLabel(muonSrc_, muons);
-
-    // embedding of muon MET corrections
-    edm::Handle<edm::ValueMap<reco::MuonMETCorrectionData> > caloMETMuonCorrs;
-    //edm::ValueMap<reco::MuonMETCorrectionData> caloMETmuCorValueMap;
-    if(embedCaloMETMuonCorrs_){
-      iEvent.getByLabel(caloMETMuonCorrs_, caloMETMuonCorrs);
-      //caloMETmuCorValueMap  = *caloMETmuCorValueMap_h;
-    }
-    edm::Handle<edm::ValueMap<reco::MuonMETCorrectionData> > tcMETMuonCorrs;
-    //edm::ValueMap<reco::MuonMETCorrectionData> tcMETmuCorValueMap;
-    if(embedTcMETMuonCorrs_) {
-      iEvent.getByLabel(tcMETMuonCorrs_, tcMETMuonCorrs);
-      //tcMETmuCorValueMap  = *tcMETmuCorValueMap_h;
-    }
-    for (edm::View<reco::Muon>::const_iterator itMuon = muons->begin(); itMuon != muons->end(); ++itMuon) {
-      // construct the Muon from the ref -> save ref to original object
-      unsigned int idx = itMuon - muons->begin();
-      MuonBaseRef muonRef = muons->refAt(idx);
-      reco::CandidateBaseRef muonBaseRef( muonRef );
-
-      Muon aMuon(muonRef);
-      fillMuon( aMuon, muonRef, muonBaseRef, genMatches, deposits, isolationValues);
-
-      // Isolation
-      if (isolator_.enabled()) {
-	//reco::CandidatePtr mother =  ptrToMother->sourceCandidatePtr(0);
-	isolator_.fill(*muons, idx, isolatorTmpStorage_);
-	typedef pat::helper::MultiIsolator::IsolationValuePairs IsolationValuePairs;
-	// better to loop backwards, so the vector is resized less times
-	for (IsolationValuePairs::const_reverse_iterator it = isolatorTmpStorage_.rbegin(), ed = isolatorTmpStorage_.rend(); it != ed; ++it) {
-	  aMuon.setIsolation(it->first, it->second);
-	}
-      }
-
-      //       for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-      // 	aMuon.setIsoDeposit(isoDepositLabels_[j].first,
-      // 			    (*deposits[j])[muonRef]);
-      //       }
-
-      // add sel to selected
-      edm::Ptr<reco::Muon> muonsPtr = muons->ptrAt(idx);
-      if ( useUserData_ ) {
-	userDataHelper_.add( aMuon, iEvent, iSetup );
-      }
-
-      // embed high level selection
-      if ( embedHighLevelSelection_ ) {
-	// get the tracks
-	reco::TrackRef innerTrack = itMuon->innerTrack();
-	reco::TrackRef globalTrack= itMuon->globalTrack();
-	reco::TrackRef bestTrack  = muon::muonBestTrack(*itMuon, reco::defaultTuneP).first;
-
-	// Make sure the collection it points to is there
-	if ( bestTrack.isNonnull() && bestTrack.isAvailable() ) {
-	  unsigned int nhits = bestTrack->numberOfValidHits(); // ????
-	  aMuon.setNumberOfValidHits( nhits );
-
-	  reco::TransientTrack tt = trackBuilder->build(bestTrack);
-	  embedHighLevel( aMuon,
-			  bestTrack,
-			  tt,
-			  primaryVertex,
-			  primaryVertexIsValid,
-			  beamSpot,
-			  beamSpotIsValid );
-
-	  // Correct to PV, or beam spot
-	  if ( !usePV_ ) {
-	    double corr_d0 = -1.0 * bestTrack->dxy( beamPoint );
-	    aMuon.setDB( corr_d0, -1.0 );
-	  } else {
-	    std::pair<bool,Measurement1D> result = IPTools::absoluteTransverseImpactParameter(tt, primaryVertex);
-	    double d0_corr = result.second.value();
-	    double d0_err = result.second.error();
-	    aMuon.setDB( d0_corr, d0_err );
-	  }
-	}
-
-	if ( globalTrack.isNonnull() && globalTrack.isAvailable() ) {
-	  double norm_chi2 = globalTrack->chi2() / globalTrack->ndof();
-	  aMuon.setNormChi2( norm_chi2 );
-	}
-      }
-
-      // embed MET muon corrections
-      if( embedCaloMETMuonCorrs_ ) aMuon.embedCaloMETMuonCorrs((*caloMETMuonCorrs)[muonRef]);
-      if( embedTcMETMuonCorrs_ ) aMuon.embedTcMETMuonCorrs((*tcMETMuonCorrs  )[muonRef]);
-
-      patMuons->push_back(aMuon);
-    }
-  }
-
-  // sort muons in pt
-  std::sort(patMuons->begin(), patMuons->end(), pTComparator_);
-
-  // put genEvt object in Event
-  std::auto_ptr<std::vector<Muon> > ptr(patMuons);
-  iEvent.put(ptr);
-
-  if (isolator_.enabled()) isolator_.endEvent();
-}
-
-
-void PATMuonProducer::fillMuon( Muon& aMuon, const MuonBaseRef& muonRef, const reco::CandidateBaseRef& baseRef, const GenAssociations& genMatches, const IsoDepositMaps& deposits, const IsolationValueMaps& isolationValues ) const
-{
-  // in the particle flow algorithm,
-  // the muon momentum is recomputed.
-  // the new value is stored as the momentum of the
-  // resulting PFCandidate of type Muon, and choosen
-  // as the pat::Muon momentum
-  if (useParticleFlow_)
-    aMuon.setP4( aMuon.pfCandidateRef()->p4() );
-  if (embedBestTrack_)         aMuon.embedMuonBestTrack();
-  reco::Muon::MuonTrackTypePair newBestTrack = muon::muonBestTrack(aMuon, reco::defaultTuneP);
-  aMuon.setBestTrack(newBestTrack.second);
-  if (embedImprovedBestTrack_) aMuon.embedImprovedMuonBestTrack();
-  reco::Muon::MuonTrackTypePair newImprovedBestTrack = muon::muonBestTrack(aMuon, reco::improvedTuneP);
-  aMuon.setImprovedBestTrack(newImprovedBestTrack.second);
-  if (embedTrack_)          aMuon.embedTrack();
-  if (embedStandAloneMuon_) aMuon.embedStandAloneMuon();
-  if (embedCombinedMuon_)   aMuon.embedCombinedMuon();
-
-  // embed the TeV refit track refs (only available for globalMuons)
-  if (aMuon.isGlobalMuon()) {
-    if (embedPickyMuon_ && aMuon.isAValidMuonTrack(reco::Muon::Picky))
-      aMuon.embedPickyMuon();
-    if (embedTpfmsMuon_ && aMuon.isAValidMuonTrack(reco::Muon::TPFMS))
-      aMuon.embedTpfmsMuon();
-    if (embedDytMuon_ && aMuon.isAValidMuonTrack(reco::Muon::DYT))
-      aMuon.embedDytMuon();
-  }
-
-  // store the match to the generated final state muons
-  if (addGenMatch_) {
-    for(size_t i = 0, n = genMatches.size(); i < n; ++i) {
-      reco::GenParticleRef genMuon = (*genMatches[i])[baseRef];
-      aMuon.addGenParticleRef(genMuon);
-    }
-    if (embedGenMatch_) aMuon.embedGenParticle();
-  }
-  if (efficiencyLoader_.enabled()) {
-    efficiencyLoader_.setEfficiencies( aMuon, muonRef );
-  }
-
-  for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-    if(useParticleFlow_) {
-      if (deposits[j]->contains(baseRef.id())) {
-	aMuon.setIsoDeposit(isoDepositLabels_[j].first, (*deposits[j])[baseRef]);
-      } else if (deposits[j]->contains(muonRef.id())){
-	aMuon.setIsoDeposit(isoDepositLabels_[j].first, (*deposits[j])[muonRef]);
-      } else {
-	reco::CandidatePtr source = aMuon.pfCandidateRef()->sourceCandidatePtr(0);
-	aMuon.setIsoDeposit(isoDepositLabels_[j].first, (*deposits[j])[source]);
-      }
-    }
-    else{
-      aMuon.setIsoDeposit(isoDepositLabels_[j].first, (*deposits[j])[muonRef]);
-    }
-  }
-
-  for (size_t j = 0; j<isolationValues.size(); ++j) {
-    if(useParticleFlow_) {
-      if (isolationValues[j]->contains(baseRef.id())) {
-	aMuon.setIsolation(isolationValueLabels_[j].first, (*isolationValues[j])[baseRef]);
-      } else if (isolationValues[j]->contains(muonRef.id())) {
-	aMuon.setIsolation(isolationValueLabels_[j].first, (*isolationValues[j])[muonRef]);
-      } else {
-	reco::CandidatePtr source = aMuon.pfCandidateRef()->sourceCandidatePtr(0);
-	aMuon.setIsolation(isolationValueLabels_[j].first, (*isolationValues[j])[source]);
-      }
-    }
-    else{
-      aMuon.setIsolation(isolationValueLabels_[j].first, (*isolationValues[j])[muonRef]);
-    }
-  }
-
-  if (resolutionLoader_.enabled()) {
-    resolutionLoader_.setResolutions(aMuon);
-  }
-}
-
-// ParameterSet description for module
-void PATMuonProducer::fillDescriptions(edm::ConfigurationDescriptions & descriptions)
-{
-  edm::ParameterSetDescription iDesc;
-  iDesc.setComment("PAT muon producer module");
-
-  // input source
-  iDesc.add<edm::InputTag>("muonSource", edm::InputTag("no default"))->setComment("input collection");
-
-  // embedding
-  iDesc.add<bool>("embedMuonBestTrack", true)->setComment("embed muon best track");
-  iDesc.add<bool>("embedImprovedMuonBestTrack", true)->setComment("embed muon best track, new tuneP (only 53X)");
-  iDesc.add<bool>("embedTrack", true)->setComment("embed external track");
-  iDesc.add<bool>("embedStandAloneMuon", true)->setComment("embed external stand-alone muon");
-  iDesc.add<bool>("embedCombinedMuon", false)->setComment("embed external combined muon");
-  iDesc.add<bool>("embedPickyMuon", false)->setComment("embed external picky track");
-  iDesc.add<bool>("embedTpfmsMuon", false)->setComment("embed external tpfms track");
-  iDesc.add<bool>("embedDytMuon", false)->setComment("embed external dyt track ");
-
-  // embedding of MET muon corrections
-  iDesc.add<bool>("embedCaloMETMuonCorrs", true)->setComment("whether to add MET muon correction for caloMET or not");
-  iDesc.add<edm::InputTag>("caloMETMuonCorrs", edm::InputTag("muonMETValueMapProducer"  , "muCorrData"))->setComment("source of MET muon corrections for caloMET");
-  iDesc.add<bool>("embedTcMETMuonCorrs", true)->setComment("whether to add MET muon correction for tcMET or not");
-  iDesc.add<edm::InputTag>("tcMETMuonCorrs", edm::InputTag("muonTCMETValueMapProducer"  , "muCorrData"))->setComment("source of MET muon corrections for tcMET");
-
-  // pf specific parameters
-  iDesc.add<edm::InputTag>("pfMuonSource", edm::InputTag("pfMuons"))->setComment("particle flow input collection");
-  iDesc.add<bool>("useParticleFlow", false)->setComment("whether to use particle flow or not");
-  iDesc.add<bool>("embedPFCandidate", false)->setComment("embed external particle flow object");
-
-  // MC matching configurables
-  iDesc.add<bool>("addGenMatch", true)->setComment("add MC matching");
-  iDesc.add<bool>("embedGenMatch", false)->setComment("embed MC matched MC information");
-  std::vector<edm::InputTag> emptySourceVector;
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("genParticleMatch", edm::InputTag(), true) xor
-                 edm::ParameterDescription<std::vector<edm::InputTag> >("genParticleMatch", emptySourceVector, true)
-		 )->setComment("input with MC match information");
-
-  pat::helper::KinResolutionsLoader::fillDescription(iDesc);
-
-  // IsoDeposit configurables
-  edm::ParameterSetDescription isoDepositsPSet;
-  isoDepositsPSet.addOptional<edm::InputTag>("tracker");
-  isoDepositsPSet.addOptional<edm::InputTag>("ecal");
-  isoDepositsPSet.addOptional<edm::InputTag>("hcal");
-  isoDepositsPSet.addOptional<edm::InputTag>("particle");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfChargedHadrons");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfChargedAll");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfPUChargedHadrons");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfNeutralHadrons");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfPhotons");
-  isoDepositsPSet.addOptional<std::vector<edm::InputTag> >("user");
-  iDesc.addOptional("isoDeposits", isoDepositsPSet);
-
-  // isolation values configurables
-  edm::ParameterSetDescription isolationValuesPSet;
-  isolationValuesPSet.addOptional<edm::InputTag>("tracker");
-  isolationValuesPSet.addOptional<edm::InputTag>("ecal");
-  isolationValuesPSet.addOptional<edm::InputTag>("hcal");
-  isolationValuesPSet.addOptional<edm::InputTag>("particle");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfChargedHadrons");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfChargedAll");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfPUChargedHadrons");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfNeutralHadrons");
-  isolationValuesPSet.addOptional<edm::InputTag>("pfPhotons");
-  iDesc.addOptional("isolationValues", isolationValuesPSet);
-
-  // Efficiency configurables
-  edm::ParameterSetDescription efficienciesPSet;
-  efficienciesPSet.setAllowAnything(); // TODO: the pat helper needs to implement a description.
-  iDesc.add("efficiencies", efficienciesPSet);
-  iDesc.add<bool>("addEfficiencies", false);
-
-  // Check to see if the user wants to add user data
-  edm::ParameterSetDescription userDataPSet;
-  PATUserDataHelper<Muon>::fillDescription(userDataPSet);
-  iDesc.addOptional("userData", userDataPSet);
-
-  edm::ParameterSetDescription isolationPSet;
-  isolationPSet.setAllowAnything(); // TODO: the pat helper needs to implement a description.
-  iDesc.add("userIsolation", isolationPSet);
-
-  iDesc.add<bool>("embedHighLevelSelection", true)->setComment("embed high level selection");
-  edm::ParameterSetDescription highLevelPSet;
-  highLevelPSet.setAllowAnything();
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("beamLineSrc", edm::InputTag(), true)
-                 )->setComment("input with high level selection");
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("pvSrc", edm::InputTag(), true)
-                 )->setComment("input with high level selection");
-  iDesc.addNode( edm::ParameterDescription<bool>("usePV", bool(), true)
-                 )->setComment("input with high level selection, use primary vertex (true) or beam line (false)");
-
-  //descriptions.add("PATMuonProducer", iDesc);
-}
-
-
-void PATMuonProducer::readIsolationLabels( const edm::ParameterSet & iConfig, const char* psetName, IsolationLabels& labels)
-{
-  labels.clear();
-
-  if (iConfig.exists( psetName )) {
-    edm::ParameterSet depconf = iConfig.getParameter<edm::ParameterSet>(psetName);
-
-    if (depconf.exists("tracker")) labels.push_back(std::make_pair(pat::TrackIso, depconf.getParameter<edm::InputTag>("tracker")));
-    if (depconf.exists("ecal"))    labels.push_back(std::make_pair(pat::EcalIso, depconf.getParameter<edm::InputTag>("ecal")));
-    if (depconf.exists("hcal"))    labels.push_back(std::make_pair(pat::HcalIso, depconf.getParameter<edm::InputTag>("hcal")));
-    if (depconf.exists("pfAllParticles"))  {
-      labels.push_back(std::make_pair(pat::PfAllParticleIso, depconf.getParameter<edm::InputTag>("pfAllParticles")));
-    }
-    if (depconf.exists("pfChargedHadrons"))  {
-      labels.push_back(std::make_pair(pat::PfChargedHadronIso, depconf.getParameter<edm::InputTag>("pfChargedHadrons")));
-    }
-    if (depconf.exists("pfChargedAll"))  {
-      labels.push_back(std::make_pair(pat::PfChargedAllIso, depconf.getParameter<edm::InputTag>("pfChargedAll")));
-    }
-    if (depconf.exists("pfPUChargedHadrons"))  {
-      labels.push_back(std::make_pair(pat::PfPUChargedHadronIso, depconf.getParameter<edm::InputTag>("pfPUChargedHadrons")));
-    }
-    if (depconf.exists("pfNeutralHadrons"))  {
-      labels.push_back(std::make_pair(pat::PfNeutralHadronIso, depconf.getParameter<edm::InputTag>("pfNeutralHadrons")));
-    }
-    if (depconf.exists("pfPhotons")) {
-      labels.push_back(std::make_pair(pat::PfGammaIso, depconf.getParameter<edm::InputTag>("pfPhotons")));
-    }
-    if (depconf.exists("user")) {
-      std::vector<edm::InputTag> userdeps = depconf.getParameter<std::vector<edm::InputTag> >("user");
-      std::vector<edm::InputTag>::const_iterator it = userdeps.begin(), ed = userdeps.end();
-      int key = UserBaseIso;
-      for ( ; it != ed; ++it, ++key) {
-	labels.push_back(std::make_pair(IsolationKeys(key), *it));
-      }
-    }
-  }
-}
-
-
-
-// embed various impact parameters with errors
-// embed high level selection
-void PATMuonProducer::embedHighLevel( pat::Muon & aMuon,
-				      reco::TrackRef track,
-				      reco::TransientTrack & tt,
-				      reco::Vertex & primaryVertex,
-				      bool primaryVertexIsValid,
-				      reco::BeamSpot & beamspot,
-				      bool beamspotIsValid
-				      )
-{
-  // Correct to PV
-
-  // PV2D
-  std::pair<bool,Measurement1D> result =
-    IPTools::signedTransverseImpactParameter(tt,
-					     GlobalVector(track->px(),
-							  track->py(),
-							  track->pz()),
-					     primaryVertex);
-  double d0_corr = result.second.value();
-  double d0_err = primaryVertexIsValid ? result.second.error() : -1.0;
-  aMuon.setDB( d0_corr, d0_err, pat::Muon::PV2D);
-
-
-  // PV3D
-  result =
-    IPTools::signedImpactParameter3D(tt,
-				     GlobalVector(track->px(),
-						  track->py(),
-						  track->pz()),
-				     primaryVertex);
-  d0_corr = result.second.value();
-  d0_err = primaryVertexIsValid ? result.second.error() : -1.0;
-  aMuon.setDB( d0_corr, d0_err, pat::Muon::PV3D);
-
-
-  // Correct to beam spot
-  // make a fake vertex out of beam spot
-  reco::Vertex vBeamspot(beamspot.position(), beamspot.rotatedCovariance3D());
-
-  // BS2D
-  result =
-    IPTools::signedTransverseImpactParameter(tt,
-					     GlobalVector(track->px(),
-							  track->py(),
-							  track->pz()),
-					     vBeamspot);
-  d0_corr = result.second.value();
-  d0_err = beamspotIsValid ? result.second.error() : -1.0;
-  aMuon.setDB( d0_corr, d0_err, pat::Muon::BS2D);
-
-    // BS3D
-  result =
-    IPTools::signedImpactParameter3D(tt,
-				     GlobalVector(track->px(),
-						  track->py(),
-						    track->pz()),
-				     vBeamspot);
-  d0_corr = result.second.value();
-  d0_err = beamspotIsValid ? result.second.error() : -1.0;
-  aMuon.setDB( d0_corr, d0_err, pat::Muon::BS3D);
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATMuonProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATMuonProducer.h b/PhysicsTools/PatAlgos/plugins/PATMuonProducer.h
deleted file mode 100644
index 90ff7b1..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATMuonProducer.h
+++ /dev/null
@@ -1,159 +0,0 @@
-//
-// $Id: PATMuonProducer.h,v 1.28.6.1 2012/09/04 17:31:56 vadler Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATMuonProducer_h
-#define PhysicsTools_PatAlgos_PATMuonProducer_h
-
-/**
-  \class    pat::PATMuonProducer PATMuonProducer.h "PhysicsTools/PatAlgos/interface/PATMuonProducer.h"
-  \brief    Produces pat::Muon's
-
-   The PATMuonProducer produces analysis-level pat::Muon's starting from
-   a collection of objects of reco::Muon.
-
-  \author   Steven Lowette, Roger Wolf
-  \version  $Id: PATMuonProducer.h,v 1.28.6.1 2012/09/04 17:31:56 vadler Exp $
-*/
-
-#include <string>
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "DataFormats/PatCandidates/interface/Muon.h"
-#include "CommonTools/Utils/interface/PtComparator.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-#include "TrackingTools/IPTools/interface/IPTools.h"
-#include "PhysicsTools/PatAlgos/interface/MultiIsolator.h"
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-
-#include "DataFormats/PatCandidates/interface/UserData.h"
-#include "PhysicsTools/PatAlgos/interface/PATUserDataHelper.h"
-#include "TrackingTools/TransientTrack/interface/TransientTrackBuilder.h"
-
-
-namespace pat {
-  /// foward declarations
-  class TrackerIsolationPt;
-  class CaloIsolationEnergy;
-
-  /// class definition
-  class PATMuonProducer : public edm::EDProducer {
-    
-  public:
-    /// default constructir
-    explicit PATMuonProducer(const edm::ParameterSet & iConfig);
-    /// default destructur
-    ~PATMuonProducer();
-    /// everything that needs to be done during the event loop
-    virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-    /// description of config file parameters
-    static void fillDescriptions(edm::ConfigurationDescriptions & descriptions);
-
-  private:
-    /// typedefs for convenience
-    typedef edm::RefToBase<reco::Muon> MuonBaseRef;
-    typedef std::vector<edm::Handle<edm::Association<reco::GenParticleCollection> > > GenAssociations;
-    typedef std::vector< edm::Handle< edm::ValueMap<IsoDeposit> > > IsoDepositMaps;
-    typedef std::vector< edm::Handle< edm::ValueMap<double> > > IsolationValueMaps;
-    typedef std::pair<pat::IsolationKeys,edm::InputTag> IsolationLabel;
-    typedef std::vector<IsolationLabel> IsolationLabels;
-
-
-    /// common muon filling, for both the standard and PF2PAT case
-    void fillMuon( Muon& aMuon, const MuonBaseRef& muonRef, const reco::CandidateBaseRef& baseRef, const GenAssociations& genMatches, const IsoDepositMaps& deposits, const IsolationValueMaps& isolationValues) const;
-    /// fill label vector from the contents of the parameter set, 
-    /// for the embedding of isoDeposits or userIsolation values
-    void readIsolationLabels( const edm::ParameterSet & iConfig, const char* psetName, IsolationLabels& labels); 
-
-
-    // embed various impact parameters with errors
-    // embed high level selection
-    void embedHighLevel( pat::Muon & aMuon,
-			 reco::TrackRef track,
-			 reco::TransientTrack & tt,
-			 reco::Vertex & primaryVertex,
-			 bool primaryVertexIsValid,
-			 reco::BeamSpot & beamspot,
-			 bool beamspotIsValid );
-
-    
-  private:
-    /// input source
-    edm::InputTag muonSrc_;
-
-    /// embed the track from best muon measurement
-    bool embedBestTrack_;
-    /// embed the track from best muon measurement, new tuneP, 53X option only
-    bool embedImprovedBestTrack_;
-    /// embed the track from inner tracker into the muon
-    bool embedTrack_;
-    /// embed track from muon system into the muon
-    bool embedStandAloneMuon_;
-    /// embed track of the combined fit into the muon
-    bool embedCombinedMuon_;
-    /// embed muon MET correction info for caloMET into the muon
-    bool embedCaloMETMuonCorrs_;
-    /// source of caloMET muon corrections
-    edm::InputTag caloMETMuonCorrs_;
-    /// embed muon MET correction info for tcMET into the muon
-    bool embedTcMETMuonCorrs_;
-    /// source of tcMET muon corrections
-    edm::InputTag tcMETMuonCorrs_;
-    /// embed track from picky muon fit into the muon
-    bool embedPickyMuon_;
-    /// embed track from tpfms muon fit into the muon
-    bool embedTpfmsMuon_;
-    /// embed track from DYT muon fit into the muon
-    bool embedDytMuon_;
-    /// add generator match information    
-    bool addGenMatch_;
-    /// input tags for generator match information
-    std::vector<edm::InputTag> genMatchSrc_;
-    /// embed the gen match information into the muon
-    bool embedGenMatch_;
-    /// add resolutions to the muon (this will be data members of th muon even w/o embedding)
-    bool addResolutions_;
-    /// helper class to add resolutions to the muon
-    pat::helper::KinResolutionsLoader resolutionLoader_;    
-    /// switch to use particle flow (PF2PAT) or not
-    bool useParticleFlow_;    
-    /// input source pfCandidates that will be to be transformed into pat::Muons, when using PF2PAT
-    edm::InputTag pfMuonSrc_;
-    /// embed pfCandidates into the muon
-    bool embedPFCandidate_;
-    /// embed high level selection variables
-    bool embedHighLevelSelection_;
-    /// input source of the primary vertex/beamspot
-    edm::InputTag beamLineSrc_;
-    /// use the primary vertex or the beamspot
-    bool usePV_;
-    /// input source of the primary vertex
-    edm::InputTag pvSrc_;
-    /// input source for isoDeposits
-    IsolationLabels isoDepositLabels_;
-    /// input source isolation value maps
-    IsolationLabels isolationValueLabels_;
-    /// add efficiencies to the muon (this will be data members of th muon even w/o embedding)
-    bool addEfficiencies_;    
-    /// add user data to the muon (this will be data members of th muon even w/o embedding)
-    bool useUserData_;
-
-    /// --- tools ---
-    /// comparator for pt ordering
-    GreaterByPt<Muon> pTComparator_;
-    /// helper class to add userdefined isolation values to the muon
-    pat::helper::MultiIsolator isolator_; 
-    /// isolation value pair for temporary storage before being folded into the muon 
-    pat::helper::MultiIsolator::IsolationValuePairs isolatorTmpStorage_;
-    /// helper class to add efficiencies to the muon
-    pat::helper::EfficiencyLoader efficiencyLoader_;
-    /// helper class to add userData to the muon
-    pat::PATUserDataHelper<pat::Muon> userDataHelper_;    
-  };
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATObjectFilter.cc b/PhysicsTools/PatAlgos/plugins/PATObjectFilter.cc
deleted file mode 100755
index 41a71a2..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATObjectFilter.cc
+++ /dev/null
@@ -1,6 +0,0 @@
-#include "FWCore/Framework/interface/MakerMacros.h"
-#include "PhysicsTools/PatAlgos/plugins/PATObjectFilter.h"
-
-using namespace pat;
-
-DEFINE_FWK_MODULE(PATCandViewCountFilter);
diff --git a/PhysicsTools/PatAlgos/plugins/PATObjectFilter.h b/PhysicsTools/PatAlgos/plugins/PATObjectFilter.h
deleted file mode 100644
index 2ddf69db..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATObjectFilter.h
+++ /dev/null
@@ -1,24 +0,0 @@
-//
-// $Id: PATObjectFilter.h,v 1.7 2010/07/22 14:18:11 srappocc Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATObjectFilter_h
-#define PhysicsTools_PatAlgos_PATObjectFilter_h
-
-#include "CommonTools/UtilAlgos/interface/AnySelector.h"
-#include "CommonTools/UtilAlgos/interface/ObjectCountFilter.h"
-#include "CommonTools/UtilAlgos/interface/MinNumberSelector.h"
-#include "CommonTools/UtilAlgos/interface/MaxNumberSelector.h"
-#include "CommonTools/UtilAlgos/interface/AndSelector.h"
-
-#include "DataFormats/Candidate/interface/Candidate.h"
-#include "DataFormats/Common/interface/View.h"
-
-namespace pat {
-
-  typedef ObjectCountFilter<edm::View<reco::Candidate>, AnySelector, AndSelector<MinNumberSelector, MaxNumberSelector> >::type PATCandViewCountFilter;
-
-}
-
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATObjectSelector.cc b/PhysicsTools/PatAlgos/plugins/PATObjectSelector.cc
deleted file mode 100755
index c9a656b..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATObjectSelector.cc
+++ /dev/null
@@ -1,28 +0,0 @@
-#include "FWCore/Framework/interface/MakerMacros.h"
-#include "PhysicsTools/PatAlgos/plugins/PATObjectSelector.h"
-
-using namespace pat;
-
-DEFINE_FWK_MODULE(PATElectronSelector);
-DEFINE_FWK_MODULE(PATMuonSelector);
-DEFINE_FWK_MODULE(PATTauSelector);
-DEFINE_FWK_MODULE(PATPhotonSelector);
-DEFINE_FWK_MODULE(PATJetSelector);
-DEFINE_FWK_MODULE(PATMETSelector);
-DEFINE_FWK_MODULE(PATPFParticleSelector);
-DEFINE_FWK_MODULE(PATCompositeCandidateSelector);
-DEFINE_FWK_MODULE(PATTriggerObjectStandAloneSelector);
-DEFINE_FWK_MODULE(PATGenericParticleSelector);
-
-
-DEFINE_FWK_MODULE(PATElectronRefSelector);
-DEFINE_FWK_MODULE(PATMuonRefSelector);
-DEFINE_FWK_MODULE(PATTauRefSelector);
-DEFINE_FWK_MODULE(PATPhotonRefSelector);
-DEFINE_FWK_MODULE(PATJetRefSelector);
-DEFINE_FWK_MODULE(PATMETRefSelector);
-DEFINE_FWK_MODULE(PATPFParticleRefSelector);
-DEFINE_FWK_MODULE(PATGenericParticleRefSelector);
-DEFINE_FWK_MODULE(PATCompositeCandidateRefSelector);
-
-
diff --git a/PhysicsTools/PatAlgos/plugins/PATObjectSelector.h b/PhysicsTools/PatAlgos/plugins/PATObjectSelector.h
deleted file mode 100644
index 0261f18..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATObjectSelector.h
+++ /dev/null
@@ -1,125 +0,0 @@
-//
-// $Id: PATObjectSelector.h,v 1.7 2010/06/17 10:08:39 gpetrucc Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATObjectSelector_h
-#define PhysicsTools_PatAlgos_PATObjectSelector_h
-
-#include "DataFormats/Common/interface/RefVector.h"
-
-#include "CommonTools/UtilAlgos/interface/StringCutObjectSelector.h"
-#include "CommonTools/UtilAlgos/interface/SingleObjectSelector.h"
-#include "CommonTools/UtilAlgos/interface/ObjectSelector.h"
-#include "CommonTools/UtilAlgos/interface/SingleElementCollectionSelector.h"
-
-#include "DataFormats/PatCandidates/interface/Electron.h"
-#include "DataFormats/PatCandidates/interface/Muon.h"
-#include "DataFormats/PatCandidates/interface/Tau.h"
-#include "DataFormats/PatCandidates/interface/Photon.h"
-#include "DataFormats/PatCandidates/interface/Jet.h"
-#include "DataFormats/PatCandidates/interface/MET.h"
-#include "DataFormats/PatCandidates/interface/PFParticle.h"
-#include "DataFormats/PatCandidates/interface/GenericParticle.h"
-#include "DataFormats/PatCandidates/interface/TriggerObjectStandAlone.h"
-#include "DataFormats/PatCandidates/interface/CompositeCandidate.h"
-
-#include "PhysicsTools/PatAlgos/plugins/PATJetSelector.h"
-
-#include <vector>
-
-
-namespace pat {
-
-
-  typedef SingleObjectSelector<
-              std::vector<Electron>,
-              StringCutObjectSelector<Electron>
-          > PATElectronSelector;
-  typedef SingleObjectSelector<
-              std::vector<Muon>,
-              StringCutObjectSelector<Muon>
-          > PATMuonSelector;
-  typedef SingleObjectSelector<
-              std::vector<Tau>,
-              StringCutObjectSelector<Tau>
-          > PATTauSelector;
-  typedef SingleObjectSelector<
-              std::vector<Photon>,
-              StringCutObjectSelector<Photon>
-          > PATPhotonSelector;
-  /* typedef SingleObjectSelector< */
-  /*             std::vector<Jet>, */
-  /*             StringCutObjectSelector<Jet> */
-  /*         > PATJetSelector; */
-  typedef SingleObjectSelector<
-              std::vector<MET>,
-              StringCutObjectSelector<MET>
-          > PATMETSelector;
-  typedef SingleObjectSelector<
-              std::vector<PFParticle>,
-              StringCutObjectSelector<PFParticle>
-          > PATPFParticleSelector;
-  typedef SingleObjectSelector<
-              std::vector<CompositeCandidate>,
-              StringCutObjectSelector<CompositeCandidate, true> // true => lazy parsing => get all methods of daughters
-          > PATCompositeCandidateSelector;
-  typedef SingleObjectSelector<
-              std::vector<TriggerObjectStandAlone>,
-              StringCutObjectSelector<TriggerObjectStandAlone>
-          > PATTriggerObjectStandAloneSelector;
-  typedef SingleObjectSelector<
-              std::vector<GenericParticle>,
-              StringCutObjectSelector<GenericParticle>
-          > PATGenericParticleSelector;
-
-  typedef SingleObjectSelector<
-              std::vector<Electron>,
-              StringCutObjectSelector<Electron>,
-              edm::RefVector<std::vector<Electron> >
-          > PATElectronRefSelector;
-  typedef SingleObjectSelector<
-              std::vector<Muon>,
-              StringCutObjectSelector<Muon>,
-              edm::RefVector<std::vector<Muon> >
-          > PATMuonRefSelector;
-  typedef SingleObjectSelector<
-              std::vector<Tau>,
-              StringCutObjectSelector<Tau>,
-              edm::RefVector<std::vector<Tau> >
-          > PATTauRefSelector;
-  typedef SingleObjectSelector<
-              std::vector<Photon>,
-              StringCutObjectSelector<Photon>,
-              edm::RefVector<std::vector<Photon> >
-          > PATPhotonRefSelector;
-  typedef SingleObjectSelector<
-              std::vector<Jet>,
-              StringCutObjectSelector<Jet>,
-              edm::RefVector<std::vector<Jet> >
-          > PATJetRefSelector;
-  typedef SingleObjectSelector<
-              std::vector<MET>,
-              StringCutObjectSelector<MET>,
-              edm::RefVector<std::vector<MET> >
-          > PATMETRefSelector;
-  typedef SingleObjectSelector<
-              std::vector<PFParticle>,
-              StringCutObjectSelector<PFParticle>,
-              edm::RefVector<std::vector<PFParticle> >
-          > PATPFParticleRefSelector;
-  typedef SingleObjectSelector<
-              std::vector<GenericParticle>,
-              StringCutObjectSelector<GenericParticle>,
-              edm::RefVector<std::vector<GenericParticle> >
-          > PATGenericParticleRefSelector;
-  typedef SingleObjectSelector<
-              std::vector<CompositeCandidate>,
-              StringCutObjectSelector<CompositeCandidate, true>, // true => lazy parsing => get all methods of daughters
-              edm::RefVector<std::vector<CompositeCandidate> >
-          > PATCompositeCandidateRefSelector;
-
-
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATPFParticleProducer.cc b/PhysicsTools/PatAlgos/plugins/PATPFParticleProducer.cc
deleted file mode 100755
index 1256edf..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATPFParticleProducer.cc
+++ /dev/null
@@ -1,149 +0,0 @@
-//
-// $Id: PATPFParticleProducer.cc,v 1.5 2009/06/25 23:49:35 gpetrucc Exp $
-//
-
-#include "PhysicsTools/PatAlgos/plugins/PATPFParticleProducer.h"
-
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "FWCore/ParameterSet/interface/FileInPath.h"
-
-#include "DataFormats/ParticleFlowCandidate/interface/PFCandidate.h"
-#include "DataFormats/ParticleFlowCandidate/interface/PFCandidateFwd.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
-
-#include "DataFormats/Common/interface/Association.h"
-
-#include "TMath.h"
-
-#include <vector>
-#include <memory>
-
-
-using namespace pat;
-
-
-PATPFParticleProducer::PATPFParticleProducer(const edm::ParameterSet & iConfig) {
-  // general configurables
-  pfCandidateSrc_ = iConfig.getParameter<edm::InputTag>( "pfCandidateSource" );
- 
-  // MC matching configurables
-  addGenMatch_   = iConfig.getParameter<bool>         ( "addGenMatch" );
-  if (addGenMatch_) {
-      embedGenMatch_ = iConfig.getParameter<bool>         ( "embedGenMatch" );
-      if (iConfig.existsAs<edm::InputTag>("genParticleMatch")) {
-          genMatchSrc_.push_back(iConfig.getParameter<edm::InputTag>( "genParticleMatch" ));
-      } else {
-          genMatchSrc_ = iConfig.getParameter<std::vector<edm::InputTag> >( "genParticleMatch" );
-      }
-  }
-
-  // Efficiency configurables
-  addEfficiencies_ = iConfig.getParameter<bool>("addEfficiencies");
-  if (addEfficiencies_) {
-     efficiencyLoader_ = pat::helper::EfficiencyLoader(iConfig.getParameter<edm::ParameterSet>("efficiencies"));
-  }
-
-  // Resolution configurables
-  addResolutions_ = iConfig.getParameter<bool>("addResolutions");
-  if (addResolutions_) {
-     resolutionLoader_ = pat::helper::KinResolutionsLoader(iConfig.getParameter<edm::ParameterSet>("resolutions"));
-  }
-
-
-
-  // produces vector of muons
-  produces<std::vector<PFParticle> >();
-
-}
-
-
-PATPFParticleProducer::~PATPFParticleProducer() {
-}
-
-
-void PATPFParticleProducer::produce(edm::Event & iEvent, 
-				    const edm::EventSetup & iSetup) {
-
-  // Get the collection of PFCandidates from the event
-  edm::Handle<edm::View<reco::PFCandidate> > pfCandidates;
-
-  fetchCandidateCollection(pfCandidates, 
-			   pfCandidateSrc_, 
-			   iEvent );
-
-  // prepare the MC matching
-  std::vector<edm::Handle<edm::Association<reco::GenParticleCollection> > > genMatches(genMatchSrc_.size());
-  if (addGenMatch_) {
-        for (size_t j = 0, nd = genMatchSrc_.size(); j < nd; ++j) {
-            iEvent.getByLabel(genMatchSrc_[j], genMatches[j]);
-        }
-  }
-
-  if (efficiencyLoader_.enabled()) efficiencyLoader_.newEvent(iEvent);
-  if (resolutionLoader_.enabled()) resolutionLoader_.newEvent(iEvent, iSetup);
-
-  // loop over PFCandidates
-  std::vector<PFParticle> * patPFParticles = new std::vector<PFParticle>();
-  for (edm::View<reco::PFCandidate>::const_iterator 
-	 itPFParticle = pfCandidates->begin(); 
-       itPFParticle != pfCandidates->end(); 
-       ++itPFParticle) {
-
-    // construct the PFParticle from the ref -> save ref to original object
-    unsigned int idx = itPFParticle - pfCandidates->begin();
-    edm::RefToBase<reco::PFCandidate> pfCandidatesRef = pfCandidates->refAt(idx);
-
-    PFParticle aPFParticle(pfCandidatesRef);
-
-    if (addGenMatch_) {
-      for(size_t i = 0, n = genMatches.size(); i < n; ++i) {
-          reco::GenParticleRef genPFParticle = (*genMatches[i])[pfCandidatesRef];
-          aPFParticle.addGenParticleRef(genPFParticle);
-      }
-      if (embedGenMatch_) aPFParticle.embedGenParticle();
-    }
-      
-    if (efficiencyLoader_.enabled()) {
-        efficiencyLoader_.setEfficiencies( aPFParticle, pfCandidatesRef );
-    }
-
-    if (resolutionLoader_.enabled()) {
-        resolutionLoader_.setResolutions(aPFParticle);
-    }
-
-    // add sel to selected
-    patPFParticles->push_back(aPFParticle);
-  }
-
-  // sort pfCandidates in pt
-  std::sort(patPFParticles->begin(), patPFParticles->end(), pTComparator_);
-
-  // put genEvt object in Event
-  std::auto_ptr<std::vector<PFParticle> > ptr(patPFParticles);
-  iEvent.put(ptr);
-
-}
-
-void 
-PATPFParticleProducer::fetchCandidateCollection( edm::Handle<edm::View<reco::PFCandidate> >& c, 
-						 const edm::InputTag& tag, 
-						 const edm::Event& iEvent) const {
-  
-  bool found = iEvent.getByLabel(tag, c);
-  
-  if(!found ) {
-    std::ostringstream  err;
-    err<<" cannot get PFCandidates: "
-       <<tag<<std::endl;
-    edm::LogError("PFCandidates")<<err.str();
-    throw cms::Exception( "MissingProduct", err.str());
-  }
-  
-}
-
-
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATPFParticleProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATPFParticleProducer.h b/PhysicsTools/PatAlgos/plugins/PATPFParticleProducer.h
deleted file mode 100644
index d1362f5..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATPFParticleProducer.h
+++ /dev/null
@@ -1,77 +0,0 @@
-//
-// $Id: PATPFParticleProducer.h,v 1.7 2010/02/20 21:00:26 wmtan Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATPFParticleProducer_h
-#define PhysicsTools_PatAlgos_PATPFParticleProducer_h
-
-/**
-  \class    pat::PATPFParticleProducer PATPFParticleProducer.h "PhysicsTools/PatAlgos/interface/PATPFParticleProducer.h"
-  \brief    Produces pat::PFParticle's
-
-   The PATPFParticleProducer produces analysis-level pat::PFParticle's starting from
-   a collection of objects of reco::PFCandidate.
-
-  \author   Steven Lowette, Roger Wolf
-  \version  $Id: PATPFParticleProducer.h,v 1.7 2010/02/20 21:00:26 wmtan Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "DataFormats/Common/interface/View.h"
-
-#include "CommonTools/Utils/interface/PtComparator.h"
-
-#include "DataFormats/PatCandidates/interface/PFParticle.h"
-
-#include "PhysicsTools/PatAlgos/interface/MultiIsolator.h"
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-
-#include <string>
-
-
-namespace pat {
-
-  class LeptonLRCalc;
-
-  class PATPFParticleProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATPFParticleProducer(const edm::ParameterSet & iConfig);
-      ~PATPFParticleProducer();
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-    private:
-      void 
-	fetchCandidateCollection(edm::Handle< edm::View<reco::PFCandidate> >& c, 
-				 const edm::InputTag& tag, 
-				 const edm::Event& iSetup) const;
-
-      // configurables
-      edm::InputTag pfCandidateSrc_;
-      bool          embedPFCandidate_;
-      bool          addGenMatch_;
-      bool          embedGenMatch_;
-      std::vector<edm::InputTag> genMatchSrc_;
-      // tools
-      GreaterByPt<PFParticle>      pTComparator_;
-
-      bool addEfficiencies_;
-      pat::helper::EfficiencyLoader efficiencyLoader_;
-      
-      bool addResolutions_;
-      pat::helper::KinResolutionsLoader resolutionLoader_;
-
- 
-  };
-
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATPhotonProducer.cc b/PhysicsTools/PatAlgos/plugins/PATPhotonProducer.cc
deleted file mode 100755
index 74222f8..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATPhotonProducer.cc
+++ /dev/null
@@ -1,269 +0,0 @@
-//
-// $Id: PATPhotonProducer.cc,v 1.29 2012/05/20 20:12:25 rwolf Exp $
-//
-
-#include "PhysicsTools/PatAlgos/plugins/PATPhotonProducer.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
-
-#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
-#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
-
-#include <memory>
-
-using namespace pat;
-
-PATPhotonProducer::PATPhotonProducer(const edm::ParameterSet & iConfig) :
-  isolator_(iConfig.exists("userIsolation") ? iConfig.getParameter<edm::ParameterSet>("userIsolation") : edm::ParameterSet(), false) ,
-  useUserData_(iConfig.exists("userData"))
-{
-  // initialize the configurables
-  photonSrc_ = iConfig.getParameter<edm::InputTag>("photonSource");
-  embedSuperCluster_ = iConfig.getParameter<bool>("embedSuperCluster");
-  // MC matching configurables
-  addGenMatch_ = iConfig.getParameter<bool>( "addGenMatch" );
-  if (addGenMatch_) {
-    embedGenMatch_ = iConfig.getParameter<bool>( "embedGenMatch" );
-    if (iConfig.existsAs<edm::InputTag>("genParticleMatch")) {
-      genMatchSrc_.push_back(iConfig.getParameter<edm::InputTag>( "genParticleMatch" ));
-    } 
-    else {
-      genMatchSrc_ = iConfig.getParameter<std::vector<edm::InputTag> >( "genParticleMatch" );
-    }
-  }
-  // Efficiency configurables
-  addEfficiencies_ = iConfig.getParameter<bool>("addEfficiencies");
-  if (addEfficiencies_) {
-    efficiencyLoader_ = pat::helper::EfficiencyLoader(iConfig.getParameter<edm::ParameterSet>("efficiencies"));
-  }
-  // photon ID configurables
-  addPhotonID_ = iConfig.getParameter<bool>( "addPhotonID" );
-  if (addPhotonID_) {
-    // it might be a single photon ID
-    if (iConfig.existsAs<edm::InputTag>("photonIDSource")) {
-      photIDSrcs_.push_back(NameTag("", iConfig.getParameter<edm::InputTag>("photonIDSource")));
-    }
-    // or there might be many of them
-    if (iConfig.existsAs<edm::ParameterSet>("photonIDSources")) {
-      // please don't configure me twice
-      if (!photIDSrcs_.empty()){
-	throw cms::Exception("Configuration") << "PATPhotonProducer: you can't specify both 'photonIDSource' and 'photonIDSources'\n";
-      }
-      // read the different photon ID names
-      edm::ParameterSet idps = iConfig.getParameter<edm::ParameterSet>("photonIDSources");
-      std::vector<std::string> names = idps.getParameterNamesForType<edm::InputTag>();
-      for (std::vector<std::string>::const_iterator it = names.begin(), ed = names.end(); it != ed; ++it) {
-	photIDSrcs_.push_back(NameTag(*it, idps.getParameter<edm::InputTag>(*it)));
-      }
-    }
-    // but in any case at least once
-    if (photIDSrcs_.empty()) throw cms::Exception("Configuration") <<
-      "PATPhotonProducer: id addPhotonID is true, you must specify either:\n" <<
-      "\tInputTag photonIDSource = <someTag>\n" << "or\n" <<
-      "\tPSet photonIDSources = { \n" <<
-      "\t\tInputTag <someName> = <someTag>   // as many as you want \n " <<
-      "\t}\n";
-  }
-  // Resolution configurables
-  addResolutions_ = iConfig.getParameter<bool>("addResolutions");
-  if (addResolutions_) {
-    resolutionLoader_ = pat::helper::KinResolutionsLoader(iConfig.getParameter<edm::ParameterSet>("resolutions"));
-  }
-  // Check to see if the user wants to add user data
-  if ( useUserData_ ) {
-    userDataHelper_ = PATUserDataHelper<Photon>(iConfig.getParameter<edm::ParameterSet>("userData"));
-  }
-  // produces vector of photons
-  produces<std::vector<Photon> >();
-
-  if (iConfig.exists("isoDeposits")) {
-     edm::ParameterSet depconf = iConfig.getParameter<edm::ParameterSet>("isoDeposits");
-     if (depconf.exists("tracker")) isoDepositLabels_.push_back(std::make_pair(pat::TrackIso, depconf.getParameter<edm::InputTag>("tracker")));
-     if (depconf.exists("ecal"))    isoDepositLabels_.push_back(std::make_pair(pat::EcalIso, depconf.getParameter<edm::InputTag>("ecal")));
-     if (depconf.exists("hcal"))    isoDepositLabels_.push_back(std::make_pair(pat::HcalIso, depconf.getParameter<edm::InputTag>("hcal")));
-     if (depconf.exists("user")) {
-        std::vector<edm::InputTag> userdeps = depconf.getParameter<std::vector<edm::InputTag> >("user");
-        std::vector<edm::InputTag>::const_iterator it = userdeps.begin(), ed = userdeps.end();
-        int key = UserBaseIso;
-        for ( ; it != ed; ++it, ++key) {
-            isoDepositLabels_.push_back(std::make_pair(IsolationKeys(key), *it));
-        }
-     }
-  }
-}
-
-PATPhotonProducer::~PATPhotonProducer() {
-}
-
-void PATPhotonProducer::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) 
-{
-  // switch off embedding (in unschedules mode)
-  if (iEvent.isRealData()){
-    addGenMatch_   = false;
-    embedGenMatch_ = false;
-  }
- 
-  // Get the vector of Photon's from the event
-  edm::Handle<edm::View<reco::Photon> > photons;
-  iEvent.getByLabel(photonSrc_, photons);
-
-  // prepare the MC matching
-  std::vector<edm::Handle<edm::Association<reco::GenParticleCollection> > > genMatches(genMatchSrc_.size());
-  if (addGenMatch_) {
-        for (size_t j = 0, nd = genMatchSrc_.size(); j < nd; ++j) {
-            iEvent.getByLabel(genMatchSrc_[j], genMatches[j]);
-        }
-  }
-
-  if (isolator_.enabled()) isolator_.beginEvent(iEvent,iSetup);
-  
-  if (efficiencyLoader_.enabled()) efficiencyLoader_.newEvent(iEvent);
-  if (resolutionLoader_.enabled()) resolutionLoader_.newEvent(iEvent, iSetup);
-  
-  std::vector<edm::Handle<edm::ValueMap<IsoDeposit> > > deposits(isoDepositLabels_.size());
-  for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-    iEvent.getByLabel(isoDepositLabels_[j].second, deposits[j]);
-  }
-  
-  // prepare ID extraction 
-  std::vector<edm::Handle<edm::ValueMap<Bool_t> > > idhandles;
-  std::vector<pat::Photon::IdPair>               ids;
-  if (addPhotonID_) {
-    idhandles.resize(photIDSrcs_.size());
-    ids.resize(photIDSrcs_.size());
-    for (size_t i = 0; i < photIDSrcs_.size(); ++i) {
-      iEvent.getByLabel(photIDSrcs_[i].second, idhandles[i]);
-      ids[i].first = photIDSrcs_[i].first;
-    }
-  }
-
-  // loop over photons
-  std::vector<Photon> * PATPhotons = new std::vector<Photon>(); 
-  for (edm::View<reco::Photon>::const_iterator itPhoton = photons->begin(); itPhoton != photons->end(); itPhoton++) {
-    // construct the Photon from the ref -> save ref to original object
-    unsigned int idx = itPhoton - photons->begin();
-    edm::RefToBase<reco::Photon> photonRef = photons->refAt(idx);
-    edm::Ptr<reco::Photon> photonPtr = photons->ptrAt(idx);
-    Photon aPhoton(photonRef);
-    if (embedSuperCluster_) aPhoton.embedSuperCluster();
-
-    // store the match to the generated final state muons
-    if (addGenMatch_) {
-      for(size_t i = 0, n = genMatches.size(); i < n; ++i) {
-          reco::GenParticleRef genPhoton = (*genMatches[i])[photonRef];
-          aPhoton.addGenParticleRef(genPhoton);
-      }
-      if (embedGenMatch_) aPhoton.embedGenParticle();
-    }
-
-    if (efficiencyLoader_.enabled()) {
-        efficiencyLoader_.setEfficiencies( aPhoton, photonRef );
-    }
-
-    if (resolutionLoader_.enabled()) {
-        resolutionLoader_.setResolutions(aPhoton);
-    }
-
-    // here comes the extra functionality
-    if (isolator_.enabled()) {
-        isolator_.fill(*photons, idx, isolatorTmpStorage_);
-        typedef pat::helper::MultiIsolator::IsolationValuePairs IsolationValuePairs;
-        // better to loop backwards, so the vector is resized less times
-        for (IsolationValuePairs::const_reverse_iterator it = isolatorTmpStorage_.rbegin(), ed = isolatorTmpStorage_.rend(); it != ed; ++it) {
-            aPhoton.setIsolation(it->first, it->second);
-        }
-    }
-
-    for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-        aPhoton.setIsoDeposit(isoDepositLabels_[j].first, (*deposits[j])[photonRef]);
-    }
-
-
-    // add photon ID info
-    if (addPhotonID_) {
-      for (size_t i = 0; i < photIDSrcs_.size(); ++i) {
-	ids[i].second = (*idhandles[i])[photonRef];    
-      }
-      aPhoton.setPhotonIDs(ids);
-    }
-
-    if ( useUserData_ ) {
-      userDataHelper_.add( aPhoton, iEvent, iSetup );
-    }
-    
-
-    // add the Photon to the vector of Photons
-    PATPhotons->push_back(aPhoton);
-  }
-
-  // sort Photons in ET
-  std::sort(PATPhotons->begin(), PATPhotons->end(), eTComparator_);
-
-  // put genEvt object in Event
-  std::auto_ptr<std::vector<Photon> > myPhotons(PATPhotons);
-  iEvent.put(myPhotons);
-  if (isolator_.enabled()) isolator_.endEvent();
-
-}
-
-// ParameterSet description for module
-void PATPhotonProducer::fillDescriptions(edm::ConfigurationDescriptions & descriptions)
-{
-  edm::ParameterSetDescription iDesc;
-  iDesc.setComment("PAT photon producer module");
-
-  // input source 
-  iDesc.add<edm::InputTag>("photonSource", edm::InputTag("no default"))->setComment("input collection");
-
-  iDesc.add<bool>("embedSuperCluster", true)->setComment("embed external super cluster");
-
-  // MC matching configurables
-  iDesc.add<bool>("addGenMatch", true)->setComment("add MC matching");
-  iDesc.add<bool>("embedGenMatch", false)->setComment("embed MC matched MC information");
-  std::vector<edm::InputTag> emptySourceVector;
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("genParticleMatch", edm::InputTag(), true) xor 
-                 edm::ParameterDescription<std::vector<edm::InputTag> >("genParticleMatch", emptySourceVector, true)
-	       )->setComment("input with MC match information");
-
-  pat::helper::KinResolutionsLoader::fillDescription(iDesc);
-
-  // photon ID configurables
-  iDesc.add<bool>("addPhotonID",true)->setComment("add photon ID variables");
-  edm::ParameterSetDescription photonIDSourcesPSet;
-  photonIDSourcesPSet.setAllowAnything(); 
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("photonIDSource", edm::InputTag(), true) xor
-                 edm::ParameterDescription<edm::ParameterSetDescription>("photonIDSources", photonIDSourcesPSet, true)
-                 )->setComment("input with photon ID variables");
-
-  // IsoDeposit configurables
-  edm::ParameterSetDescription isoDepositsPSet;
-  isoDepositsPSet.addOptional<edm::InputTag>("tracker"); 
-  isoDepositsPSet.addOptional<edm::InputTag>("ecal");
-  isoDepositsPSet.addOptional<edm::InputTag>("hcal");
-  isoDepositsPSet.addOptional<std::vector<edm::InputTag> >("user");
-  iDesc.addOptional("isoDeposits", isoDepositsPSet);
-
-  // Efficiency configurables
-  edm::ParameterSetDescription efficienciesPSet;
-  efficienciesPSet.setAllowAnything(); // TODO: the pat helper needs to implement a description.
-  iDesc.add("efficiencies", efficienciesPSet);
-  iDesc.add<bool>("addEfficiencies", false);
-
-  // Check to see if the user wants to add user data
-  edm::ParameterSetDescription userDataPSet;
-  PATUserDataHelper<Photon>::fillDescription(userDataPSet);
-  iDesc.addOptional("userData", userDataPSet);
-
-  edm::ParameterSetDescription isolationPSet;
-  isolationPSet.setAllowAnything(); // TODO: the pat helper needs to implement a description.
-  iDesc.add("userIsolation", isolationPSet);
-
-  descriptions.add("PATPhotonProducer", iDesc);
-
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATPhotonProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/PATPhotonProducer.h b/PhysicsTools/PatAlgos/plugins/PATPhotonProducer.h
deleted file mode 100644
index 271343f..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATPhotonProducer.h
+++ /dev/null
@@ -1,84 +0,0 @@
-//
-// $Id: PATPhotonProducer.h,v 1.19 2009/06/25 23:49:35 gpetrucc Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATPhotonProducer_h
-#define PhysicsTools_PatAlgos_PATPhotonProducer_h
-
-/**
-  \class    pat::PATPhotonProducer PATPhotonProducer.h "PhysicsTools/PatAlgos/interface/PATPhotonProducer.h"
-  \brief    Produces the pat::Photon
-
-   The PATPhotonProducer produces the analysis-level pat::Photon starting from
-   a collection of objects of PhotonType.
-
-  \author   Steven Lowette
-  \version  $Id: PATPhotonProducer.h,v 1.19 2009/06/25 23:49:35 gpetrucc Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-#include "CommonTools/Utils/interface/EtComparator.h"
-
-#include "DataFormats/PatCandidates/interface/Photon.h"
-
-#include "PhysicsTools/PatAlgos/interface/MultiIsolator.h"
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-
-
-#include "DataFormats/PatCandidates/interface/UserData.h"
-#include "PhysicsTools/PatAlgos/interface/PATUserDataHelper.h"
-
-namespace pat {
-
-  class PATPhotonProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATPhotonProducer(const edm::ParameterSet & iConfig);
-      ~PATPhotonProducer();
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-      static void fillDescriptions(edm::ConfigurationDescriptions & descriptions);
-
-    private:
-
-      // configurables
-      edm::InputTag photonSrc_;
-      bool embedSuperCluster_;
-
-      bool addGenMatch_;
-      bool embedGenMatch_;
-      std::vector<edm::InputTag> genMatchSrc_;
-
-      // tools
-      GreaterByEt<Photon> eTComparator_;
-
-      pat::helper::MultiIsolator isolator_; 
-      pat::helper::MultiIsolator::IsolationValuePairs isolatorTmpStorage_; // better here than recreate at each event
-      std::vector<std::pair<pat::IsolationKeys,edm::InputTag> > isoDepositLabels_;
-
-      bool addEfficiencies_;
-      pat::helper::EfficiencyLoader efficiencyLoader_;
-      
-      bool addResolutions_;
-      pat::helper::KinResolutionsLoader resolutionLoader_;
-
-      bool          addPhotonID_;
-      typedef std::pair<std::string, edm::InputTag> NameTag;
-      std::vector<NameTag> photIDSrcs_;
-
-      bool useUserData_;
-      pat::PATUserDataHelper<pat::Photon>      userDataHelper_;
-
-  };
-
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATPrimaryVertexCleaner.cc b/PhysicsTools/PatAlgos/plugins/PATPrimaryVertexCleaner.cc
deleted file mode 100755
index a9ced9c..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATPrimaryVertexCleaner.cc
+++ /dev/null
@@ -1,7 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/PATPrimaryVertexSelector.h"
-#include "CommonTools/UtilAlgos/interface/ObjectSelector.h"
-
-typedef ObjectSelector<PATPrimaryVertexSelector> PATPrimaryVertexCleaner;
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-DEFINE_FWK_MODULE(PATPrimaryVertexCleaner);
diff --git a/PhysicsTools/PatAlgos/plugins/PATSingleVertexSelector.cc b/PhysicsTools/PatAlgos/plugins/PATSingleVertexSelector.cc
deleted file mode 100644
index c2ef954..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATSingleVertexSelector.cc
+++ /dev/null
@@ -1,171 +0,0 @@
-#include "PhysicsTools/PatAlgos/plugins/PATSingleVertexSelector.h"
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/Candidate/interface/VertexCompositeCandidate.h"
-#include <DataFormats/BeamSpot/interface/BeamSpot.h>
-
-#include <algorithm>
-
-using pat::PATSingleVertexSelector;
-
-
-PATSingleVertexSelector::Mode
-PATSingleVertexSelector::parseMode(const std::string &mode) {
-    if (mode == "firstVertex") {
-        return First;
-    } else if (mode == "nearestToCandidate") {
-        return NearestToCand;
-    } else if (mode == "fromCandidate") {
-        return FromCand;
-    } else if (mode == "beamSpot") {
-        return FromBeamSpot;
-    } else {
-        throw cms::Exception("Configuration") << "PATSingleVertexSelector: Mode '" << mode << "' not recognized or not supported.\n";
-    }
-}
-
-
-PATSingleVertexSelector::PATSingleVertexSelector(const edm::ParameterSet & iConfig)
-  : doFilterEvents_(false)
-{
-   using namespace std;
-
-   modes_.push_back( parseMode(iConfig.getParameter<std::string>("mode")) );
-   if (iConfig.exists("fallbacks")) {
-      vector<string> modes = iConfig.getParameter<vector<string> >("fallbacks");
-      for (vector<string>::const_iterator it = modes.begin(), ed = modes.end(); it != ed; ++it) {
-        modes_.push_back( parseMode(*it) );
-      }
-   }
-   if (hasMode_(First) || hasMode_(NearestToCand)) {
-        vertices_ = iConfig.getParameter<edm::InputTag>("vertices");
-        if (iConfig.existsAs<string>("vertexPreselection")) {
-            string presel = iConfig.getParameter<string>("vertexPreselection");
-            if (!presel.empty()) vtxPreselection_ = auto_ptr<VtxSel>(new VtxSel(presel));
-        }
-   }
-   if (hasMode_(NearestToCand) || hasMode_(FromCand)) {
-        candidates_ = iConfig.getParameter<vector<edm::InputTag> >("candidates");
-        if (iConfig.existsAs<string>("candidatePreselection")) {
-            string presel = iConfig.getParameter<string>("candidatePreselection");
-            if (!presel.empty()) candPreselection_ = auto_ptr<CandSel>(new CandSel(presel));
-        }
-   }
-   if (hasMode_(FromBeamSpot)) {
-        beamSpot_ = iConfig.getParameter<edm::InputTag>("beamSpot");
-   }
-
-   if ( iConfig.exists("filter") ) doFilterEvents_ = iConfig.getParameter<bool>("filter");
-
-   produces<vector<reco::Vertex> >();
-}
-
-
-PATSingleVertexSelector::~PATSingleVertexSelector()
-{
-}
-
-bool PATSingleVertexSelector::hasMode_(Mode mode) const {
-    return (std::find(modes_.begin(), modes_.end(), mode) != modes_.end());
-}
-
-bool
-PATSingleVertexSelector::filter(edm::Event & iEvent, const edm::EventSetup & iSetup) {
-    using namespace edm;
-    using namespace std;
-
-    // Clear
-    selVtxs_.clear(); bestCand_ = 0;
-
-    // Gather data from the Event
-    // -- vertex data --
-    if (hasMode_(First) || hasMode_(NearestToCand)) {
-        Handle<vector<reco::Vertex> > vertices;
-        iEvent.getByLabel(vertices_, vertices);
-        for (vector<reco::Vertex>::const_iterator itv = vertices->begin(), edv = vertices->end(); itv != edv; ++itv) {
-            if ((vtxPreselection_.get() != 0) && !((*vtxPreselection_)(*itv)) ) continue;
-            selVtxs_.push_back( &*itv );
-        }
-    }
-    // -- candidate data --
-    if (hasMode_(NearestToCand) || hasMode_(FromCand)) {
-       vector<pair<double, const reco::Candidate *> > cands;
-       for (vector<edm::InputTag>::const_iterator itt = candidates_.begin(), edt = candidates_.end(); itt != edt; ++itt) {
-          Handle<View<reco::Candidate> > theseCands;
-          iEvent.getByLabel(*itt, theseCands);
-          for (View<reco::Candidate>::const_iterator itc = theseCands->begin(), edc = theseCands->end(); itc != edc; ++itc) {
-            if ((candPreselection_.get() != 0) && !((*candPreselection_)(*itc))) continue;
-            cands.push_back( pair<double, const reco::Candidate *>(-itc->pt(), &*itc) );
-          }
-       }
-       if (!cands.empty()) bestCand_ = cands.front().second;
-    }
-
-    bool passes = false;
-    auto_ptr<vector<reco::Vertex> > result;
-    // Run main mode + possible fallback modes
-    for (std::vector<Mode>::const_iterator itm = modes_.begin(), endm = modes_.end(); itm != endm; ++itm) {
-        result = filter_(*itm, iEvent, iSetup);
-        // Check if we got any vertices.  If so, take them.
-        if (result->size()) {
-          passes = true;
-          break;
-        }
-    }
-    iEvent.put(result);
-    // Check if we want to apply the EDFilter
-    if (doFilterEvents_)
-      return passes;
-    else return true;
-}
-
-std::auto_ptr<std::vector<reco::Vertex> >
-PATSingleVertexSelector::filter_(Mode mode, const edm::Event &iEvent, const edm::EventSetup & iSetup) {
-    using namespace edm;
-    using namespace std;
-    std::auto_ptr<std::vector<reco::Vertex> > result(
-        new std::vector<reco::Vertex>());
-    switch(mode) {
-        case First: {
-            if (selVtxs_.empty()) return result;
-            result->push_back(*selVtxs_.front());
-            return result;
-            }
-        case FromCand: {
-            if (bestCand_ == 0) return result;
-            reco::Vertex vtx;
-            if (typeid(*bestCand_) == typeid(reco::VertexCompositeCandidate)) {
-                vtx = reco::Vertex(bestCand_->vertex(), bestCand_->vertexCovariance(),
-                        bestCand_->vertexChi2(), bestCand_->vertexNdof(), bestCand_->numberOfDaughters() );
-            } else {
-                vtx = reco::Vertex(bestCand_->vertex(), reco::Vertex::Error(), 0, 0, 0);
-            }
-            result->push_back(vtx);
-            return result;
-            }
-        case NearestToCand: {
-            if (selVtxs_.empty() || (bestCand_ == 0)) return result;
-            const reco::Vertex * which = 0;
-            float dzmin = 9999.0;
-            for (vector<const reco::Vertex *>::const_iterator itv = selVtxs_.begin(), edv = selVtxs_.end(); itv != edv; ++itv) {
-                float dz = std::abs((*itv)->z() - bestCand_->vz());
-                if (dz < dzmin) { dzmin = dz; which = *itv; }
-            }
-            if (which != 0) // actually it should not happen, but better safe than sorry
-              result->push_back(*which);
-            return result;
-            }
-        case FromBeamSpot: {
-            Handle<reco::BeamSpot> beamSpot;
-            iEvent.getByLabel(beamSpot_, beamSpot);
-            reco::Vertex bs(beamSpot->position(), beamSpot->covariance3D(), 0, 0, 0);
-            result->push_back(bs);
-            return result;
-            }
-        default:
-            // Return an empty vector signifying no vertices found.
-            return result;
-    }
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-DEFINE_FWK_MODULE(PATSingleVertexSelector);
diff --git a/PhysicsTools/PatAlgos/plugins/PATSingleVertexSelector.h b/PhysicsTools/PatAlgos/plugins/PATSingleVertexSelector.h
deleted file mode 100644
index 869c38c..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATSingleVertexSelector.h
+++ /dev/null
@@ -1,65 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_PATSingleVertexSelector_h
-#define PhysicsTools_PatAlgos_PATSingleVertexSelector_h
-//
-// $Id: PATSingleVertexSelector.h,v 1.5 2011/06/15 11:47:25 friis Exp $
-//
-
-/**
-  \class    pat::PATSingleVertexSelector PATSingleVertexSelector.h "PhysicsTools/PatAlgos/plugins/PATSingleVertexSelector.h"
-  \brief    Produces a list containing a single vertex selected by some criteria
-
-
-  \author   Giovanni Petrucciani
-  \version  $Id: PATSingleVertexSelector.h,v 1.5 2011/06/15 11:47:25 friis Exp $
-*/
-
-#include "FWCore/Framework/interface/EDFilter.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "CommonTools/Utils/interface/StringCutObjectSelector.h"
-
-#include "DataFormats/VertexReco/interface/Vertex.h"
-#include "DataFormats/Candidate/interface/Candidate.h"
-
-namespace pat {
-
-  class PATSingleVertexSelector : public edm::EDFilter {
-
-    public:
-
-      explicit PATSingleVertexSelector(const edm::ParameterSet & iConfig);
-      ~PATSingleVertexSelector();
-
-      virtual bool filter(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-    private:
-      enum Mode { First, NearestToCand, FromCand, FromBeamSpot };
-      typedef StringCutObjectSelector<reco::Vertex>    VtxSel;
-      typedef StringCutObjectSelector<reco::Candidate> CandSel;
-
-      static Mode parseMode(const std::string &name) ;
-      std::auto_ptr<std::vector<reco::Vertex> >
-        filter_(Mode mode, const edm::Event & iEvent, const edm::EventSetup & iSetup);
-      bool hasMode_(Mode mode) const ;
-      // configurables
-      std::vector<Mode> modes_; // mode + optional fallbacks
-      edm::InputTag vertices_;
-      std::vector<edm::InputTag> candidates_;
-      std::auto_ptr<VtxSel > vtxPreselection_;
-      std::auto_ptr<CandSel> candPreselection_;
-      edm::InputTag beamSpot_;
-      // transient data. meaningful while 'filter()' is on the stack
-      std::vector<const reco::Vertex *> selVtxs_;
-      const reco::Candidate *           bestCand_;
-
-      // flag to enable/disable EDFilter functionality:
-      // if set to false, PATSingleVertexSelector selects the "one" event vertex,
-      // but does not reject any events
-      bool doFilterEvents_;
-  };
-
-}
-
-#endif
-
diff --git a/PhysicsTools/PatAlgos/plugins/PATTauProducer.cc b/PhysicsTools/PatAlgos/plugins/PATTauProducer.cc
deleted file mode 100755
index ecfe53b..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATTauProducer.cc
+++ /dev/null
@@ -1,478 +0,0 @@
-//
-// $Id: PATTauProducer.cc,v 1.37 2012/05/20 20:12:25 rwolf Exp $
-//
-
-#include "PhysicsTools/PatAlgos/plugins/PATTauProducer.h"
-
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-#include "FWCore/ParameterSet/interface/FileInPath.h"
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/Common/interface/Association.h"
-#include "DataFormats/Common/interface/Ref.h"
-
-#include "DataFormats/TauReco/interface/PFTau.h"
-#include "DataFormats/TauReco/interface/PFTauDiscriminator.h"
-#include "DataFormats/TauReco/interface/CaloTau.h"
-#include "DataFormats/TauReco/interface/CaloTauDiscriminator.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticleFwd.h"
-#include "DataFormats/HepMCCandidate/interface/GenParticle.h"
-#include "DataFormats/JetReco/interface/GenJetCollection.h"
-
-#include "DataFormats/PatCandidates/interface/TauJetCorrFactors.h"
-
-#include "FWCore/ParameterSet/interface/ConfigurationDescriptions.h"
-#include "FWCore/ParameterSet/interface/ParameterSetDescription.h"
-
-#include <vector>
-#include <memory>
-
-using namespace pat;
-
-PATTauProducer::PATTauProducer(const edm::ParameterSet & iConfig):
-  isolator_(iConfig.exists("userIsolation") ? iConfig.getParameter<edm::ParameterSet>("userIsolation") : edm::ParameterSet(), false) ,
-  useUserData_(iConfig.exists("userData"))
-{
-  // initialize the configurables
-  tauSrc_ = iConfig.getParameter<edm::InputTag>( "tauSource" );
-  embedIsolationTracks_ = iConfig.getParameter<bool>( "embedIsolationTracks" );
-  embedLeadTrack_ = iConfig.getParameter<bool>( "embedLeadTrack" );
-  embedSignalTracks_ = iConfig.getParameter<bool>( "embedSignalTracks" );
-  embedLeadPFCand_ = iConfig.getParameter<bool>( "embedLeadPFCand" );
-  embedLeadPFChargedHadrCand_ = iConfig.getParameter<bool>( "embedLeadPFChargedHadrCand" );
-  embedLeadPFNeutralCand_ = iConfig.getParameter<bool>( "embedLeadPFNeutralCand" );
-  embedSignalPFCands_ = iConfig.getParameter<bool>( "embedSignalPFCands" );
-  embedSignalPFChargedHadrCands_ = iConfig.getParameter<bool>( "embedSignalPFChargedHadrCands" );
-  embedSignalPFNeutralHadrCands_ = iConfig.getParameter<bool>( "embedSignalPFNeutralHadrCands" );
-  embedSignalPFGammaCands_ = iConfig.getParameter<bool>( "embedSignalPFGammaCands" );
-  embedIsolationPFCands_ = iConfig.getParameter<bool>( "embedIsolationPFCands" );
-  embedIsolationPFChargedHadrCands_ = iConfig.getParameter<bool>( "embedIsolationPFChargedHadrCands" );
-  embedIsolationPFNeutralHadrCands_ = iConfig.getParameter<bool>( "embedIsolationPFNeutralHadrCands" );
-  embedIsolationPFGammaCands_ = iConfig.getParameter<bool>( "embedIsolationPFGammaCands" );
-  addGenMatch_ = iConfig.getParameter<bool>( "addGenMatch" );
-  if (addGenMatch_) {
-    embedGenMatch_ = iConfig.getParameter<bool>( "embedGenMatch" );
-    if (iConfig.existsAs<edm::InputTag>("genParticleMatch")) {
-      genMatchSrc_.push_back(iConfig.getParameter<edm::InputTag>( "genParticleMatch" ));
-    } 
-    else {
-      genMatchSrc_ = iConfig.getParameter<std::vector<edm::InputTag> >( "genParticleMatch" );
-    }
-  }
-  addGenJetMatch_ = iConfig.getParameter<bool>( "addGenJetMatch" );
-  if(addGenJetMatch_) {
-    embedGenJetMatch_ = iConfig.getParameter<bool>( "embedGenJetMatch" );
-    genJetMatchSrc_ = iConfig.getParameter<edm::InputTag>( "genJetMatch" );
-  }
-  addTauJetCorrFactors_ = iConfig.getParameter<bool>( "addTauJetCorrFactors" );
-  tauJetCorrFactorsSrc_ = iConfig.getParameter<std::vector<edm::InputTag> >( "tauJetCorrFactorsSource" );
-  // tau ID configurables
-  addTauID_ = iConfig.getParameter<bool>( "addTauID" );
-  if ( addTauID_ ) {
-    // it might be a single tau ID
-    if (iConfig.existsAs<edm::InputTag>("tauIDSource")) {
-      tauIDSrcs_.push_back(NameTag("", iConfig.getParameter<edm::InputTag>("tauIDSource")));
-    }
-    // or there might be many of them
-    if (iConfig.existsAs<edm::ParameterSet>("tauIDSources")) {
-      // please don't configure me twice
-      if (!tauIDSrcs_.empty()){
-	throw cms::Exception("Configuration") << "PATTauProducer: you can't specify both 'tauIDSource' and 'tauIDSources'\n";
-      }
-      // read the different tau ID names
-      edm::ParameterSet idps = iConfig.getParameter<edm::ParameterSet>("tauIDSources");
-      std::vector<std::string> names = idps.getParameterNamesForType<edm::InputTag>();
-      for (std::vector<std::string>::const_iterator it = names.begin(), ed = names.end(); it != ed; ++it) {
-	tauIDSrcs_.push_back(NameTag(*it, idps.getParameter<edm::InputTag>(*it)));
-      }
-    }
-    // but in any case at least once
-    if (tauIDSrcs_.empty()) throw cms::Exception("Configuration") <<
-      "PATTauProducer: id addTauID is true, you must specify either:\n" <<
-      "\tInputTag tauIDSource = <someTag>\n" << "or\n" <<
-      "\tPSet tauIDSources = { \n" <<
-      "\t\tInputTag <someName> = <someTag>   // as many as you want \n " <<
-      "\t}\n";
-  }
-  // IsoDeposit configurables
-  if (iConfig.exists("isoDeposits")) {
-    edm::ParameterSet depconf = iConfig.getParameter<edm::ParameterSet>("isoDeposits");
-    if ( depconf.exists("tracker")         ) isoDepositLabels_.push_back(std::make_pair(pat::TrackIso, depconf.getParameter<edm::InputTag>("tracker")));
-    if ( depconf.exists("ecal")            ) isoDepositLabels_.push_back(std::make_pair(pat::EcalIso, depconf.getParameter<edm::InputTag>("ecal")));
-    if ( depconf.exists("hcal")            ) isoDepositLabels_.push_back(std::make_pair(pat::HcalIso, depconf.getParameter<edm::InputTag>("hcal")));
-    if ( depconf.exists("pfAllParticles")  ) isoDepositLabels_.push_back(std::make_pair(pat::PfAllParticleIso, depconf.getParameter<edm::InputTag>("pfAllParticles")));
-    if ( depconf.exists("pfChargedHadron") ) isoDepositLabels_.push_back(std::make_pair(pat::PfChargedHadronIso, depconf.getParameter<edm::InputTag>("pfChargedHadron")));
-    if ( depconf.exists("pfNeutralHadron") ) isoDepositLabels_.push_back(std::make_pair(pat::PfNeutralHadronIso,depconf.getParameter<edm::InputTag>("pfNeutralHadron")));
-    if ( depconf.exists("pfGamma")         ) isoDepositLabels_.push_back(std::make_pair(pat::PfGammaIso, depconf.getParameter<edm::InputTag>("pfGamma")));
-    
-    if ( depconf.exists("user") ) {
-      std::vector<edm::InputTag> userdeps = depconf.getParameter<std::vector<edm::InputTag> >("user");
-      std::vector<edm::InputTag>::const_iterator it = userdeps.begin(), ed = userdeps.end();
-      int key = UserBaseIso;
-      for ( ; it != ed; ++it, ++key) {
-	isoDepositLabels_.push_back(std::make_pair(IsolationKeys(key), *it));
-      }
-    }
-  }
-  // Efficiency configurables
-  addEfficiencies_ = iConfig.getParameter<bool>("addEfficiencies");
-  if (addEfficiencies_) {
-     efficiencyLoader_ = pat::helper::EfficiencyLoader(iConfig.getParameter<edm::ParameterSet>("efficiencies"));
-  }
-  // Resolution configurables
-  addResolutions_ = iConfig.getParameter<bool>("addResolutions");
-  if (addResolutions_) {
-     resolutionLoader_ = pat::helper::KinResolutionsLoader(iConfig.getParameter<edm::ParameterSet>("resolutions"));
-  }
-  // Check to see if the user wants to add user data
-  if ( useUserData_ ) {
-    userDataHelper_ = PATUserDataHelper<Tau>(iConfig.getParameter<edm::ParameterSet>("userData"));
-  }
-  // produces vector of taus
-  produces<std::vector<Tau> >();
-}
-
-PATTauProducer::~PATTauProducer() 
-{
-}
-
-void PATTauProducer::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) 
-{ 
-  // switch off embedding (in unschedules mode)
-  if (iEvent.isRealData()){
-    addGenMatch_    = false;
-    embedGenMatch_  = false;
-    addGenJetMatch_ = false;
-  }
-
-  // Get the collection of taus from the event
-  edm::Handle<edm::View<reco::BaseTau> > anyTaus;
-  try {
-    iEvent.getByLabel(tauSrc_, anyTaus);
-  } catch (const edm::Exception &e) {
-    edm::LogWarning("DataSource") << "WARNING! No Tau collection found. This missing input will not block the job. Instead, an empty tau collection is being be produced.";
-    std::auto_ptr<std::vector<Tau> > patTaus(new std::vector<Tau>()); 
-    iEvent.put(patTaus);
-    return;
-  }
-
-  if (isolator_.enabled()) isolator_.beginEvent(iEvent,iSetup);
-
-  if (efficiencyLoader_.enabled()) efficiencyLoader_.newEvent(iEvent);
-  if (resolutionLoader_.enabled()) resolutionLoader_.newEvent(iEvent, iSetup);
-   
-  std::vector<edm::Handle<edm::ValueMap<IsoDeposit> > > deposits(isoDepositLabels_.size());
-  for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-    iEvent.getByLabel(isoDepositLabels_[j].second, deposits[j]);
-  }
-
-  // prepare the MC matching
-  std::vector<edm::Handle<edm::Association<reco::GenParticleCollection> > > genMatches(genMatchSrc_.size());
-  if (addGenMatch_) {
-    for (size_t j = 0, nd = genMatchSrc_.size(); j < nd; ++j) {
-      iEvent.getByLabel(genMatchSrc_[j], genMatches[j]);
-    }
-  }
-
-  edm::Handle<edm::Association<reco::GenJetCollection> > genJetMatch;  
-  if (addGenJetMatch_) iEvent.getByLabel(genJetMatchSrc_, genJetMatch); 
-
-  // read in the jet correction factors ValueMap
-  std::vector<edm::ValueMap<TauJetCorrFactors> > tauJetCorrs;
-  if (addTauJetCorrFactors_) {
-    for ( size_t i = 0; i < tauJetCorrFactorsSrc_.size(); ++i ) {
-      edm::Handle<edm::ValueMap<TauJetCorrFactors> > tauJetCorr;
-      iEvent.getByLabel(tauJetCorrFactorsSrc_[i], tauJetCorr);
-      tauJetCorrs.push_back( *tauJetCorr );
-    }
-  }  
-
-  std::auto_ptr<std::vector<Tau> > patTaus(new std::vector<Tau>()); 
-
-  bool first=true; // this is introduced to issue warnings only for the first tau-jet
-  for (size_t idx = 0, ntaus = anyTaus->size(); idx < ntaus; ++idx) {
-    edm::RefToBase<reco::BaseTau> tausRef = anyTaus->refAt(idx);
-    edm::Ptr<reco::BaseTau> tausPtr = anyTaus->ptrAt(idx);
-    
-    Tau aTau(tausRef);
-    if (embedLeadTrack_)       aTau.embedLeadTrack();
-    if (embedSignalTracks_)    aTau.embedSignalTracks();
-    if (embedIsolationTracks_) aTau.embedIsolationTracks();    
-    if (embedLeadPFCand_) {
-      if (aTau.isPFTau() )
-	aTau.embedLeadPFCand();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    if (embedLeadPFChargedHadrCand_) {
-      if (aTau.isPFTau() )
-	aTau.embedLeadPFChargedHadrCand();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    if (embedLeadPFNeutralCand_) {
-      if (aTau.isPFTau() )
-	aTau.embedLeadPFNeutralCand();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    if (embedSignalPFCands_) {
-      if (aTau.isPFTau() )
-	aTau.embedSignalPFCands();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    if (embedSignalPFChargedHadrCands_) {
-      if (aTau.isPFTau() )
-	aTau.embedSignalPFChargedHadrCands();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    if (embedSignalPFNeutralHadrCands_) {
-      if (aTau.isPFTau() )
-	aTau.embedSignalPFNeutralHadrCands();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    if (embedSignalPFGammaCands_) {
-      if (aTau.isPFTau() )
-	aTau.embedSignalPFGammaCands();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    if (embedIsolationPFCands_) {
-      if (aTau.isPFTau() )
-	aTau.embedIsolationPFCands();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    if (embedIsolationPFChargedHadrCands_) {
-      if (aTau.isPFTau() )
-	aTau.embedIsolationPFChargedHadrCands();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    if (embedIsolationPFNeutralHadrCands_) {
-      if (aTau.isPFTau() )
-	aTau.embedIsolationPFNeutralHadrCands();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    if (embedIsolationPFGammaCands_) {
-      if (aTau.isPFTau() )
-	aTau.embedIsolationPFGammaCands();
-      else 
-	edm::LogWarning("Type Error") << "Embedding a PFTau-specific information into a pat::Tau which wasn't made from a reco::PFTau is impossible.\n";
-    }
-    
-    if (addTauJetCorrFactors_) {
-      // add additional JetCorrs to the jet 
-      for ( unsigned int i=0; i<tauJetCorrFactorsSrc_.size(); ++i ) {
-	const TauJetCorrFactors& tauJetCorr = tauJetCorrs[i][tausRef];
-	// uncomment for debugging
-	// tauJetCorr.print();
-	aTau.addJECFactors(tauJetCorr);
-      }
-      std::vector<std::string> levels = tauJetCorrs[0][tausRef].correctionLabels();
-      if(std::find(levels.begin(), levels.end(), "L2L3Residual")!=levels.end()){
-	aTau.initializeJEC(tauJetCorrs[0][tausRef].jecLevel("L2L3Residual"));
-      }
-      else if(std::find(levels.begin(), levels.end(), "L3Absolute")!=levels.end()){
-	aTau.initializeJEC(tauJetCorrs[0][tausRef].jecLevel("L3Absolute"));
-      }
-      else{
-	aTau.initializeJEC(tauJetCorrs[0][tausRef].jecLevel("Uncorrected"));
-	if(first){	  
-	  edm::LogWarning("L3Absolute not found") 
-	    << "L2L3Residual and L3Absolute are not part of the correction applied jetCorrFactors \n"
-	    << "of module " <<  tauJetCorrs[0][tausRef].jecSet() << " jets will remain"
-	    << " uncorrected."; 
-	  first=false;
-	}
-      }
-    }
-
-    // store the match to the generated final state muons
-    if (addGenMatch_) {
-      for(size_t i = 0, n = genMatches.size(); i < n; ++i) {
-          reco::GenParticleRef genTau = (*genMatches[i])[tausRef];
-          aTau.addGenParticleRef(genTau);
-      }
-      if (embedGenMatch_) aTau.embedGenParticle();
-    }
-    
-    // store the match to the visible part of the generated tau
-    if (addGenJetMatch_) {
-      reco::GenJetRef genJetTau = (*genJetMatch)[tausRef];
-      if (genJetTau.isNonnull() && genJetTau.isAvailable() ) {
-        aTau.setGenJet( genJetTau );
-      } // leave empty if no match found
-    }
-
-    // prepare ID extraction 
-    if ( addTauID_ ) {
-      std::vector<pat::Tau::IdPair> ids(tauIDSrcs_.size());
-      for ( size_t i = 0; i < tauIDSrcs_.size(); ++i ) {
-	edm::Handle<reco::CaloTauDiscriminator> caloTauIdDiscr;
-	iEvent.getByLabel(tauIDSrcs_[i].second, caloTauIdDiscr);
-
-	edm::Handle<reco::PFTauDiscriminator> pfTauIdDiscr;
-	iEvent.getByLabel(tauIDSrcs_[i].second, pfTauIdDiscr);
-	
-	if ( typeid(*tausRef) == typeid(reco::PFTau) ) {
-	  //std::cout << "filling PFTauDiscriminator '" << tauIDSrcs_[i].first << "' into pat::Tau object..." << std::endl;
-	  edm::Handle<reco::PFTauCollection> pfTauCollection; 
-	  iEvent.getByLabel(tauSrc_, pfTauCollection);
-
-	  edm::Handle<reco::PFTauDiscriminator> pfTauIdDiscr;
-	  iEvent.getByLabel(tauIDSrcs_[i].second, pfTauIdDiscr);
-
-	  ids[i].first = tauIDSrcs_[i].first;
-	  ids[i].second = getTauIdDiscriminator(pfTauCollection, idx, pfTauIdDiscr);
-	} else if ( typeid(*tausRef) == typeid(reco::CaloTau) ) {
-	  //std::cout << "filling CaloTauDiscriminator '" << tauIDSrcs_[i].first << "' into pat::Tau object..." << std::endl;
-	  edm::Handle<reco::CaloTauCollection> caloTauCollection; 
-	  iEvent.getByLabel(tauSrc_, caloTauCollection);
-
-	  edm::Handle<reco::CaloTauDiscriminator> caloTauIdDiscr;
-	  iEvent.getByLabel(tauIDSrcs_[i].second, caloTauIdDiscr);
-
-	  ids[i].first = tauIDSrcs_[i].first;
-	  ids[i].second = getTauIdDiscriminator(caloTauCollection, idx, caloTauIdDiscr);
-	} else {
-	  throw cms::Exception("Type Mismatch") <<
-	    "PATTauProducer: unsupported datatype '" << typeid(*tausRef).name() << "' for tauSource\n";
-	}
-      }
-
-      aTau.setTauIDs(ids);
-    }
-
-    // extraction of reconstructed tau decay mode 
-    // (only available for PFTaus)
-    if ( aTau.isPFTau() ) {
-      edm::Handle<reco::PFTauCollection> pfTaus;
-      iEvent.getByLabel(tauSrc_, pfTaus);
-      reco::PFTauRef pfTauRef(pfTaus, idx);
-
-      aTau.setDecayMode(pfTauRef->decayMode());
-    }
-
-    // Isolation
-    if (isolator_.enabled()) {
-      isolator_.fill(*anyTaus, idx, isolatorTmpStorage_);
-      typedef pat::helper::MultiIsolator::IsolationValuePairs IsolationValuePairs;
-      // better to loop backwards, so the vector is resized less times
-      for ( IsolationValuePairs::const_reverse_iterator it = isolatorTmpStorage_.rbegin(), 
-	      ed = isolatorTmpStorage_.rend(); it != ed; ++it) {
-	aTau.setIsolation(it->first, it->second);
-      }
-    }
-    
-    for (size_t j = 0, nd = deposits.size(); j < nd; ++j) {
-      aTau.setIsoDeposit(isoDepositLabels_[j].first, (*deposits[j])[tausRef]);
-    }
-
-    if (efficiencyLoader_.enabled()) {
-      efficiencyLoader_.setEfficiencies( aTau, tausRef );
-    }
-
-    if (resolutionLoader_.enabled()) {
-      resolutionLoader_.setResolutions(aTau);
-    }
-
-    if ( useUserData_ ) {
-      userDataHelper_.add( aTau, iEvent, iSetup );
-    }
-
-    patTaus->push_back(aTau);
-  }
-
-  // sort taus in pT
-  std::sort(patTaus->begin(), patTaus->end(), pTTauComparator_);
-
-  // put genEvt object in Event
-  iEvent.put(patTaus);
-
-  // clean up
-  if (isolator_.enabled()) isolator_.endEvent();
-}
-
-template <typename TauCollectionType, typename TauDiscrType>
-float PATTauProducer::getTauIdDiscriminator(const edm::Handle<TauCollectionType>& tauCollection, size_t tauIdx, const edm::Handle<TauDiscrType>& tauIdDiscr)
-{
-  edm::Ref<TauCollectionType> tauRef(tauCollection, tauIdx);
-  return (*tauIdDiscr)[tauRef];
-}     
-
-// ParameterSet description for module
-void PATTauProducer::fillDescriptions(edm::ConfigurationDescriptions & descriptions)
-{
-  edm::ParameterSetDescription iDesc;
-  iDesc.setComment("PAT tau producer module");
-
-  // input source 
-  iDesc.add<edm::InputTag>("tauSource", edm::InputTag())->setComment("input collection");
-
-  // embedding
-  iDesc.add<bool>("embedIsolationTracks", false)->setComment("embed external isolation tracks");
-  iDesc.add<bool>("embedLeadTrack", false)->setComment("embed external leading track");
-  iDesc.add<bool>("embedLeadTracks", false)->setComment("embed external signal tracks");
-
-  // MC matching configurables
-  iDesc.add<bool>("addGenMatch", true)->setComment("add MC matching");
-  iDesc.add<bool>("embedGenMatch", false)->setComment("embed MC matched MC information");
-  std::vector<edm::InputTag> emptySourceVector;
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("genParticleMatch", edm::InputTag(), true) xor 
-                 edm::ParameterDescription<std::vector<edm::InputTag> >("genParticleMatch", emptySourceVector, true)
-		 )->setComment("input with MC match information");
-
-  // MC jet matching variables
-  iDesc.add<bool>("addGenJetMatch", true)->setComment("add MC jet matching");
-  iDesc.add<bool>("embedGenJetMatch", false)->setComment("embed MC jet matched jet information");
-  iDesc.add<edm::InputTag>("genJetMatch", edm::InputTag("tauGenJetMatch"));
-
-
-  pat::helper::KinResolutionsLoader::fillDescription(iDesc);
-
-  // tau ID configurables
-  iDesc.add<bool>("addTauID", true)->setComment("add tau ID variables");
-  edm::ParameterSetDescription tauIDSourcesPSet;
-  tauIDSourcesPSet.setAllowAnything(); 
-  iDesc.addNode( edm::ParameterDescription<edm::InputTag>("tauIDSource", edm::InputTag(), true) xor
-                 edm::ParameterDescription<edm::ParameterSetDescription>("tauIDSources", tauIDSourcesPSet, true)
-               )->setComment("input with electron ID variables");
-
-  // IsoDeposit configurables
-  edm::ParameterSetDescription isoDepositsPSet;
-  isoDepositsPSet.addOptional<edm::InputTag>("tracker"); 
-  isoDepositsPSet.addOptional<edm::InputTag>("ecal");
-  isoDepositsPSet.addOptional<edm::InputTag>("hcal");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfAllParticles");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfChargedHadron");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfNeutralHadron");
-  isoDepositsPSet.addOptional<edm::InputTag>("pfGamma");
-  isoDepositsPSet.addOptional<std::vector<edm::InputTag> >("user");
-  iDesc.addOptional("isoDeposits", isoDepositsPSet);
-
-  // Efficiency configurables
-  edm::ParameterSetDescription efficienciesPSet;
-  efficienciesPSet.setAllowAnything(); // TODO: the pat helper needs to implement a description.
-  iDesc.add("efficiencies", efficienciesPSet);
-  iDesc.add<bool>("addEfficiencies", false);
-
-  // Check to see if the user wants to add user data
-  edm::ParameterSetDescription userDataPSet;
-  PATUserDataHelper<Tau>::fillDescription(userDataPSet);
-  iDesc.addOptional("userData", userDataPSet);
-
-  edm::ParameterSetDescription isolationPSet;
-  isolationPSet.setAllowAnything(); // TODO: the pat helper needs to implement a description.
-  iDesc.add("userIsolation", isolationPSet);
-
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATTauProducer);
-
-
diff --git a/PhysicsTools/PatAlgos/plugins/PATTauProducer.h b/PhysicsTools/PatAlgos/plugins/PATTauProducer.h
deleted file mode 100644
index 2c3adee..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATTauProducer.h
+++ /dev/null
@@ -1,113 +0,0 @@
-//
-// $Id: PATTauProducer.h,v 1.23 2011/09/26 12:36:30 veelken Exp $
-//
-
-#ifndef PhysicsTools_PatAlgos_PATTauProducer_h
-#define PhysicsTools_PatAlgos_PATTauProducer_h
-
-/**
-  \class    pat::PATTauProducer PATTauProducer.h "PhysicsTools/PatAlgos/interface/PATTauProducer.h"
-  \brief    Produces pat::Tau's
-
-   The PATTauProducer produces analysis-level pat::Tau's starting from
-   a collection of objects of TauType.
-
-  \author   Steven Lowette, Christophe Delaere
-  \version  $Id: PATTauProducer.h,v 1.23 2011/09/26 12:36:30 veelken Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "DataFormats/Common/interface/Handle.h"
-
-#include "CommonTools/Utils/interface/PtComparator.h"
-
-#include "PhysicsTools/PatAlgos/interface/MultiIsolator.h"
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-
-#include "DataFormats/PatCandidates/interface/Tau.h"
-
-#include "DataFormats/PatCandidates/interface/UserData.h"
-#include "PhysicsTools/PatAlgos/interface/PATUserDataMerger.h"
-#include "PhysicsTools/PatAlgos/interface/PATUserDataHelper.h"
-
-#include "DataFormats/TauReco/interface/CaloTauDiscriminator.h"
-#include "DataFormats/TauReco/interface/PFTauDiscriminator.h"
-
-#include <string>
-
-
-namespace pat {
-
-  class PATTauProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATTauProducer(const edm::ParameterSet & iConfig);
-      ~PATTauProducer();
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-      static void fillDescriptions(edm::ConfigurationDescriptions & descriptions);
-
-    private:
-
-      // configurables
-      edm::InputTag tauSrc_;
-      bool embedIsolationTracks_;
-      bool embedLeadTrack_;
-      bool embedSignalTracks_;
-      bool embedLeadPFCand_; 
-      bool embedLeadPFChargedHadrCand_; 
-      bool embedLeadPFNeutralCand_; 
-      bool embedSignalPFCands_; 
-      bool embedSignalPFChargedHadrCands_; 
-      bool embedSignalPFNeutralHadrCands_; 
-      bool embedSignalPFGammaCands_; 
-      bool embedIsolationPFCands_; 
-      bool embedIsolationPFChargedHadrCands_; 
-      bool embedIsolationPFNeutralHadrCands_; 
-      bool embedIsolationPFGammaCands_; 
-
-      bool          addGenMatch_;
-      bool          embedGenMatch_;
-      std::vector<edm::InputTag> genMatchSrc_;
-
-      bool          addGenJetMatch_;
-      bool          embedGenJetMatch_;
-      edm::InputTag genJetMatchSrc_;
-
-      bool          addTauJetCorrFactors_;
-      std::vector<edm::InputTag> tauJetCorrFactorsSrc_;
-
-      bool          addTauID_;
-      typedef std::pair<std::string, edm::InputTag> NameTag;
-      std::vector<NameTag> tauIDSrcs_;
-
-      // tools
-      GreaterByPt<Tau>       pTTauComparator_;
-
-      pat::helper::MultiIsolator isolator_; 
-      pat::helper::MultiIsolator::IsolationValuePairs isolatorTmpStorage_; // better here than recreate at each event
-      std::vector<std::pair<pat::IsolationKeys,edm::InputTag> > isoDepositLabels_;
-
-      bool addEfficiencies_;
-      pat::helper::EfficiencyLoader efficiencyLoader_;
-      
-      bool addResolutions_;
-      pat::helper::KinResolutionsLoader resolutionLoader_;
-
-      bool useUserData_;
-      pat::PATUserDataHelper<pat::Tau>      userDataHelper_;
-
-      template <typename TauCollectionType, typename TauDiscrType> float getTauIdDiscriminator(const edm::Handle<TauCollectionType>&, size_t, const edm::Handle<TauDiscrType>&);
-  };
-
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATTriggerEventProducer.cc b/PhysicsTools/PatAlgos/plugins/PATTriggerEventProducer.cc
deleted file mode 100644
index 98f656e..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATTriggerEventProducer.cc
+++ /dev/null
@@ -1,291 +0,0 @@
-//
-// $Id: PATTriggerEventProducer.cc,v 1.18 2012/05/14 18:02:02 vadler Exp $
-//
-
-
-#include "PhysicsTools/PatAlgos/plugins/PATTriggerEventProducer.h"
-
-#include <cassert>
-
-#include "DataFormats/Common/interface/TriggerResults.h"
-#include "DataFormats/HLTReco/interface/TriggerEvent.h"
-#include "DataFormats/L1GlobalTrigger/interface/L1GlobalTriggerReadoutRecord.h"
-#include "CondFormats/L1TObjects/interface/L1GtTriggerMenu.h"
-#include "CondFormats/DataRecord/interface/L1GtTriggerMenuRcd.h"
-#include "DataFormats/PatCandidates/interface/TriggerObjectStandAlone.h"
-#include "DataFormats/PatCandidates/interface/TriggerEvent.h"
-#include "DataFormats/Provenance/interface/ProcessHistory.h"
-#include "FWCore/ParameterSet/interface/Registry.h"
-
-#include "DataFormats/Common/interface/AssociativeIterator.h"
-#include "FWCore/Framework/interface/ESHandle.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-
-
-using namespace pat;
-using namespace edm;
-
-
-PATTriggerEventProducer::PATTriggerEventProducer( const ParameterSet & iConfig ) :
-  nameProcess_( iConfig.getParameter< std::string >( "processName" ) ),
-  autoProcessName_( nameProcess_ == "*" ),
-  tagTriggerProducer_( "patTrigger" ),
-  tagsTriggerMatcher_(),
-  // L1 configuration parameters
-  tagL1Gt_(),
-  // HLTConfigProvider
-  hltConfigInit_( false ),
-  // HLT configuration parameters
-  tagTriggerResults_( "TriggerResults" ),
-  tagTriggerEvent_( "hltTriggerSummaryAOD" ),
-  // Conditions configuration parameters
-  tagCondGt_(),
-  // Conditions
-  condRun_(),
-  condLumi_(),
-  gtCondRunInit_( false ),
-  gtCondLumiInit_( false )
-{
-
-  if ( iConfig.exists( "triggerResults" ) )     tagTriggerResults_  = iConfig.getParameter< InputTag >( "triggerResults" );
-  if ( iConfig.exists( "triggerEvent" ) )       tagTriggerEvent_    = iConfig.getParameter< InputTag >( "triggerEvent" );
-  if ( iConfig.exists( "patTriggerProducer" ) ) tagTriggerProducer_ = iConfig.getParameter< InputTag >( "patTriggerProducer" );
-  if ( iConfig.exists( "condGtTag" ) )          tagCondGt_          = iConfig.getParameter< InputTag >( "condGtTag" );
-  if ( iConfig.exists( "l1GtTag" ) )            tagL1Gt_            = iConfig.getParameter< InputTag >( "l1GtTag" );
-  if ( iConfig.exists( "patTriggerMatches" ) )  tagsTriggerMatcher_ = iConfig.getParameter< std::vector< InputTag > >( "patTriggerMatches" );
-
-  for ( size_t iMatch = 0; iMatch < tagsTriggerMatcher_.size(); ++iMatch ) {
-    produces< TriggerObjectMatch >( tagsTriggerMatcher_.at( iMatch ).label() );
-  }
-  produces< TriggerEvent >();
-
-}
-
-
-void PATTriggerEventProducer::beginRun( Run & iRun, const EventSetup & iSetup )
-{
-
-  // Initialize process name
-  if ( autoProcessName_ ) {
-    // reset
-    nameProcess_ = "*";
-    // determine process name from last run TriggerSummaryProducerAOD module in process history of input
-    const ProcessHistory & processHistory( iRun.processHistory() );
-    ProcessConfiguration processConfiguration;
-    ParameterSet processPSet;
-    // unbroken loop, which relies on time ordering (accepts the last found entry)
-    for ( ProcessHistory::const_iterator iHist = processHistory.begin(); iHist != processHistory.end(); ++iHist ) {
-      if ( processHistory.getConfigurationForProcess( iHist->processName(), processConfiguration )     &&
-           pset::Registry::instance()->getMapped( processConfiguration.parameterSetID(), processPSet ) &&
-           processPSet.exists( tagTriggerEvent_.label() )
-         ) {
-        nameProcess_ = iHist->processName();
-        LogDebug( "autoProcessName" ) << "HLT process name '" << nameProcess_ << "' discovered";
-      }
-    }
-    // terminate, if nothing is found
-    if ( nameProcess_ == "*" ) {
-      LogError( "autoProcessName" ) << "trigger::TriggerEvent product with label '" << tagTriggerEvent_.label() << "' not produced according to process history of input data\n"
-                                    << "No trigger information produced.";
-      return;
-    }
-    LogInfo( "autoProcessName" ) << "HLT process name " << nameProcess_ << " used for PAT trigger information";
-  }
-  // adapt configuration of used input tags
-  if ( tagTriggerResults_.process().empty() || tagTriggerResults_.process() == "*" ) {
-    tagTriggerResults_ = InputTag( tagTriggerResults_.label(), tagTriggerResults_.instance(), nameProcess_ );
-  } else if ( tagTriggerEvent_.process() != nameProcess_ ) {
-    LogWarning( "triggerResultsTag" ) << "TriggerResults process name '" << tagTriggerResults_.process() << "' differs from HLT process name '" << nameProcess_ << "'";
-  }
-  if ( tagTriggerEvent_.process().empty() || tagTriggerEvent_.process()   == "*" ) {
-    tagTriggerEvent_ = InputTag( tagTriggerEvent_.label(), tagTriggerEvent_.instance(), nameProcess_ );
-  } else if ( tagTriggerEvent_.process() != nameProcess_ ) {
-    LogWarning( "triggerEventTag" ) << "TriggerEvent process name '" << tagTriggerEvent_.process() << "' differs from HLT process name '" << nameProcess_ << "'";
-  }
-
-  gtCondRunInit_ = false;
-  if ( ! tagCondGt_.label().empty() ) {
-    Handle< ConditionsInRunBlock > condRunBlock;
-    iRun.getByLabel( tagCondGt_, condRunBlock );
-    if ( condRunBlock.isValid() ) {
-      condRun_       = *condRunBlock;
-      gtCondRunInit_ = true;
-    } else {
-      LogError( "conditionsInEdm" ) << "ConditionsInRunBlock product with InputTag '" << tagCondGt_.encode() << "' not in run";
-    }
-  }
-
-  // Initialize HLTConfigProvider
-  hltConfigInit_ = false;
-  bool changed( true );
-  if ( ! hltConfig_.init( iRun, iSetup, nameProcess_, changed ) ) {
-    LogError( "hltConfigExtraction" ) << "HLT config extraction error with process name '" << nameProcess_ << "'";
-  } else if ( hltConfig_.size() <= 0 ) {
-    LogError( "hltConfigSize" ) << "HLT config size error";
-  } else hltConfigInit_ = true;
-
-}
-
-void PATTriggerEventProducer::beginLuminosityBlock( LuminosityBlock & iLuminosityBlock, const EventSetup & iSetup )
-{
-
-  // Terminate, if auto process name determination failed
-  if ( nameProcess_ == "*" ) return;
-
-  gtCondLumiInit_ = false;
-  if ( ! tagCondGt_.label().empty() ) {
-    Handle< ConditionsInLumiBlock > condLumiBlock;
-    iLuminosityBlock.getByLabel( tagCondGt_, condLumiBlock );
-    if ( condLumiBlock.isValid() ) {
-      condLumi_       = *condLumiBlock;
-      gtCondLumiInit_ = true;
-    } else {
-      LogError( "conditionsInEdm" ) << "ConditionsInLumiBlock product with InputTag '" << tagCondGt_.encode() << "' not in lumi";
-    }
-  }
-
-}
-
-
-void PATTriggerEventProducer::produce( Event& iEvent, const EventSetup& iSetup )
-{
-
-  // Terminate, if auto process name determination failed
-  if ( nameProcess_ == "*" ) return;
-
-  if ( ! hltConfigInit_ ) return;
-
-  ESHandle< L1GtTriggerMenu > handleL1GtTriggerMenu;
-  iSetup.get< L1GtTriggerMenuRcd >().get( handleL1GtTriggerMenu );
-  Handle< TriggerResults > handleTriggerResults;
-  iEvent.getByLabel( tagTriggerResults_, handleTriggerResults );
-  if ( ! handleTriggerResults.isValid() ) {
-    LogError( "triggerResultsValid" ) << "TriggerResults product with InputTag '" << tagTriggerResults_.encode() << "' not in event\n"
-                                      << "No trigger information produced";
-    return;
-  }
-  Handle< TriggerAlgorithmCollection > handleTriggerAlgorithms;
-  iEvent.getByLabel( tagTriggerProducer_, handleTriggerAlgorithms );
-  Handle< TriggerConditionCollection > handleTriggerConditions;
-  iEvent.getByLabel( tagTriggerProducer_, handleTriggerConditions );
-  Handle< TriggerPathCollection > handleTriggerPaths;
-  iEvent.getByLabel( tagTriggerProducer_, handleTriggerPaths );
-  Handle< TriggerFilterCollection > handleTriggerFilters;
-  iEvent.getByLabel( tagTriggerProducer_, handleTriggerFilters );
-  Handle< TriggerObjectCollection > handleTriggerObjects;
-  iEvent.getByLabel( tagTriggerProducer_, handleTriggerObjects );
-
-  bool physDecl( false );
-  if ( iEvent.isRealData() && ! tagL1Gt_.label().empty() ) {
-    Handle< L1GlobalTriggerReadoutRecord > handleL1GlobalTriggerReadoutRecord;
-    iEvent.getByLabel( tagL1Gt_, handleL1GlobalTriggerReadoutRecord );
-    if ( handleL1GlobalTriggerReadoutRecord.isValid() ) {
-      L1GtFdlWord fdlWord = handleL1GlobalTriggerReadoutRecord->gtFdlWord();
-      if ( fdlWord.physicsDeclared() == 1 ) {
-        physDecl = true;
-      }
-    } else {
-      LogError( "l1GlobalTriggerReadoutRecordValid" ) << "L1GlobalTriggerReadoutRecord product with InputTag '" << tagL1Gt_.encode() << "' not in event";
-    }
-  } else {
-    physDecl = true;
-  }
-
-
-  // produce trigger event
-
-  std::auto_ptr< TriggerEvent > triggerEvent( new TriggerEvent( handleL1GtTriggerMenu->gtTriggerMenuName(), std::string( hltConfig_.tableName() ), handleTriggerResults->wasrun(), handleTriggerResults->accept(), handleTriggerResults->error(), physDecl ) );
-  // set product references to trigger collections
-  if ( handleTriggerAlgorithms.isValid() ) {
-    triggerEvent->setAlgorithms( handleTriggerAlgorithms );
-  } else {
-    LogError( "triggerAlgorithmsValid" ) << "pat::TriggerAlgorithmCollection product with InputTag '" << tagTriggerProducer_.encode() << "' not in event";
-  }
-  if ( handleTriggerConditions.isValid() ) {
-    triggerEvent->setConditions( handleTriggerConditions );
-  } else {
-    LogError( "triggerConditionsValid" ) << "pat::TriggerConditionCollection product with InputTag '" << tagTriggerProducer_.encode() << "' not in event";
-  }
-  if ( handleTriggerPaths.isValid() ) {
-    triggerEvent->setPaths( handleTriggerPaths );
-  } else {
-    LogError( "triggerPathsValid" ) << "pat::TriggerPathCollection product with InputTag '" << tagTriggerProducer_.encode() << "' not in event";
-  }
-  if ( handleTriggerFilters.isValid() ) {
-    triggerEvent->setFilters( handleTriggerFilters );
-  } else {
-    LogError( "triggerFiltersValid" ) << "pat::TriggerFilterCollection product with InputTag '" << tagTriggerProducer_.encode() << "' not in event";
-  }
-  if ( handleTriggerObjects.isValid() ) {
-    triggerEvent->setObjects( handleTriggerObjects );
-  } else {
-    LogError( "triggerObjectsValid" ) << "pat::TriggerObjectCollection product with InputTag '" << tagTriggerProducer_.encode() << "' not in event";
-  }
-  if ( gtCondRunInit_ ) {
-    triggerEvent->setLhcFill( condRun_.lhcFillNumber );
-    triggerEvent->setBeamMode( condRun_.beamMode );
-    triggerEvent->setBeamMomentum( condRun_.beamMomentum );
-    triggerEvent->setBCurrentStart( condRun_.BStartCurrent );
-    triggerEvent->setBCurrentStop( condRun_.BStopCurrent );
-    triggerEvent->setBCurrentAvg( condRun_.BAvgCurrent );
-  }
-  if ( gtCondLumiInit_ ) {
-    triggerEvent->setIntensityBeam1( condLumi_.totalIntensityBeam1 );
-    triggerEvent->setIntensityBeam2( condLumi_.totalIntensityBeam2 );
-  }
-  if ( ! tagCondGt_.label().empty() ) {
-    Handle< ConditionsInEventBlock > condEventBlock;
-    iEvent.getByLabel( tagCondGt_, condEventBlock );
-    if ( condEventBlock.isValid() ) {
-      triggerEvent->setBstMasterStatus( condEventBlock->bstMasterStatus );
-      triggerEvent->setTurnCount( condEventBlock->turnCountNumber );
-    } else {
-      LogError( "conditionsInEdm" ) << "ConditionsInEventBlock product with InputTag '" << tagCondGt_.encode() << "' not in event";
-    }
-  }
-
-  // produce trigger match association and set references
-  if ( handleTriggerObjects.isValid() ) {
-    for ( size_t iMatch = 0; iMatch < tagsTriggerMatcher_.size(); ++iMatch ) {
-      const std::string labelTriggerObjectMatcher( tagsTriggerMatcher_.at( iMatch ).label() );
-      // copy trigger match association using TriggerObjectStandAlone to those using TriggerObject
-      // relying on the fact, that only one candidate collection is present in the association
-      Handle< TriggerObjectStandAloneMatch > handleTriggerObjectStandAloneMatch;
-      iEvent.getByLabel( labelTriggerObjectMatcher, handleTriggerObjectStandAloneMatch );
-      if ( ! handleTriggerObjectStandAloneMatch.isValid() ) {
-        LogError( "triggerMatchValid" ) << "pat::TriggerObjectStandAloneMatch product with InputTag '" << labelTriggerObjectMatcher << "' not in event";
-        continue;
-      }
-      AssociativeIterator< reco::CandidateBaseRef, TriggerObjectStandAloneMatch > it( *handleTriggerObjectStandAloneMatch, EdmEventItemGetter< reco::CandidateBaseRef >( iEvent ) ), itEnd( it.end() );
-      Handle< reco::CandidateView > handleCands;
-      if ( it != itEnd ) iEvent.get( it->first.id(), handleCands );
-      std::vector< int > indices;
-      while ( it != itEnd ) {
-        indices.push_back( it->second.key() );
-        ++it;
-      }
-      std::auto_ptr< TriggerObjectMatch > triggerObjectMatch( new TriggerObjectMatch( handleTriggerObjects ) );
-      TriggerObjectMatch::Filler matchFiller( *triggerObjectMatch );
-      if ( handleCands.isValid() ) {
-        matchFiller.insert( handleCands, indices.begin(), indices.end() );
-      }
-      matchFiller.fill();
-      OrphanHandle< TriggerObjectMatch > handleTriggerObjectMatch( iEvent.put( triggerObjectMatch, labelTriggerObjectMatcher ) );
-      // set product reference to trigger match association
-      if ( ! handleTriggerObjectMatch.isValid() ) {
-        LogError( "triggerMatchValid" ) << "pat::TriggerObjectMatch product with InputTag '" << labelTriggerObjectMatcher << "' not in event";
-        continue;
-      }
-      if ( ! ( triggerEvent->addObjectMatchResult( handleTriggerObjectMatch, labelTriggerObjectMatcher ) ) ) {
-        LogWarning( "triggerObjectMatchReplication" ) << "pat::TriggerEvent contains already a pat::TriggerObjectMatch from matcher module '" << labelTriggerObjectMatcher << "'";
-      }
-    }
-  }
-
-  iEvent.put( triggerEvent );
-
-}
-
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-DEFINE_FWK_MODULE( PATTriggerEventProducer );
diff --git a/PhysicsTools/PatAlgos/plugins/PATTriggerEventProducer.h b/PhysicsTools/PatAlgos/plugins/PATTriggerEventProducer.h
deleted file mode 100644
index 541ceff..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATTriggerEventProducer.h
+++ /dev/null
@@ -1,83 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_PATTriggerEventProducer_h
-#define PhysicsTools_PatAlgos_PATTriggerEventProducer_h
-
-
-// -*- C++ -*-
-//
-// Package:    PatAlgos
-// Class:      pat::PATTriggerEventProducer
-//
-// $Id: PATTriggerEventProducer.h,v 1.11 2010/11/27 15:16:20 vadler Exp $
-//
-/**
-  \class    pat::PATTriggerEventProducer PATTriggerEventProducer.h "PhysicsTools/PatAlgos/plugins/PATTriggerEventProducer.h"
-  \brief    Produces the central entry point to full PAT trigger information
-
-   This producer extract general trigger and conditions information from
-   - the edm::TriggerResults written by the HLT process,
-   - the ConditionsInEdm products,
-   - the process history and
-   - the GlobalTrigger information in the event and the event setup
-   and writes it together with links to the full PAT trigger information collections and PAT trigger match results to
-   - the pat::TriggerEvent
-
-   For me information, s.
-   https://twiki.cern.ch/twiki/bin/view/CMS/SWGuidePATTrigger
-
-  \author   Volker Adler
-  \version  $Id: PATTriggerEventProducer.h,v 1.11 2010/11/27 15:16:20 vadler Exp $
-*/
-
-
-#include "FWCore/Framework/interface/Frameworkfwd.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-
-#include <string>
-#include <vector>
-
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "DataFormats/Common/interface/ConditionsInEdm.h"
-#include "HLTrigger/HLTcore/interface/HLTConfigProvider.h"
-
-
-namespace pat {
-
-  class PATTriggerEventProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATTriggerEventProducer( const edm::ParameterSet & iConfig );
-      ~PATTriggerEventProducer() {};
-
-    private:
-
-      virtual void beginRun( edm::Run & iRun, const edm::EventSetup & iSetup );
-      virtual void beginLuminosityBlock( edm::LuminosityBlock & iLumi, const edm::EventSetup & iSetup );
-      virtual void produce( edm::Event & iEvent, const edm::EventSetup & iSetup );
-
-      std::string                  nameProcess_;        // configuration
-      bool                         autoProcessName_;
-      edm::InputTag                tagTriggerProducer_; // configuration (optional with default)
-      std::vector< edm::InputTag > tagsTriggerMatcher_; // configuration (optional)
-      // L1
-      edm::InputTag                tagL1Gt_;            // configuration (optional with default)
-      // HLT
-      HLTConfigProvider            hltConfig_;
-      bool                         hltConfigInit_;
-      edm::InputTag                tagTriggerResults_;  // configuration (optional with default)
-      edm::InputTag                tagTriggerEvent_;    // configuration (optional with default)
-      // Conditions
-      edm::InputTag                tagCondGt_;          // configuration (optional with default)
-      edm::ConditionsInRunBlock    condRun_;
-      edm::ConditionsInLumiBlock   condLumi_;
-      bool                         gtCondRunInit_;
-      bool                         gtCondLumiInit_;
-
-  };
-
-}
-
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATTriggerMatchEmbedder.cc b/PhysicsTools/PatAlgos/plugins/PATTriggerMatchEmbedder.cc
deleted file mode 100644
index 95f7392..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATTriggerMatchEmbedder.cc
+++ /dev/null
@@ -1,122 +0,0 @@
-// -*- C++ -*-
-//
-// Package:    PatAlgos
-// Class:      pat::PATTriggerMatchEmbedder
-//
-/**
-  \class    pat::PATTriggerMatchEmbedder PATTriggerMatchEmbedder.cc "PhysicsTools/PatAlgos/plugins/PATTriggerMatchEmbedder.cc"
-  \brief
-
-   .
-
-  \author   Volker Adler
-  \version  $Id: PATTriggerMatchEmbedder.cc,v 1.6 2010/09/02 17:52:47 vadler Exp $
-*/
-//
-// $Id: PATTriggerMatchEmbedder.cc,v 1.6 2010/09/02 17:52:47 vadler Exp $
-//
-
-
-#include <vector>
-
-#include "FWCore/Framework/interface/Frameworkfwd.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "DataFormats/Common/interface/Handle.h"
-#include "DataFormats/Common/interface/RefToBase.h"
-
-#include "DataFormats/PatCandidates/interface/Electron.h"
-#include "DataFormats/PatCandidates/interface/Jet.h"
-#include "DataFormats/PatCandidates/interface/MET.h"
-#include "DataFormats/PatCandidates/interface/Muon.h"
-#include "DataFormats/PatCandidates/interface/Photon.h"
-#include "DataFormats/PatCandidates/interface/Tau.h"
-
-
-namespace pat {
-
-  template< class PATObjectType >
-  class PATTriggerMatchEmbedder : public edm::EDProducer {
-
-      edm::InputTag src_;
-      std::vector< edm::InputTag > matches_;
-
-    public:
-
-      explicit PATTriggerMatchEmbedder( const edm::ParameterSet & iConfig );
-      ~PATTriggerMatchEmbedder() {};
-
-    private:
-
-      virtual void produce( edm::Event & iEvent, const edm::EventSetup & iSetup );
-
-  };
-
-  typedef PATTriggerMatchEmbedder< Electron > PATTriggerMatchElectronEmbedder;
-  typedef PATTriggerMatchEmbedder< Jet >      PATTriggerMatchJetEmbedder;
-  typedef PATTriggerMatchEmbedder< MET >      PATTriggerMatchMETEmbedder;
-  typedef PATTriggerMatchEmbedder< Muon >     PATTriggerMatchMuonEmbedder;
-  typedef PATTriggerMatchEmbedder< Photon >   PATTriggerMatchPhotonEmbedder;
-  typedef PATTriggerMatchEmbedder< Tau >      PATTriggerMatchTauEmbedder;
-
-}
-
-
-using namespace pat;
-
-
-template< class PATObjectType >
-PATTriggerMatchEmbedder< PATObjectType >::PATTriggerMatchEmbedder( const edm::ParameterSet & iConfig ) :
-  src_( iConfig.getParameter< edm::InputTag >( "src" ) ),
-  matches_( iConfig.getParameter< std::vector< edm::InputTag > >( "matches" ) )
-{
-  produces< std::vector< PATObjectType > >();
-}
-
-template< class PATObjectType >
-void PATTriggerMatchEmbedder< PATObjectType >::produce( edm::Event & iEvent, const edm::EventSetup & iSetup )
-{
-  std::auto_ptr< std::vector< PATObjectType > > output( new std::vector< PATObjectType >() );
-
-  edm::Handle< edm::View< PATObjectType > > candidates;
-  iEvent.getByLabel( src_, candidates );
-  if ( ! candidates.isValid() ) {
-    edm::LogError( "missingInputSource" ) << "Input source with InputTag " << src_.encode() << " not in event.";
-    return;
-  }
-
-  for ( typename edm::View< PATObjectType >::const_iterator iCand = candidates->begin(); iCand != candidates->end(); ++iCand ) {
-    const unsigned index( iCand - candidates->begin() );
-    PATObjectType cand( candidates->at( index ) );
-    std::set< TriggerObjectStandAloneRef > cachedRefs;
-    for ( size_t iMatch = 0; iMatch < matches_.size(); ++iMatch ) {
-      edm::Handle< TriggerObjectStandAloneMatch > match;
-      iEvent.getByLabel( matches_.at( iMatch ), match );
-      if ( ! match.isValid() ) {
-        edm::LogError( "missingInputMatch" ) << "Input match with InputTag " << matches_.at( iMatch ).encode() << " not in event.";
-        continue;
-      }
-      const TriggerObjectStandAloneRef trigRef( ( *match )[ candidates->refAt( index ) ] );
-      if ( trigRef.isNonnull() && trigRef.isAvailable() ) {
-        if ( cachedRefs.insert( trigRef ).second ) { // protection from multiple entries of the same trigger objects
-          cand.addTriggerObjectMatch( *trigRef );
-        }
-      }
-    }
-    output->push_back( cand );
-  }
-
-  iEvent.put( output );
-}
-
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE( PATTriggerMatchElectronEmbedder );
-DEFINE_FWK_MODULE( PATTriggerMatchJetEmbedder );
-DEFINE_FWK_MODULE( PATTriggerMatchMETEmbedder );
-DEFINE_FWK_MODULE( PATTriggerMatchMuonEmbedder );
-DEFINE_FWK_MODULE( PATTriggerMatchPhotonEmbedder );
-DEFINE_FWK_MODULE( PATTriggerMatchTauEmbedder );
diff --git a/PhysicsTools/PatAlgos/plugins/PATTriggerMatchSelector.h b/PhysicsTools/PatAlgos/plugins/PATTriggerMatchSelector.h
deleted file mode 100644
index 9e71166..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATTriggerMatchSelector.h
+++ /dev/null
@@ -1,53 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_PATTriggerMatchSelector_h
-#define PhysicsTools_PatAlgos_PATTriggerMatchSelector_h
-
-
-// -*- C++ -*-
-//
-// Package:    PatAlgos
-// Class:      PATTriggerMatchSelector
-//
-/**
-  \class    pat::PATTriggerMatchSelector PATTriggerMatchSelector.h "PhysicsTools/PatAlgos/plugins/PATTriggerMatchSelector.h"
-  \brief
-
-   .
-
-  \author   Volker Adler
-  \version  $Id: PATTriggerMatchSelector.h,v 1.6 2010/12/11 22:12:59 vadler Exp $
-*/
-//
-// $Id: PATTriggerMatchSelector.h,v 1.6 2010/12/11 22:12:59 vadler Exp $
-//
-
-
-#include <string>
-#include <vector>
-#include <map>
-
-#include "CommonTools/Utils/interface/StringCutObjectSelector.h"
-
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-
-namespace pat {
-
-  template< typename T1, typename T2 >
-  class PATTriggerMatchSelector : public StringCutObjectSelector< T2 > {
-
-    public:
-
-      PATTriggerMatchSelector( const edm::ParameterSet & iConfig ) :
-        StringCutObjectSelector< T2 >( iConfig.getParameter< std::string >( "matchedCuts" ) )
-      {}
-
-      bool operator()( const T1 & patObj, const T2 & trigObj ) const {
-        return StringCutObjectSelector< T2 >::operator()( trigObj );
-      }
-
-  };
-
-}
-
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/PATTriggerMatcher.cc b/PhysicsTools/PatAlgos/plugins/PATTriggerMatcher.cc
deleted file mode 100644
index 9d14638..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATTriggerMatcher.cc
+++ /dev/null
@@ -1,87 +0,0 @@
-//
-// $Id: PATTriggerMatcher.cc,v 1.8 2010/06/26 17:53:57 vadler Exp $
-//
-#include "PhysicsTools/PatAlgos/plugins/PATTriggerMatchSelector.h"
-#include "CommonTools/UtilAlgos/interface/PhysObjectMatcher.h"
-#include "CommonTools/UtilAlgos/interface/MatchByDR.h"
-#include "CommonTools/UtilAlgos/interface/MatchByDRDPt.h"
-#include "CommonTools/UtilAlgos/interface/MatchLessByDPt.h"
-#include "CommonTools/UtilAlgos/interface/MatchByDEta.h"
-#include "CommonTools/UtilAlgos/interface/MatchLessByDEta.h"
-
-#include "DataFormats/Candidate/interface/Candidate.h"
-#include "DataFormats/PatCandidates/interface/TriggerObjectStandAlone.h"
-
-
-/// Match by deltaR (default), ranking by deltaR (default)
-typedef reco::PhysObjectMatcher<
-  reco::CandidateView,
-  pat::TriggerObjectStandAloneCollection,
-  pat::PATTriggerMatchSelector< reco::CandidateView::value_type,
-                                pat::TriggerObjectStandAloneCollection::value_type >
-> PATTriggerMatcherDRLessByR;
-
-/// Match by deltaR and deltaPt, ranking by deltaR (default)
-typedef reco::PhysObjectMatcher<
-  reco::CandidateView,
-  pat::TriggerObjectStandAloneCollection,
-  pat::PATTriggerMatchSelector< reco::CandidateView::value_type,
-                                pat::TriggerObjectStandAloneCollection::value_type>,
-  reco::MatchByDRDPt< reco::CandidateView::value_type,
-                      pat::TriggerObjectStandAloneCollection::value_type >
-> PATTriggerMatcherDRDPtLessByR;
-
-/// Match by deltaR (default), ranking by deltaPt
-typedef reco::PhysObjectMatcher<
-  reco::CandidateView,
-  pat::TriggerObjectStandAloneCollection,
-  pat::PATTriggerMatchSelector< reco::CandidateView::value_type,
-                                pat::TriggerObjectStandAloneCollection::value_type >,
-  reco::MatchByDR< reco::CandidateView::value_type,
-                   pat::TriggerObjectStandAloneCollection::value_type >,
-  reco::MatchLessByDPt< reco::CandidateView,
-                        pat::TriggerObjectStandAloneCollection >
-> PATTriggerMatcherDRLessByPt;
-
-/// Match by deltaR and deltaPt, ranking by deltaPt
-typedef reco::PhysObjectMatcher<
-  reco::CandidateView,
-  pat::TriggerObjectStandAloneCollection,
-  pat::PATTriggerMatchSelector<reco::CandidateView::value_type,
-                               pat::TriggerObjectStandAloneCollection::value_type >,
-  reco::MatchByDRDPt< reco::CandidateView::value_type,
-                      pat::TriggerObjectStandAloneCollection::value_type >,
-  reco::MatchLessByDPt< reco::CandidateView,
-                        pat::TriggerObjectStandAloneCollection >
-> PATTriggerMatcherDRDPtLessByPt;
-
-/// Match by deltaEta, ranking by deltaR
-typedef reco::PhysObjectMatcher<
-  reco::CandidateView,
-  pat::TriggerObjectStandAloneCollection,
-  pat::PATTriggerMatchSelector< reco::CandidateView::value_type,
-                                pat::TriggerObjectStandAloneCollection::value_type >,
-  reco::MatchByDEta< reco::CandidateView::value_type,
-                     pat::TriggerObjectStandAloneCollection::value_type >
-> PATTriggerMatcherDEtaLessByDR;
-
-/// Match by deltaEta, ranking by deltaEta
-typedef reco::PhysObjectMatcher<
-  reco::CandidateView,
-  pat::TriggerObjectStandAloneCollection,
-  pat::PATTriggerMatchSelector< reco::CandidateView::value_type,
-                                pat::TriggerObjectStandAloneCollection::value_type >,
-  reco::MatchByDEta< reco::CandidateView::value_type,
-                     pat::TriggerObjectStandAloneCollection::value_type >,
-  reco::MatchLessByDEta< reco::CandidateView,
-                         pat::TriggerObjectStandAloneCollection >
-> PATTriggerMatcherDEtaLessByDEta;
-
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-DEFINE_FWK_MODULE( PATTriggerMatcherDRLessByR );
-DEFINE_FWK_MODULE( PATTriggerMatcherDRDPtLessByR );
-DEFINE_FWK_MODULE( PATTriggerMatcherDRLessByPt );
-DEFINE_FWK_MODULE( PATTriggerMatcherDRDPtLessByPt );
-DEFINE_FWK_MODULE( PATTriggerMatcherDEtaLessByDR );
-DEFINE_FWK_MODULE( PATTriggerMatcherDEtaLessByDEta );
diff --git a/PhysicsTools/PatAlgos/plugins/PATTriggerProducer.cc b/PhysicsTools/PatAlgos/plugins/PATTriggerProducer.cc
deleted file mode 100644
index 73c1ad0..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATTriggerProducer.cc
+++ /dev/null
@@ -1,979 +0,0 @@
-//
-// $Id: PATTriggerProducer.cc,v 1.34.4.3 2012/10/25 00:20:47 vadler Exp $
-//
-
-
-#include "PhysicsTools/PatAlgos/plugins/PATTriggerProducer.h"
-
-#include <vector>
-#include <map>
-#include <utility>
-#include <cassert>
-#include <string>
-
-#include "CondFormats/L1TObjects/interface/L1GtTriggerMenu.h"
-#include "CondFormats/DataRecord/interface/L1GtTriggerMenuRcd.h"
-#include "DataFormats/Common/interface/Handle.h"
-#include "DataFormats/L1GlobalTrigger/interface/L1GlobalTriggerReadoutSetup.h"
-#include "DataFormats/L1GlobalTrigger/interface/L1GlobalTriggerReadoutRecord.h"
-#include "DataFormats/L1GlobalTrigger/interface/L1GlobalTriggerObjectMaps.h"
-#include "DataFormats/Common/interface/TriggerResults.h"
-#include "DataFormats/HLTReco/interface/TriggerEvent.h"
-#include "DataFormats/Provenance/interface/ProcessHistory.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/Registry.h"
-
-#include "DataFormats/PatCandidates/interface/TriggerAlgorithm.h"
-#include "DataFormats/PatCandidates/interface/TriggerCondition.h"
-#include "DataFormats/PatCandidates/interface/TriggerPath.h"
-#include "DataFormats/PatCandidates/interface/TriggerFilter.h"
-#include "DataFormats/PatCandidates/interface/TriggerObjectStandAlone.h"
-
-#include "FWCore/Framework/interface/ESHandle.h"
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-
-using namespace pat;
-using namespace edm;
-
-
-// Constants' definitions
-const unsigned L1GlobalTriggerReadoutSetup::NumberPhysTriggers;
-const unsigned L1GlobalTriggerReadoutSetup::NumberPhysTriggersExtended;
-const unsigned L1GlobalTriggerReadoutSetup::NumberTechnicalTriggers;
-static const bool useL1EventSetup( true );
-static const bool useL1GtTriggerMenuLite( false );
-
-
-PATTriggerProducer::PATTriggerProducer( const ParameterSet & iConfig ) :
-  nameProcess_( iConfig.getParameter< std::string >( "processName" ) ),
-  autoProcessName_( nameProcess_ == "*" ),
-  onlyStandAlone_( iConfig.getParameter< bool >( "onlyStandAlone" ) ),
-  firstInRun_( true ),
-  // L1 configuration parameters
-  addL1Algos_( false ),
-  tagL1GlobalTriggerObjectMaps_( "l1L1GtObjectMap" ),
-  tagL1ExtraMu_(),
-  tagL1ExtraNoIsoEG_(),
-  tagL1ExtraIsoEG_(),
-  tagL1ExtraCenJet_(),
-  tagL1ExtraForJet_(),
-  tagL1ExtraTauJet_(),
-  tagL1ExtraETM_(),
-  tagL1ExtraHTM_(),
-  autoProcessNameL1ExtraMu_( false ),
-  autoProcessNameL1ExtraNoIsoEG_( false ),
-  autoProcessNameL1ExtraIsoEG_( false ),
-  autoProcessNameL1ExtraCenJet_( false ),
-  autoProcessNameL1ExtraForJet_( false ),
-  autoProcessNameL1ExtraTauJet_( false ),
-  autoProcessNameL1ExtraETM_( false ),
-  autoProcessNameL1ExtraHTM_( false ),
-  mainBxOnly_( true ),
-  saveL1Refs_( false ),
-  // HLTConfigProvider
-  hltConfigInit_( false ),
-  // HLT configuration parameters
-  tagTriggerResults_( "TriggerResults" ),
-  tagTriggerEvent_( "hltTriggerSummaryAOD" ),
-  hltPrescaleLabel_(),
-  labelHltPrescaleTable_(),
-  hltPrescaleTableRun_(),
-  hltPrescaleTableLumi_(),
-  addPathModuleLabels_( false )
-{
-
-  // L1 configuration parameters
-  if ( iConfig.exists( "addL1Algos" ) ) addL1Algos_ = iConfig.getParameter< bool >( "addL1Algos" );
-  if ( iConfig.exists( "l1GlobalTriggerObjectMaps" ) ) tagL1GlobalTriggerObjectMaps_ = iConfig.getParameter< InputTag >( "l1GlobalTriggerObjectMaps" );
-  if ( iConfig.exists( "l1ExtraMu" ) ) {
-    tagL1ExtraMu_ = iConfig.getParameter< InputTag >( "l1ExtraMu" );
-    if ( tagL1ExtraMu_.process() == "*" ) {
-      if ( autoProcessName_ ) autoProcessNameL1ExtraMu_ = true;
-      else                    tagL1ExtraMu_ = InputTag( tagL1ExtraMu_.label(), tagL1ExtraMu_.instance(), nameProcess_ );
-    }
-  }
-  if ( iConfig.exists( "l1ExtraNoIsoEG" ) ) {
-    tagL1ExtraNoIsoEG_ = iConfig.getParameter< InputTag >( "l1ExtraNoIsoEG" );
-    if ( tagL1ExtraNoIsoEG_.process() == "*" ) {
-      if ( autoProcessName_ ) autoProcessNameL1ExtraNoIsoEG_ = true;
-      else                    tagL1ExtraNoIsoEG_ = InputTag( tagL1ExtraNoIsoEG_.label(), tagL1ExtraNoIsoEG_.instance(), nameProcess_ );
-    }
-  }
-  if ( iConfig.exists( "l1ExtraIsoEG" ) ) {
-    tagL1ExtraIsoEG_ = iConfig.getParameter< InputTag >( "l1ExtraIsoEG" );
-    if ( tagL1ExtraIsoEG_.process() == "*" ) {
-      if ( autoProcessName_ ) autoProcessNameL1ExtraIsoEG_ = true;
-      else                    tagL1ExtraIsoEG_ = InputTag( tagL1ExtraIsoEG_.label(), tagL1ExtraIsoEG_.instance(), nameProcess_ );
-    }
-  }
-  if ( iConfig.exists( "l1ExtraCenJet" ) ) {
-    tagL1ExtraCenJet_ = iConfig.getParameter< InputTag >( "l1ExtraCenJet" );
-    if ( tagL1ExtraCenJet_.process() == "*" ) {
-      if ( autoProcessName_ ) autoProcessNameL1ExtraCenJet_ = true;
-      else                    tagL1ExtraCenJet_ = InputTag( tagL1ExtraCenJet_.label(), tagL1ExtraCenJet_.instance(), nameProcess_ );
-    }
-  }
-  if ( iConfig.exists( "l1ExtraForJet" ) ) {
-    tagL1ExtraForJet_ = iConfig.getParameter< InputTag >( "l1ExtraForJet" );
-    if ( tagL1ExtraForJet_.process() == "*" ) {
-      if ( autoProcessName_ ) autoProcessNameL1ExtraForJet_ = true;
-      else                    tagL1ExtraForJet_ = InputTag( tagL1ExtraForJet_.label(), tagL1ExtraForJet_.instance(), nameProcess_ );
-    }
-  }
-  if ( iConfig.exists( "l1ExtraTauJet" ) ) {
-    tagL1ExtraTauJet_ = iConfig.getParameter< InputTag >( "l1ExtraTauJet" );
-    if ( tagL1ExtraTauJet_.process() == "*" ) {
-      if ( autoProcessName_ ) autoProcessNameL1ExtraTauJet_ = true;
-      else                    tagL1ExtraTauJet_ = InputTag( tagL1ExtraTauJet_.label(), tagL1ExtraTauJet_.instance(), nameProcess_ );
-    }
-  }
-  if ( iConfig.exists( "l1ExtraETM" ) ) {
-    tagL1ExtraETM_ = iConfig.getParameter< InputTag >( "l1ExtraETM" );
-    if ( tagL1ExtraETM_.process() == "*" ) {
-      if ( autoProcessName_ ) autoProcessNameL1ExtraETM_ = true;
-      else                    tagL1ExtraETM_ = InputTag( tagL1ExtraETM_.label(), tagL1ExtraETM_.instance(), nameProcess_ );
-    }
-  }
-  if ( iConfig.exists( "l1ExtraHTM" ) ) {
-    tagL1ExtraHTM_ = iConfig.getParameter< InputTag >( "l1ExtraHTM" );
-    if ( tagL1ExtraHTM_.process() == "*" ) {
-      if ( autoProcessName_ ) autoProcessNameL1ExtraHTM_ = true;
-      else                    tagL1ExtraHTM_ = InputTag( tagL1ExtraHTM_.label(), tagL1ExtraHTM_.instance(), nameProcess_ );
-    }
-  }
-  if ( iConfig.exists( "mainBxOnly" ) ) mainBxOnly_ = iConfig.getParameter< bool >( "mainBxOnly" );
-  if ( iConfig.exists( "saveL1Refs" ) ) saveL1Refs_ = iConfig.getParameter< bool >( "saveL1Refs" );
-
-  // HLT configuration parameters
-  if ( iConfig.exists( "triggerResults" ) )      tagTriggerResults_     = iConfig.getParameter< InputTag >( "triggerResults" );
-  if ( iConfig.exists( "triggerEvent" ) )        tagTriggerEvent_       = iConfig.getParameter< InputTag >( "triggerEvent" );
-  if ( iConfig.exists( "hltPrescaleLabel" ) )    hltPrescaleLabel_      = iConfig.getParameter< std::string >( "hltPrescaleLabel" );
-  if ( iConfig.exists( "hltPrescaleTable" ) )    labelHltPrescaleTable_ = iConfig.getParameter< std::string >( "hltPrescaleTable" );
-  if ( iConfig.exists( "addPathModuleLabels" ) ) addPathModuleLabels_   = iConfig.getParameter< bool >( "addPathModuleLabels" );
-  exludeCollections_.clear();
-  if ( iConfig.exists( "exludeCollections" )  ) exludeCollections_      = iConfig.getParameter< std::vector< std::string > >( "exludeCollections" );
-
-  if ( ! onlyStandAlone_ ) {
-    produces< TriggerAlgorithmCollection >();
-    produces< TriggerConditionCollection >();
-    produces< TriggerPathCollection >();
-    produces< TriggerFilterCollection >();
-    produces< TriggerObjectCollection >();
-  }
-  produces< TriggerObjectStandAloneCollection >();
-
-}
-
-
-void PATTriggerProducer::beginRun( Run & iRun, const EventSetup & iSetup )
-{
-
-  // Initialize
-  firstInRun_    = true;
-  l1PSet_        = 0;
-  hltConfigInit_ = false;
-
-  // Initialize process name
-  if ( autoProcessName_ ) {
-    // reset
-    nameProcess_ = "*";
-    // determine process name from last run TriggerSummaryProducerAOD module in process history of input
-    const ProcessHistory & processHistory( iRun.processHistory() );
-    ProcessConfiguration processConfiguration;
-    ParameterSet processPSet;
-    // unbroken loop, which relies on time ordering (accepts the last found entry)
-    for ( ProcessHistory::const_iterator iHist = processHistory.begin(); iHist != processHistory.end(); ++iHist ) {
-      if ( processHistory.getConfigurationForProcess( iHist->processName(), processConfiguration )     &&
-           pset::Registry::instance()->getMapped( processConfiguration.parameterSetID(), processPSet ) &&
-           processPSet.exists( tagTriggerEvent_.label() )
-         ) {
-        nameProcess_ = iHist->processName();
-        LogDebug( "autoProcessName" ) << "HLT process name '" << nameProcess_ << "' discovered";
-      }
-    }
-    // terminate, if nothing is found
-    if ( nameProcess_ == "*" ) {
-      LogError( "autoProcessName" ) << "trigger::TriggerEvent product with label '" << tagTriggerEvent_.label() << "' not produced according to process history of input data\n"
-                                    << "No trigger information produced";
-      return;
-    }
-    LogInfo( "autoProcessName" ) << "HLT process name' " << nameProcess_ << "' used for PAT trigger information";
-  }
-  // adapt configuration of used input tags
-  if ( tagTriggerResults_.process().empty() || tagTriggerResults_.process() == "*" ) {
-    tagTriggerResults_ = InputTag( tagTriggerResults_.label(), tagTriggerResults_.instance(), nameProcess_ );
-  } else if ( tagTriggerEvent_.process() != nameProcess_ ) {
-    LogWarning( "inputTags" ) << "TriggerResults process name '" << tagTriggerResults_.process() << "' differs from HLT process name '" << nameProcess_ << "'";
-  }
-  if ( tagTriggerEvent_.process().empty() || tagTriggerEvent_.process()   == "*" ) {
-    tagTriggerEvent_ = InputTag( tagTriggerEvent_.label(), tagTriggerEvent_.instance(), nameProcess_ );
-  } else if ( tagTriggerEvent_.process() != nameProcess_ ) {
-    LogWarning( "inputTags" ) << "TriggerEvent process name '" << tagTriggerEvent_.process() << "' differs from HLT process name '" << nameProcess_ << "'";
-  }
-  if ( autoProcessNameL1ExtraMu_ )      tagL1ExtraMu_      = InputTag( tagL1ExtraMu_.label()     , tagL1ExtraMu_.instance()     , nameProcess_ );
-  if ( autoProcessNameL1ExtraNoIsoEG_ ) tagL1ExtraNoIsoEG_ = InputTag( tagL1ExtraNoIsoEG_.label(), tagL1ExtraNoIsoEG_.instance(), nameProcess_ );
-  if ( autoProcessNameL1ExtraIsoEG_ )   tagL1ExtraIsoEG_   = InputTag( tagL1ExtraIsoEG_.label()  , tagL1ExtraIsoEG_.instance()  , nameProcess_ );
-  if ( autoProcessNameL1ExtraCenJet_ )  tagL1ExtraCenJet_  = InputTag( tagL1ExtraCenJet_.label() , tagL1ExtraCenJet_.instance() , nameProcess_ );
-  if ( autoProcessNameL1ExtraForJet_ )  tagL1ExtraForJet_  = InputTag( tagL1ExtraForJet_.label() , tagL1ExtraForJet_.instance() , nameProcess_ );
-  if ( autoProcessNameL1ExtraTauJet_ )  tagL1ExtraTauJet_  = InputTag( tagL1ExtraTauJet_.label() , tagL1ExtraTauJet_.instance() , nameProcess_ );
-  if ( autoProcessNameL1ExtraETM_ )     tagL1ExtraETM_     = InputTag( tagL1ExtraETM_.label()    , tagL1ExtraETM_.instance()    , nameProcess_ );
-  if ( autoProcessNameL1ExtraHTM_ )     tagL1ExtraHTM_     = InputTag( tagL1ExtraHTM_.label()    , tagL1ExtraHTM_.instance()    , nameProcess_ );
-
-  // Initialize HLTConfigProvider
-  bool changed( true );
-  if ( ! hltConfig_.init( iRun, iSetup, nameProcess_, changed ) ) {
-    LogError( "hltConfig" ) << "HLT config extraction error with process name '" << nameProcess_ << "'";
-  } else if ( hltConfig_.size() <= 0 ) {
-    LogError( "hltConfig" ) << "HLT config size error";
-  } else hltConfigInit_ = true;
-
-  // Update mapping from filter names to path names
-  if (hltConfigInit_ && changed) moduleLabelToPathAndFlags_.init( hltConfig_ );
-
-  // Extract pre-scales
-  if ( hltConfigInit_ ) {
-    // Start empty
-    hltPrescaleTableRun_ = trigger::HLTPrescaleTable();
-    // Try run product, if configured
-    if ( ! labelHltPrescaleTable_.empty() ) {
-      Handle< trigger::HLTPrescaleTable > handleHltPrescaleTable;
-      iRun.getByLabel( InputTag( labelHltPrescaleTable_, "Run", nameProcess_ ), handleHltPrescaleTable );
-      if ( handleHltPrescaleTable.isValid() ) {
-        hltPrescaleTableRun_ = trigger::HLTPrescaleTable( handleHltPrescaleTable->set(), handleHltPrescaleTable->labels(), handleHltPrescaleTable->table() );
-      }
-    }
-  }
-
-}
-
-
-void PATTriggerProducer::beginLuminosityBlock( LuminosityBlock & iLuminosityBlock, const EventSetup & iSetup )
-{
-
-  // Terminate, if auto process name determination failed
-  if ( nameProcess_ == "*" ) return;
-
-  // Extract pre-scales
-  if ( hltConfigInit_ ) {
-    // Start from run
-    hltPrescaleTableLumi_ = trigger::HLTPrescaleTable( hltPrescaleTableRun_.set(), hltPrescaleTableRun_.labels(), hltPrescaleTableRun_.table() );
-    // Try lumi product, if configured and available
-    if ( ! labelHltPrescaleTable_.empty() ) {
-      Handle< trigger::HLTPrescaleTable > handleHltPrescaleTable;
-      iLuminosityBlock.getByLabel( InputTag( labelHltPrescaleTable_, "Lumi", nameProcess_ ), handleHltPrescaleTable );
-      if ( handleHltPrescaleTable.isValid() ) {
-        hltPrescaleTableLumi_ = trigger::HLTPrescaleTable( handleHltPrescaleTable->set(), handleHltPrescaleTable->labels(), handleHltPrescaleTable->table() );
-      }
-    }
-  }
-
-}
-
-
-void PATTriggerProducer::produce( Event& iEvent, const EventSetup& iSetup )
-{
-
-  // Terminate, if auto process name determination failed
-  if ( nameProcess_ == "*" ) return;
-
-  std::auto_ptr< TriggerObjectCollection > triggerObjects( new TriggerObjectCollection() );
-  std::auto_ptr< TriggerObjectStandAloneCollection > triggerObjectsStandAlone( new TriggerObjectStandAloneCollection() );
-
-  // HLT
-
-  // Get and check HLT event data
-  Handle< trigger::TriggerEvent > handleTriggerEvent;
-  iEvent.getByLabel( tagTriggerEvent_, handleTriggerEvent );
-  Handle< TriggerResults > handleTriggerResults;
-  iEvent.getByLabel( tagTriggerResults_, handleTriggerResults );
-  bool goodHlt( hltConfigInit_ );
-  if ( goodHlt ) {
-    if( ! handleTriggerResults.isValid() ) {
-      LogError( "triggerResultsValid" ) << "TriggerResults product with InputTag '" << tagTriggerResults_.encode() << "' not in event\n"
-                                        << "No HLT information produced";
-      goodHlt = false;
-    } else if ( ! handleTriggerEvent.isValid() ) {
-      LogError( "triggerEventValid" ) << "trigger::TriggerEvent product with InputTag '" << tagTriggerEvent_.encode() << "' not in event\n"
-                                      << "No HLT information produced";
-      goodHlt = false;
-    }
-  }
-
-  // Produce HLT paths and determine status of modules
-
-  if ( goodHlt ) {
-
-    // Extract pre-scales
-    // Start from lumi
-    trigger::HLTPrescaleTable hltPrescaleTable( hltPrescaleTableLumi_.set(), hltPrescaleTableLumi_.labels(), hltPrescaleTableLumi_.table() );
-    // Try event product, if configured and available
-    if ( ! labelHltPrescaleTable_.empty() ) {
-      Handle< trigger::HLTPrescaleTable > handleHltPrescaleTable;
-      iEvent.getByLabel( InputTag( labelHltPrescaleTable_, "Event", nameProcess_ ), handleHltPrescaleTable );
-      if ( handleHltPrescaleTable.isValid() ) {
-        hltPrescaleTable = trigger::HLTPrescaleTable( handleHltPrescaleTable->set(), handleHltPrescaleTable->labels(), handleHltPrescaleTable->table() );
-      }
-    }
-    // Try event setup, if no product
-    if ( hltPrescaleTable.size() == 0 ) {
-      if ( ! labelHltPrescaleTable_.empty() ) {
-        LogWarning( "hltPrescaleInputTag" ) << "HLTPrescaleTable product with label '" << labelHltPrescaleTable_ << "' not found in process" << nameProcess_ << "\n"
-                                            << "Using default from event setup";
-      }
-      if ( hltConfig_.prescaleSize() > 0 ) {
-        if ( hltConfig_.prescaleSet( iEvent, iSetup ) != -1 ) {
-          hltPrescaleTable = trigger::HLTPrescaleTable( hltConfig_.prescaleSet( iEvent, iSetup ), hltConfig_.prescaleLabels(), hltConfig_.prescaleTable() );
-          LogDebug( "hltPrescaleTable" ) << "HLT prescale table found in event setup";
-        } else {
-          LogWarning( "hltPrescaleSet" ) << "HLTPrescaleTable from event setup has error";
-        }
-      }
-    }
-    unsigned set( hltPrescaleTable.set() );
-    if ( hltPrescaleTable.size() > 0 ) {
-      if ( hltPrescaleLabel_.size() > 0 ) {
-        bool foundPrescaleLabel( false );
-        for ( unsigned iLabel = 0; iLabel <  hltPrescaleTable.labels().size(); ++iLabel ) {
-          if ( hltPrescaleTable.labels().at( iLabel ) == hltPrescaleLabel_ ) {
-            set                = iLabel;
-            foundPrescaleLabel = true;
-            break;
-          }
-        }
-        if ( ! foundPrescaleLabel ) {
-          LogWarning( "hltPrescaleLabel" ) << "HLT prescale label '" << hltPrescaleLabel_ << "' not in prescale table\n"
-                                           << "Using default";
-        }
-      }
-    } else if ( iEvent.isRealData() ) {
-      if ( ( labelHltPrescaleTable_.empty() && firstInRun_ ) || ! labelHltPrescaleTable_.empty() ) {
-        LogError( "hltPrescaleTable" ) << "No HLT prescale table found\n"
-                                       << "Using default empty table with all prescales 1";
-      }
-    }
-
-    const unsigned sizePaths( hltConfig_.size() );
-    const unsigned sizeFilters( handleTriggerEvent->sizeFilters() );
-    const unsigned sizeObjects( handleTriggerEvent->sizeObjects() );
-
-    std::map< std::string, int > moduleStates;
-
-    if ( ! onlyStandAlone_ ) {
-      std::auto_ptr< TriggerPathCollection > triggerPaths( new TriggerPathCollection() );
-      triggerPaths->reserve( sizePaths );
-      const std::vector<std::string> & pathNames = hltConfig_.triggerNames();
-      for ( size_t indexPath = 0; indexPath < sizePaths; ++indexPath ) {
-        const std::string & namePath = pathNames.at( indexPath );
-        unsigned indexLastFilterPathModules( handleTriggerResults->index( indexPath ) + 1 );
-        unsigned indexLastFilterFilters( sizeFilters );
-        while ( indexLastFilterPathModules > 0 ) {
-          --indexLastFilterPathModules;
-          const std::string & labelLastFilterPathModules( hltConfig_.moduleLabel( indexPath, indexLastFilterPathModules ) );
-          indexLastFilterFilters = handleTriggerEvent->filterIndex( InputTag( labelLastFilterPathModules, "", nameProcess_ ) );
-          if ( indexLastFilterFilters < sizeFilters ) {
-            if ( hltConfig_.moduleType( labelLastFilterPathModules ) == "HLTBool" ) continue;
-            break;
-          }
-        }
-        TriggerPath triggerPath( namePath, indexPath, hltConfig_.prescaleValue( set, namePath ), handleTriggerResults->wasrun( indexPath ), handleTriggerResults->accept( indexPath ), handleTriggerResults->error( indexPath ), indexLastFilterPathModules, hltConfig_.saveTagsModules( namePath ).size() );
-        // add module names to path and states' map
-        const unsigned sizeModulesPath( hltConfig_.size( indexPath ) );
-        assert( indexLastFilterPathModules < sizeModulesPath );
-        std::map< unsigned, std::string > indicesModules;
-        for ( size_t iM = 0; iM < sizeModulesPath; ++iM ) {
-          const std::string nameModule( hltConfig_.moduleLabel( indexPath, iM ) );
-          if ( addPathModuleLabels_ ) {
-            triggerPath.addModule( nameModule );
-          }
-          const unsigned indexFilter( handleTriggerEvent->filterIndex( InputTag( nameModule, "", nameProcess_ ) ) );
-          if ( indexFilter < sizeFilters ) {
-            triggerPath.addFilterIndex( indexFilter );
-          }
-          const unsigned slotModule( hltConfig_.moduleIndex( indexPath, nameModule ) );
-          indicesModules.insert( std::pair< unsigned, std::string >( slotModule, nameModule ) );
-        }
-        // add L1 seeds
-        const L1SeedCollection l1Seeds( hltConfig_.hltL1GTSeeds( namePath ) );
-        for ( L1SeedCollection::const_iterator iSeed = l1Seeds.begin(); iSeed != l1Seeds.end(); ++iSeed ) {
-          triggerPath.addL1Seed( *iSeed );
-        }
-        // store path
-        triggerPaths->push_back( triggerPath );
-        // cache module states to be used for the filters
-        for ( std::map< unsigned, std::string >::const_iterator iM = indicesModules.begin(); iM != indicesModules.end(); ++iM ) {
-          if ( iM->first < indexLastFilterPathModules ) {
-            moduleStates[ iM->second ] = 1;
-          } else if ( iM->first == indexLastFilterPathModules ) {
-            moduleStates[ iM->second ] = handleTriggerResults->accept( indexPath );
-          } else if ( moduleStates.find( iM->second ) == moduleStates.end() ) {
-            moduleStates[ iM->second ] = -1;
-          }
-        }
-      }
-      // Put HLT paths to event
-      iEvent.put( triggerPaths );
-    }
-
-    // Store used trigger objects and their types for HLT filters
-    // (only active filter(s) available from trigger::TriggerEvent)
-
-    std::multimap< trigger::size_type, int >         objectTypes;
-    std::multimap< trigger::size_type, std::string > filterLabels;
-
-    for ( size_t iF = 0; iF < sizeFilters; ++iF ) {
-      const std::string nameFilter( handleTriggerEvent->filterLabel( iF ) );
-      const trigger::Keys & keys  = handleTriggerEvent->filterKeys( iF );
-      const trigger::Vids & types = handleTriggerEvent->filterIds( iF );
-      assert( types.size() == keys.size() );
-      for ( size_t iK = 0; iK < keys.size(); ++iK ) {
-        filterLabels.insert( std::pair< trigger::size_type, std::string >( keys[ iK ], nameFilter ) );
-        objectTypes.insert( std::pair< trigger::size_type, int >( keys[ iK ], types[ iK ] ) );
-      }
-    }
-
-    // HLT objects
-
-    triggerObjects->reserve( onlyStandAlone_ ? 0 : sizeObjects );
-    triggerObjectsStandAlone->reserve( sizeObjects );
-
-    const trigger::Keys & collectionKeys( handleTriggerEvent->collectionKeys() );
-    std::map< trigger::size_type, trigger::size_type > newObjectKeys;
-    for ( size_t iO = 0, iC = 0, nC = handleTriggerEvent->sizeCollections(); iO < sizeObjects && iC < nC; ++iO ) {
-      const trigger::TriggerObject tobj = handleTriggerEvent->getObjects().at( iO );
-      TriggerObject triggerObject( reco::Particle::PolarLorentzVector(tobj.pt(), tobj.eta(), tobj.phi(), tobj.mass()), tobj.id()  );
-      // set collection
-      while ( iO >= collectionKeys[ iC ] ) ++iC; // relies on well ordering of trigger objects with respect to the collections
-      triggerObject.setCollection( handleTriggerEvent->collectionTagEncoded( iC ) );
-      // set filter ID
-      typedef std::multimap< trigger::size_type, int >::const_iterator it_type;
-      for (std::pair<it_type,it_type> trange = objectTypes.equal_range(iO);
-          trange.first != trange.second; ++trange.first) {
-          triggerObject.addTriggerObjectType( trange.first->second );
-      }
-
-      // stand-alone trigger object
-      TriggerObjectStandAlone triggerObjectStandAlone( triggerObject );
-      // check for excluded collections
-      bool excluded( false );
-      for ( size_t iE = 0; iE < exludeCollections_.size(); ++iE ) {
-        if ( triggerObjectStandAlone.hasCollection( exludeCollections_.at( iE ) ) ) {
-          if ( ! onlyStandAlone_ ) newObjectKeys[ iO ] = trigger::size_type( sizeObjects );
-          excluded = true;
-          break;
-        }
-      }
-      if ( excluded ) continue;
-      typedef std::multimap< trigger::size_type, std::string >::const_iterator it_fl;
-      for (std::pair<it_fl,it_fl> frange = filterLabels.equal_range(iO); frange.first != frange.second; ++frange.first) {
-          triggerObjectStandAlone.addFilterLabel( frange.first->second );
-          const std::vector<ModuleLabelToPathAndFlags::PathAndFlags> & paths = moduleLabelToPathAndFlags_[frange.first->second];
-          for (std::vector<ModuleLabelToPathAndFlags::PathAndFlags>::const_iterator iP = paths.begin(); iP != paths.end(); ++iP) {
-              bool pathFired = handleTriggerResults->wasrun( iP->pathIndex ) && handleTriggerResults->accept( iP->pathIndex );
-              triggerObjectStandAlone.addPathName( iP->pathName, pathFired && iP->lastFilter, pathFired && iP->l3Filter );
-          }
-      }
-
-      triggerObjectsStandAlone->push_back( triggerObjectStandAlone );
-      if ( ! onlyStandAlone_ ) {
-        triggerObjects->push_back( triggerObject );
-        newObjectKeys[ iO ] = trigger::size_type( triggerObjects->size() - 1 );
-      }
-    }
-
-    // Re-iterate HLT filters and finally produce them in order to account for optionally skipped objects
-    if ( ! onlyStandAlone_ ) {
-      std::auto_ptr< TriggerFilterCollection > triggerFilters( new TriggerFilterCollection() );
-      triggerFilters->reserve( sizeFilters );
-      for ( size_t iF = 0; iF < sizeFilters; ++iF ) {
-        const std::string nameFilter( handleTriggerEvent->filterTag( iF ).label() );
-        const trigger::Keys & keys  = handleTriggerEvent->filterKeys( iF ); // not cached
-        const trigger::Vids & types = handleTriggerEvent->filterIds( iF );  // not cached
-        TriggerFilter triggerFilter( nameFilter );
-        // set filter type
-        const std::string typeFilter( hltConfig_.moduleType( nameFilter ) );
-        triggerFilter.setType( typeFilter );
-        triggerFilter.setSaveTags( hltConfig_.saveTags( nameFilter ) );
-        // set keys and trigger object types of used objects
-        for ( size_t iK = 0; iK < keys.size(); ++iK ) { // identical to types.size()
-          // check, if current object is excluded
-          if ( newObjectKeys.find( keys.at( iK ) ) != newObjectKeys.end() ) {
-            if ( newObjectKeys[ keys.at( iK ) ] == sizeObjects ) continue;
-            triggerFilter.addObjectKey( newObjectKeys[ keys.at( iK ) ] );
-            triggerFilter.addTriggerObjectType( types.at( iK ) );
-          } else {
-            LogWarning( "triggerObjectKey" ) << "TriggerFilter '" << nameFilter << "' requests non-existing TriggerObject key " << keys.at( iK ) << "\n"
-                                             << "Skipping object assignment";
-          }
-        }
-        // set status from path info
-        std::map< std::string, int >::iterator iS( moduleStates.find( nameFilter ) );
-        if ( iS != moduleStates.end() ) {
-          if ( ! triggerFilter.setStatus( iS->second ) ) {
-            triggerFilter.setStatus( -1 ); // FIXME different code for "unvalid status determined" needed?
-          }
-        } else {
-          triggerFilter.setStatus( -1 ); // FIXME different code for "unknown" needed?
-        }
-        // store filter
-        triggerFilters->push_back( triggerFilter );
-      }
-      // put HLT filters to event
-      iEvent.put( triggerFilters );
-    }
-
-  } // if ( goodHlt )
-
-  // L1 objects
-  // (needs to be done after HLT objects, since their x-links with filters rely on their collection keys)
-
-  // map for assignments of objects to conditions
-  std::map< L1GtObject, std::vector< unsigned > > l1ObjectTypeMap;
-  if ( ! tagL1ExtraMu_.label().empty() ) {
-    Handle< l1extra::L1MuonParticleCollection > handleL1ExtraMu;
-    iEvent.getByLabel( tagL1ExtraMu_, handleL1ExtraMu );
-    if ( handleL1ExtraMu.isValid() ) {
-      std::vector< unsigned > muKeys;
-      for ( size_t l1Mu = 0; l1Mu < handleL1ExtraMu->size(); ++l1Mu ) {
-        if ( mainBxOnly_ && handleL1ExtraMu->at( l1Mu ).bx() != 0 ) continue;
-        TriggerObject triggerObject;
-        if ( saveL1Refs_ ) {
-          const reco::CandidateBaseRef leafCandRef( l1extra::L1MuonParticleRef( handleL1ExtraMu, l1Mu ) );
-          triggerObject = TriggerObject( leafCandRef );
-        } else {
-          const reco::LeafCandidate leafCandidate( *( handleL1ExtraMu->at( l1Mu ).reco::LeafCandidate::clone() ) );
-          triggerObject = TriggerObject( leafCandidate );
-        }
-        triggerObject.setCollection( tagL1ExtraMu_ );
-        triggerObject.addTriggerObjectType( trigger::TriggerL1Mu );
-        if ( ! onlyStandAlone_ ) triggerObjects->push_back( triggerObject );
-        TriggerObjectStandAlone triggerObjectStandAlone( triggerObject );
-        triggerObjectsStandAlone->push_back( triggerObjectStandAlone );
-        if ( handleL1ExtraMu->at( l1Mu ).bx() == 0 ) muKeys.push_back( triggerObjectsStandAlone->size() - 1 );
-      }
-      l1ObjectTypeMap.insert( std::make_pair( Mu, muKeys ) );
-    } else LogError( "l1ExtraValid" ) << "l1extra::L1MuonParticleCollection product with InputTag '" << tagL1ExtraMu_.encode() << "' not in event";
-  }
-  if ( ! tagL1ExtraNoIsoEG_.label().empty() ) {
-    Handle< l1extra::L1EmParticleCollection > handleL1ExtraNoIsoEG;
-    iEvent.getByLabel( tagL1ExtraNoIsoEG_, handleL1ExtraNoIsoEG );
-    if ( handleL1ExtraNoIsoEG.isValid() ) {
-      std::vector< unsigned > noIsoEGKeys;
-      for ( size_t l1NoIsoEG = 0; l1NoIsoEG < handleL1ExtraNoIsoEG->size(); ++l1NoIsoEG ) {
-        if ( mainBxOnly_ && handleL1ExtraNoIsoEG->at( l1NoIsoEG ).bx() != 0 ) continue;
-        TriggerObject triggerObject;
-        if ( saveL1Refs_ ) {
-          const reco::CandidateBaseRef leafCandRef( l1extra::L1EmParticleRef( handleL1ExtraNoIsoEG, l1NoIsoEG ) );
-          triggerObject = TriggerObject( leafCandRef );
-        } else {
-          const reco::LeafCandidate leafCandidate( *( handleL1ExtraNoIsoEG->at( l1NoIsoEG ).reco::LeafCandidate::clone() ) );
-          triggerObject = TriggerObject( leafCandidate );
-        }
-        triggerObject.setCollection( tagL1ExtraNoIsoEG_ );
-        triggerObject.addTriggerObjectType( trigger::TriggerL1NoIsoEG );
-        if ( ! onlyStandAlone_ ) triggerObjects->push_back( triggerObject );
-        TriggerObjectStandAlone triggerObjectStandAlone( triggerObject );
-        triggerObjectsStandAlone->push_back( triggerObjectStandAlone );
-        if ( handleL1ExtraNoIsoEG->at( l1NoIsoEG ).bx() == 0 ) noIsoEGKeys.push_back( triggerObjectsStandAlone->size() - 1 );
-      }
-      l1ObjectTypeMap.insert( std::make_pair( NoIsoEG, noIsoEGKeys ) );
-    } else LogError( "l1ExtraValid" ) << "l1extra::L1EmParticleCollection product with InputTag '" << tagL1ExtraNoIsoEG_.encode() << "' not in event";
-  }
-  if ( ! tagL1ExtraIsoEG_.label().empty() ) {
-    Handle< l1extra::L1EmParticleCollection > handleL1ExtraIsoEG;
-    iEvent.getByLabel( tagL1ExtraIsoEG_, handleL1ExtraIsoEG );
-    if ( handleL1ExtraIsoEG.isValid() ) {
-      std::vector< unsigned > isoEGKeys;
-      for ( size_t l1IsoEG = 0; l1IsoEG < handleL1ExtraIsoEG->size(); ++l1IsoEG ) {
-        if ( mainBxOnly_ && handleL1ExtraIsoEG->at( l1IsoEG ).bx() != 0 ) continue;
-        TriggerObject triggerObject;
-        if ( saveL1Refs_ ) {
-          const reco::CandidateBaseRef leafCandRef( l1extra::L1EmParticleRef( handleL1ExtraIsoEG, l1IsoEG ) );
-          triggerObject = TriggerObject( leafCandRef );
-        } else {
-          const reco::LeafCandidate leafCandidate( *( handleL1ExtraIsoEG->at( l1IsoEG ).reco::LeafCandidate::clone() ) );
-          triggerObject = TriggerObject( leafCandidate );
-        }
-        triggerObject.setCollection( tagL1ExtraIsoEG_ );
-        triggerObject.addTriggerObjectType( trigger::TriggerL1IsoEG );
-        if ( ! onlyStandAlone_ ) triggerObjects->push_back( triggerObject );
-        TriggerObjectStandAlone triggerObjectStandAlone( triggerObject );
-        triggerObjectsStandAlone->push_back( triggerObjectStandAlone );
-        if ( handleL1ExtraIsoEG->at( l1IsoEG ).bx() == 0 ) isoEGKeys.push_back( triggerObjectsStandAlone->size() - 1 );
-      }
-      l1ObjectTypeMap.insert( std::make_pair( IsoEG, isoEGKeys ) );
-    } else LogError( "l1ExtraValid" ) << "l1extra::L1EmParticleCollection product with InputTag '" << tagL1ExtraIsoEG_.encode() << "' not in event";
-  }
-  if ( ! tagL1ExtraCenJet_.label().empty() ) {
-    Handle< l1extra::L1JetParticleCollection > handleL1ExtraCenJet;
-    iEvent.getByLabel( tagL1ExtraCenJet_, handleL1ExtraCenJet );
-    if ( handleL1ExtraCenJet.isValid() ) {
-      std::vector< unsigned > cenJetKeys;
-      for ( size_t l1CenJet = 0; l1CenJet < handleL1ExtraCenJet->size(); ++l1CenJet ) {
-        if ( mainBxOnly_ && handleL1ExtraCenJet->at( l1CenJet ).bx() != 0 ) continue;
-        TriggerObject triggerObject;
-        if ( saveL1Refs_ ) {
-          const reco::CandidateBaseRef leafCandRef( l1extra::L1JetParticleRef( handleL1ExtraCenJet, l1CenJet ) );
-          triggerObject = TriggerObject( leafCandRef );
-        } else {
-          const reco::LeafCandidate leafCandidate( *( handleL1ExtraCenJet->at( l1CenJet ).reco::LeafCandidate::clone() ) );
-          triggerObject = TriggerObject( leafCandidate );
-        }
-        triggerObject.setCollection( tagL1ExtraCenJet_ );
-        triggerObject.addTriggerObjectType( trigger::TriggerL1CenJet );
-        if ( ! onlyStandAlone_ ) triggerObjects->push_back( triggerObject );
-        TriggerObjectStandAlone triggerObjectStandAlone( triggerObject );
-        triggerObjectsStandAlone->push_back( triggerObjectStandAlone );
-        if ( handleL1ExtraCenJet->at( l1CenJet ).bx() == 0 ) cenJetKeys.push_back( triggerObjectsStandAlone->size() - 1 );
-      }
-      l1ObjectTypeMap.insert( std::make_pair( CenJet, cenJetKeys ) );
-    } else LogError( "l1ExtraValid" ) << "l1extra::L1JetParticleCollection product with InputTag '" << tagL1ExtraCenJet_.encode() << "' not in event";
-  }
-  if ( ! tagL1ExtraForJet_.label().empty() ) {
-    Handle< l1extra::L1JetParticleCollection > handleL1ExtraForJet;
-    iEvent.getByLabel( tagL1ExtraForJet_, handleL1ExtraForJet );
-    if ( handleL1ExtraForJet.isValid() ) {
-      std::vector< unsigned > forJetKeys;
-      for ( size_t l1ForJet = 0; l1ForJet < handleL1ExtraForJet->size(); ++l1ForJet ) {
-        if ( mainBxOnly_ && handleL1ExtraForJet->at( l1ForJet ).bx() != 0 ) continue;
-        TriggerObject triggerObject;
-        if ( saveL1Refs_ ) {
-          const reco::CandidateBaseRef leafCandRef( l1extra::L1JetParticleRef( handleL1ExtraForJet, l1ForJet ) );
-          triggerObject = TriggerObject( leafCandRef );
-        } else {
-          const reco::LeafCandidate leafCandidate( *( handleL1ExtraForJet->at( l1ForJet ).reco::LeafCandidate::clone() ) );
-          triggerObject = TriggerObject( leafCandidate );
-        }
-        triggerObject.setCollection( tagL1ExtraForJet_ );
-        triggerObject.addTriggerObjectType( trigger::TriggerL1ForJet );
-        if ( ! onlyStandAlone_ ) triggerObjects->push_back( triggerObject );
-        TriggerObjectStandAlone triggerObjectStandAlone( triggerObject );
-        triggerObjectsStandAlone->push_back( triggerObjectStandAlone );
-        if ( handleL1ExtraForJet->at( l1ForJet ).bx() == 0 ) forJetKeys.push_back( triggerObjectsStandAlone->size() - 1 );
-      }
-      l1ObjectTypeMap.insert( std::make_pair( ForJet, forJetKeys ) );
-    } else LogError( "l1ExtraValid" ) << "l1extra::L1JetParticleCollection product with InputTag '" << tagL1ExtraForJet_.encode() << "' not in event";
-  }
-  if ( ! tagL1ExtraTauJet_.label().empty() ) {
-    Handle< l1extra::L1JetParticleCollection > handleL1ExtraTauJet;
-    iEvent.getByLabel( tagL1ExtraTauJet_, handleL1ExtraTauJet );
-    if ( handleL1ExtraTauJet.isValid() ) {
-      std::vector< unsigned > tauJetKeys;
-      for ( size_t l1TauJet = 0; l1TauJet < handleL1ExtraTauJet->size(); ++l1TauJet ) {
-        if ( mainBxOnly_ && handleL1ExtraTauJet->at( l1TauJet ).bx() != 0 ) continue;
-        TriggerObject triggerObject;
-        if ( saveL1Refs_ ) {
-          const reco::CandidateBaseRef leafCandRef( l1extra::L1JetParticleRef( handleL1ExtraTauJet, l1TauJet ) );
-          triggerObject = TriggerObject( leafCandRef );
-        } else {
-          const reco::LeafCandidate leafCandidate( *( handleL1ExtraTauJet->at( l1TauJet ).reco::LeafCandidate::clone() ) );
-          triggerObject = TriggerObject( leafCandidate );
-        }
-        triggerObject.setCollection( tagL1ExtraTauJet_ );
-        triggerObject.addTriggerObjectType( trigger::TriggerL1TauJet );
-        if ( ! onlyStandAlone_ ) triggerObjects->push_back( triggerObject );
-        TriggerObjectStandAlone triggerObjectStandAlone( triggerObject );
-        triggerObjectsStandAlone->push_back( triggerObjectStandAlone );
-        if ( handleL1ExtraTauJet->at( l1TauJet ).bx() == 0 ) tauJetKeys.push_back( triggerObjectsStandAlone->size() - 1 );
-      }
-      l1ObjectTypeMap.insert( std::make_pair( TauJet, tauJetKeys ) );
-    } else LogError( "l1ExtraValid" ) << "l1extra::L1JetParticleCollection product with InputTag '" << tagL1ExtraTauJet_.encode() << "' not in event";
-  }
-  if ( ! tagL1ExtraETM_ .label().empty()) {
-    Handle< l1extra::L1EtMissParticleCollection > handleL1ExtraETM;
-    iEvent.getByLabel( tagL1ExtraETM_, handleL1ExtraETM );
-    if ( handleL1ExtraETM.isValid() ) {
-      std::vector< unsigned > etmKeys;
-      for ( size_t l1ETM = 0; l1ETM < handleL1ExtraETM->size(); ++l1ETM ) {
-        if ( mainBxOnly_ && handleL1ExtraETM->at( l1ETM ).bx() != 0 ) continue;
-        TriggerObject triggerObject;
-        if ( saveL1Refs_ ) {
-          const reco::CandidateBaseRef leafCandRef( l1extra::L1EtMissParticleRef( handleL1ExtraETM, l1ETM ) );
-          triggerObject = TriggerObject( leafCandRef );
-        } else {
-          const reco::LeafCandidate leafCandidate( *( handleL1ExtraETM->at( l1ETM ).reco::LeafCandidate::clone() ) );
-          triggerObject = TriggerObject( leafCandidate );
-        }
-        triggerObject.setCollection( tagL1ExtraETM_ );
-        triggerObject.addTriggerObjectType( trigger::TriggerL1ETM );
-        if ( ! onlyStandAlone_ ) triggerObjects->push_back( triggerObject );
-        TriggerObjectStandAlone triggerObjectStandAlone( triggerObject );
-        triggerObjectsStandAlone->push_back( triggerObjectStandAlone );
-        if ( handleL1ExtraETM->at( l1ETM ).bx() == 0 ) etmKeys.push_back( triggerObjectsStandAlone->size() - 1 );
-      }
-      l1ObjectTypeMap.insert( std::make_pair( ETM, etmKeys ) );
-    } else LogError( "l1ExtraValid" ) << "l1extra::L1EtMissParticleCollection product with InputTag '" << tagL1ExtraETM_.encode() << "' not in event";
-  }
-  if ( ! tagL1ExtraHTM_.label().empty() ) {
-    Handle< l1extra::L1EtMissParticleCollection > handleL1ExtraHTM;
-    iEvent.getByLabel( tagL1ExtraHTM_, handleL1ExtraHTM );
-    if ( handleL1ExtraHTM.isValid() ) {
-      std::vector< unsigned > htmKeys;
-      for ( size_t l1HTM = 0; l1HTM < handleL1ExtraHTM->size(); ++l1HTM ) {
-        if ( mainBxOnly_ && handleL1ExtraHTM->at( l1HTM ).bx() != 0 ) continue;
-        TriggerObject triggerObject;
-        if ( saveL1Refs_ ) {
-          const reco::CandidateBaseRef leafCandRef( l1extra::L1EtMissParticleRef( handleL1ExtraHTM, l1HTM ) );
-          triggerObject = TriggerObject( leafCandRef );
-        } else {
-          const reco::LeafCandidate leafCandidate( *( handleL1ExtraHTM->at( l1HTM ).reco::LeafCandidate::clone() ) );
-          triggerObject = TriggerObject( leafCandidate );
-        }
-        triggerObject.setCollection( tagL1ExtraHTM_ );
-        triggerObject.addTriggerObjectType( trigger::TriggerL1HTM );
-        if ( ! onlyStandAlone_ ) triggerObjects->push_back( triggerObject );
-        TriggerObjectStandAlone triggerObjectStandAlone( triggerObject );
-        triggerObjectsStandAlone->push_back( triggerObjectStandAlone );
-        if ( handleL1ExtraHTM->at( l1HTM ).bx() == 0 ) htmKeys.push_back( triggerObjectsStandAlone->size() - 1 );
-      }
-      l1ObjectTypeMap.insert( std::make_pair( HTM, htmKeys ) );
-    } else LogError( "l1ExtraValid" ) << "l1extra::L1EtMissParticleCollection product with InputTag '" << tagL1ExtraHTM_.encode() << "' not in event";
-  }
-
-  // Put trigger objects to event
-  if ( ! onlyStandAlone_ ) iEvent.put( triggerObjects );
-
-  // L1 algorithms
-  if ( ! onlyStandAlone_ ) {
-    std::auto_ptr< TriggerAlgorithmCollection > triggerAlgos( new TriggerAlgorithmCollection() );
-    std::auto_ptr< TriggerConditionCollection > triggerConditions( new TriggerConditionCollection() );
-    if ( addL1Algos_ ) {
-      // create trigger object types transalation map (yes, it's ugly!)
-      std::map< L1GtObject, trigger::TriggerObjectType > mapObjectTypes;
-      mapObjectTypes.insert( std::make_pair( Mu     , trigger::TriggerL1Mu ) );
-      mapObjectTypes.insert( std::make_pair( NoIsoEG, trigger::TriggerL1NoIsoEG ) );
-      mapObjectTypes.insert( std::make_pair( IsoEG  , trigger::TriggerL1IsoEG ) );
-      mapObjectTypes.insert( std::make_pair( CenJet , trigger::TriggerL1CenJet ) );
-      mapObjectTypes.insert( std::make_pair( ForJet , trigger::TriggerL1ForJet ) );
-      mapObjectTypes.insert( std::make_pair( TauJet , trigger::TriggerL1TauJet ) );
-      mapObjectTypes.insert( std::make_pair( ETM    , trigger::TriggerL1ETM ) );
-      mapObjectTypes.insert( std::make_pair( HTM    , trigger::TriggerL1HTM ) );
-      // get and cache L1 menu
-      l1GtUtils_.getL1GtRunCache( iEvent, iSetup, useL1EventSetup, useL1GtTriggerMenuLite );
-      ESHandle< L1GtTriggerMenu > handleL1GtTriggerMenu;
-      iSetup.get< L1GtTriggerMenuRcd >().get( handleL1GtTriggerMenu );
-      L1GtTriggerMenu l1GtTriggerMenu( *handleL1GtTriggerMenu );
-      const AlgorithmMap l1GtAlgorithms( l1GtTriggerMenu.gtAlgorithmMap() );
-      const AlgorithmMap l1GtTechTriggers( l1GtTriggerMenu.gtTechnicalTriggerMap() );
-      l1GtTriggerMenu.buildGtConditionMap();
-      const std::vector< ConditionMap > l1GtConditionsVector( l1GtTriggerMenu.gtConditionMap() );
-      // cache conditions in one single condition map
-      ConditionMap l1GtConditions;
-      for ( size_t iCv = 0; iCv < l1GtConditionsVector.size(); ++iCv ) {
-        l1GtConditions.insert( l1GtConditionsVector.at( iCv ).begin(), l1GtConditionsVector.at( iCv ).end() );
-      }
-      triggerAlgos->reserve( l1GtAlgorithms.size() + l1GtTechTriggers.size() );
-      Handle< L1GlobalTriggerObjectMaps > handleL1GlobalTriggerObjectMaps;
-      iEvent.getByLabel( tagL1GlobalTriggerObjectMaps_, handleL1GlobalTriggerObjectMaps );
-      if( ! handleL1GlobalTriggerObjectMaps.isValid() ) {
-        LogError( "l1ObjectMap" ) << "L1GlobalTriggerObjectMaps product with InputTag '" << tagL1GlobalTriggerObjectMaps_.encode() << "' not in event\n"
-                                    << "No L1 objects and GTL results available for physics algorithms";
-      }
-      handleL1GlobalTriggerObjectMaps->consistencyCheck();
-      if ( firstInRun_ ) {
-        l1PSet_ = ( ParameterSet* )( pset::Registry::instance()->getMapped(handleL1GlobalTriggerObjectMaps->namesParameterSetID()) );
-        if (l1PSet_ == 0) {
-          LogError( "l1ObjectMap" ) << "ParameterSet registry not available\n"
-                                    << "Skipping conditions for all L1 physics algorithm names in this run";
-        }
-      } else {
-        if (l1PSet_ == 0) {
-          LogInfo( "l1ObjectMap" ) << "ParameterSet registry not available\n"
-                                   << "Skipping conditions for all L1 physics algorithm names in this event";
-        }
-      }
-      // physics algorithms
-      for ( CItAlgo iAlgo = l1GtAlgorithms.begin(); iAlgo != l1GtAlgorithms.end(); ++iAlgo ) {
-        const std::string & algoName( iAlgo->second.algoName() );
-        if ( ! ( iAlgo->second.algoBitNumber() < int( L1GlobalTriggerReadoutSetup::NumberPhysTriggers ) ) ) {
-          LogError( "l1Algo" ) << "L1 physics algorithm '" << algoName << "' has bit number " << iAlgo->second.algoBitNumber() << " >= " << L1GlobalTriggerReadoutSetup::NumberPhysTriggers << "\n"
-                               << "Skipping";
-          continue;
-        }
-        L1GtUtils::TriggerCategory category;
-        int bit;
-        if ( ! l1GtUtils_.l1AlgoTechTrigBitNumber( algoName, category, bit ) ) {
-          LogError( "l1Algo" ) << "L1 physics algorithm '" << algoName << "' not found in the L1 menu\n"
-                               << "Skipping";
-          continue;
-        }
-        if ( category != L1GtUtils::AlgorithmTrigger ) {
-          LogError( "l1Algo" ) << "L1 physics algorithm '" << algoName << "' does not have category 'AlgorithmTrigger' from 'L1GtUtils'\n"
-                               << "Skipping";
-          continue;
-        }
-        bool decisionBeforeMask;
-        bool decisionAfterMask;
-        int  prescale;
-        int  mask;
-        int  error( l1GtUtils_.l1Results( iEvent, algoName, decisionBeforeMask, decisionAfterMask, prescale, mask ) );
-        if ( error ) {
-          LogError( "l1Algo" ) << "L1 physics algorithm '" << algoName << "' decision has error code " << error << " from 'L1GtUtils'\n"
-                               << "Skipping";
-          continue;
-        }
-        TriggerAlgorithm triggerAlgo( algoName, iAlgo->second.algoAlias(), category == L1GtUtils::TechnicalTrigger, (unsigned)bit, (unsigned)prescale, (bool)mask, decisionBeforeMask, decisionAfterMask );
-        triggerAlgo.setLogicalExpression( iAlgo->second.algoLogicalExpression() );
-        // GTL result and used conditions in physics algorithm
-        if( ! handleL1GlobalTriggerObjectMaps.isValid() ) {
-          triggerAlgos->push_back( triggerAlgo );
-          continue; // LogWarning already earlier (before loop)
-        }
-        if ( ! handleL1GlobalTriggerObjectMaps->algorithmExists(bit)) {
-          LogError( "l1ObjectMap" ) << "L1 physics algorithm '" << algoName << "' is missing in L1GlobalTriggerObjectMaps\n"
-                                    << "Skipping conditions and GTL result";
-          triggerAlgos->push_back( triggerAlgo );
-          continue;
-        }
-        bool algorithmResult = handleL1GlobalTriggerObjectMaps->algorithmResult(bit);
-//         if ( ( algorithmResult != decisionBeforeMask ) && ( decisionBeforeMask == true || prescale == 1 ) ) {
-        if ( ( algorithmResult != decisionBeforeMask ) && ( decisionBeforeMask == true ) ) { // FIXME: understand the difference for un-prescaled algos 118, 119, 123
-          LogInfo( "l1ObjectMap" ) << "L1 physics algorithm '" << algoName << "' with different decisions in\n"
-                                   << "L1GlobalTriggerObjectMaps (GTL result)        : " << algorithmResult << "\n"
-                                   << "L1GlobalTriggerReadoutRecord (decision before mask): " << decisionBeforeMask;
-        }
-        triggerAlgo.setGtlResult( algorithmResult );
-        // conditions in algorithm
-        L1GlobalTriggerObjectMaps::ConditionsInAlgorithm conditions = handleL1GlobalTriggerObjectMaps->getConditionsInAlgorithm(bit);
-        if (l1PSet_ == 0) {
-          triggerAlgos->push_back( triggerAlgo );
-          continue;
-        }
-        if (!l1PSet_->exists(algoName)) {
-          if ( firstInRun_ ) {
-            LogError( "l1ObjectMap" ) << "L1 physics algorithm name '" << algoName << "' not available in ParameterSet registry\n"
-                                      << "Skipping conditions for this algorithm in this run";
-          } else {
-            LogInfo( "l1ObjectMap" ) << "L1 physics algorithm name '" << algoName << "' not available in ParameterSet registry\n"
-                                     << "Skipping conditions for this algorithm in this event";
-          }
-          triggerAlgos->push_back( triggerAlgo );
-          continue;
-        }
-        std::vector<std::string> conditionNames( l1PSet_->getParameter<std::vector<std::string> >(algoName) );
-
-        for ( unsigned iT = 0; iT < conditionNames.size(); ++iT ) {
-          size_t key( triggerConditions->size() );
-          for ( size_t iC = 0; iC < triggerConditions->size(); ++iC ) {
-            if ( conditionNames.at(iT) == triggerConditions->at( iC ).name() ) {
-              key = iC;
-              break;
-            }
-          }
-          if ( key == triggerConditions->size() ) {
-            if ( iT >= conditions.nConditions() ) {
-              LogError( "l1CondMap" ) << "More condition names from ParameterSet registry than the " << conditions.nConditions() << " conditions in L1GlobalTriggerObjectMaps\n"
-                                      << "Skipping condition " << conditionNames.at(iT) << " in algorithm " << algoName;
-              break;
-            }
-            TriggerCondition triggerCond( conditionNames[iT], conditions.getConditionResult(iT) );
-            if ( l1GtConditions.find( triggerCond.name() ) != l1GtConditions.end() ) {
-              triggerCond.setCategory( l1GtConditions[ triggerCond.name() ]->condCategory() );
-              triggerCond.setType( l1GtConditions[ triggerCond.name() ]->condType() );
-              const std::vector< L1GtObject > l1ObjectTypes( l1GtConditions[ triggerCond.name() ]->objectType() );
-              for ( size_t iType = 0 ; iType < l1ObjectTypes.size(); ++iType ) {
-                triggerCond.addTriggerObjectType( mapObjectTypes[ l1ObjectTypes.at( iType ) ] );
-              }
-              // objects in condition
-              L1GlobalTriggerObjectMaps::CombinationsInCondition combinations = handleL1GlobalTriggerObjectMaps->getCombinationsInCondition(bit, iT);
-              for ( size_t iVV = 0; iVV < combinations.nCombinations(); ++iVV ) {
-                for ( size_t iV = 0; iV < combinations.nObjectsPerCombination(); ++iV ) {
-
-                  unsigned objectIndex = combinations.getObjectIndex(iVV, iV);
-                  if ( iV >= l1ObjectTypes.size() ) {
-                    LogError( "l1CondMap" ) << "Index " << iV << " in combinations vector overshoots size " << l1ObjectTypes.size() << " of types vector in conditions map\n"
-                                            << "Skipping object key in condition " << triggerCond.name();
-                  } else if ( l1ObjectTypeMap.find( l1ObjectTypes.at( iV ) ) != l1ObjectTypeMap.end() ) {
-                    if ( objectIndex >= l1ObjectTypeMap[ l1ObjectTypes.at( iV ) ].size() ) {
-                      LogError( "l1CondMap" ) << "Index " << objectIndex << " in combination overshoots number " << l1ObjectTypeMap[ l1ObjectTypes.at( iV ) ].size() << "of according trigger objects\n"
-                                              << "Skipping object key in condition " << triggerCond.name();
-                    }
-                    const unsigned objectKey( l1ObjectTypeMap[ l1ObjectTypes.at( iV ) ].at( objectIndex ) );
-                    triggerCond.addObjectKey( objectKey );
-                    // add current condition and algorithm also to the according stand-alone trigger object
-                    triggerObjectsStandAlone->at( objectKey ).addAlgorithmName( triggerAlgo.name(), ( triggerAlgo.decision() && triggerCond.wasAccept() ) );
-                    triggerObjectsStandAlone->at( objectKey ).addConditionName( triggerCond.name() );
-                  }
-                }
-              }
-            } else {
-              LogWarning( "l1CondMap" ) << "L1 conditions '" << triggerCond.name() << "' not found in the L1 menu\n"
-                                        << "Remains incomplete";
-            }
-            triggerConditions->push_back( triggerCond );
-          }
-          triggerAlgo.addConditionKey( key );
-        }
-        triggerAlgos->push_back( triggerAlgo );
-      }
-      // technical triggers
-      for ( CItAlgo iAlgo = l1GtTechTriggers.begin(); iAlgo != l1GtTechTriggers.end(); ++iAlgo ) {
-        const std::string & algoName( iAlgo->second.algoName() );
-        if ( ! ( iAlgo->second.algoBitNumber() < int( L1GlobalTriggerReadoutSetup::NumberTechnicalTriggers ) ) ) {
-          LogError( "l1Algo" ) << "L1 technical trigger '" << algoName << "' has bit number " << iAlgo->second.algoBitNumber() << " >= " << L1GlobalTriggerReadoutSetup::NumberTechnicalTriggers << "\n"
-                               << "Skipping";
-          continue;
-        }
-        L1GtUtils::TriggerCategory category;
-        int bit;
-        if ( ! l1GtUtils_.l1AlgoTechTrigBitNumber( algoName, category, bit ) ) {
-          LogError( "l1Algo" ) << "L1 technical trigger '" << algoName << "' not found in the L1 menu\n"
-                               << "Skipping";
-          continue;
-        }
-        if ( category != L1GtUtils::TechnicalTrigger ) {
-          LogError( "l1Algo" ) << "L1 technical trigger '" << algoName << "' does not have category 'TechnicalTrigger' from 'L1GtUtils'\n"
-                               << "Skipping";
-          continue;
-        }
-        bool decisionBeforeMask;
-        bool decisionAfterMask;
-        int  prescale;
-        int  mask;
-        int  error( l1GtUtils_.l1Results( iEvent, algoName, decisionBeforeMask, decisionAfterMask, prescale, mask ) );
-        if ( error ) {
-          LogError( "l1Algo" ) << "L1 technical trigger '" << algoName << "' decision has error code " << error << " from 'L1GtUtils'\n"
-                               << "Skipping";
-          continue;
-        }
-        TriggerAlgorithm triggerAlgo( algoName, iAlgo->second.algoAlias(), category == L1GtUtils::TechnicalTrigger, (unsigned)bit, (unsigned)prescale, (bool)mask, decisionBeforeMask, decisionAfterMask );
-        triggerAlgo.setLogicalExpression( iAlgo->second.algoLogicalExpression() );
-        triggerAlgos->push_back( triggerAlgo );
-      }
-    }
-
-    // Put L1 algorithms and conditions to event
-    iEvent.put( triggerAlgos );
-    iEvent.put( triggerConditions );
-  }
-
-  // Put (finally) stand-alone trigger objects to event
-  iEvent.put( triggerObjectsStandAlone );
-
-  firstInRun_ = false;
-
-}
-
-void PATTriggerProducer::ModuleLabelToPathAndFlags::init(const HLTConfigProvider &hltConfig_) {
-    clear();
-    const std::vector<std::string> & pathNames = hltConfig_.triggerNames();
-    unsigned int sizePaths = pathNames.size();
-    for ( unsigned int indexPath = 0; indexPath < sizePaths; ++indexPath ) {
-        const std::string & namePath = pathNames[indexPath];
-
-        const std::vector<std::string> & nameModules = hltConfig_.moduleLabels(indexPath);
-        unsigned int sizeModulesPath = nameModules.size();
-        bool lastFilter = true;
-        unsigned int iM = sizeModulesPath;
-        while (iM > 0) {
-            const std::string & nameFilter = nameModules[--iM];
-            if (hltConfig_.moduleEDMType(nameFilter) != "EDFilter") continue;
-            if (hltConfig_.moduleType(nameFilter)    == "HLTBool")  continue;
-            bool saveTags = hltConfig_.saveTags(nameFilter);
-            insert( nameFilter, namePath, indexPath, lastFilter, saveTags );
-            if (saveTags) lastFilter = false; // FIXME: rather always?
-        }
-    }
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-DEFINE_FWK_MODULE( PATTriggerProducer );
diff --git a/PhysicsTools/PatAlgos/plugins/PATTriggerProducer.h b/PhysicsTools/PatAlgos/plugins/PATTriggerProducer.h
deleted file mode 100644
index 9ae3f5b..0000000
--- a/PhysicsTools/PatAlgos/plugins/PATTriggerProducer.h
+++ /dev/null
@@ -1,134 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_PATTriggerProducer_h
-#define PhysicsTools_PatAlgos_PATTriggerProducer_h
-
-
-// -*- C++ -*-
-//
-// Package:    PatAlgos
-// Class:      pat::PATTriggerProducer
-//
-// $Id: PATTriggerProducer.h,v 1.17.4.2 2012/09/11 22:21:47 vadler Exp $
-//
-/**
-  \class    pat::PATTriggerProducer PATTriggerProducer.h "PhysicsTools/PatAlgos/plugins/PATTriggerProducer.h"
-  \brief    Produces the full or stand-alone PAT trigger information collections
-
-   This producer extracts the trigger information from
-   - the edm::TriggerResults written by the HLT process,
-   - the corresponding trigger::TriggerEvent,
-   - the provenance information,
-   - the process history,
-   - the GlobalTrigger information in the event and the event setup and
-   - the L1 object collections ("l1extra")
-   re-arranges it and writes it either (full mode) to
-   - a pat::TriggerObjectCollection,
-   - a pat::TriggerFilterCollection,
-   - a pat::TriggerPathCollection,
-   - a pat::TriggerAlgorithmCollection (optionally filled or empty) and
-   - a pat::TriggerConditionCollection (optionally filled or empty)
-   or (stand-alone mode) to
-   - a pat::TriggerObjectStandAloneCollection
-
-   For me information, s.
-   https://twiki.cern.ch/twiki/bin/view/CMS/SWGuidePATTrigger
-
-  \author   Volker Adler
-  \version  $Id: PATTriggerProducer.h,v 1.17.4.2 2012/09/11 22:21:47 vadler Exp $
-*/
-
-
-#include "FWCore/Framework/interface/Frameworkfwd.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-
-#include <string>
-
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "L1Trigger/GlobalTriggerAnalyzer/interface/L1GtUtils.h"
-#include "HLTrigger/HLTcore/interface/HLTConfigProvider.h"
-
-namespace pat {
-
-  class PATTriggerProducer : public edm::EDProducer {
-
-    public:
-
-      explicit PATTriggerProducer( const edm::ParameterSet & iConfig );
-      ~PATTriggerProducer() {};
-
-    private:
-
-      virtual void beginRun( edm::Run & iRun, const edm::EventSetup & iSetup );
-      virtual void beginLuminosityBlock( edm::LuminosityBlock & iLuminosityBlock, const edm::EventSetup & iSetup );
-      virtual void produce( edm::Event & iEvent, const edm::EventSetup & iSetup );
-
-      std::string nameProcess_;     // configuration
-      bool        autoProcessName_;
-      bool        onlyStandAlone_;  // configuration
-      bool        firstInRun_;
-      // L1
-      L1GtUtils           l1GtUtils_;
-      edm::ParameterSet * l1PSet_;
-      bool                addL1Algos_;                    // configuration (optional with default)
-      edm::InputTag       tagL1GlobalTriggerObjectMaps_;  // configuration (optional with default)
-      edm::InputTag       tagL1ExtraMu_;                  // configuration (optional)
-      edm::InputTag       tagL1ExtraNoIsoEG_;             // configuration (optional)
-      edm::InputTag       tagL1ExtraIsoEG_;               // configuration (optional)
-      edm::InputTag       tagL1ExtraCenJet_;              // configuration (optional)
-      edm::InputTag       tagL1ExtraForJet_;              // configuration (optional)
-      edm::InputTag       tagL1ExtraTauJet_;              // configuration (optional)
-      edm::InputTag       tagL1ExtraETM_;                 // configuration (optional)
-      edm::InputTag       tagL1ExtraHTM_;                 // configuration (optional)
-      bool                autoProcessNameL1ExtraMu_;
-      bool                autoProcessNameL1ExtraNoIsoEG_;
-      bool                autoProcessNameL1ExtraIsoEG_;
-      bool                autoProcessNameL1ExtraCenJet_;
-      bool                autoProcessNameL1ExtraForJet_;
-      bool                autoProcessNameL1ExtraTauJet_;
-      bool                autoProcessNameL1ExtraETM_;
-      bool                autoProcessNameL1ExtraHTM_;
-      bool                mainBxOnly_;                    // configuration (optional with default)
-      bool                saveL1Refs_;                    // configuration (optional with default)
-      // HLT
-      HLTConfigProvider         hltConfig_;
-      bool                      hltConfigInit_;
-      edm::InputTag             tagTriggerResults_;     // configuration (optional with default)
-      edm::InputTag             tagTriggerEvent_;       // configuration (optional with default)
-      std::string               hltPrescaleLabel_;      // configuration (optional)
-      std::string               labelHltPrescaleTable_; // configuration (optional)
-      trigger::HLTPrescaleTable hltPrescaleTableRun_;
-      trigger::HLTPrescaleTable hltPrescaleTableLumi_;
-      bool                       addPathModuleLabels_;  // configuration (optional with default)
-      std::vector< std::string > exludeCollections_;    // configuration (optional)
-
-      class ModuleLabelToPathAndFlags {
-          public:
-              struct PathAndFlags {
-                PathAndFlags(const std::string &name, unsigned int index, bool last, bool l3) : pathName(name), pathIndex(index), lastFilter(last), l3Filter(l3) {}
-                PathAndFlags() {}
-                std::string pathName;
-                unsigned int pathIndex;
-                bool lastFilter;
-                bool l3Filter;
-              };
-              void init(const HLTConfigProvider &conf) ;
-              void clear() { map_.clear(); }
-              const std::vector<PathAndFlags> & operator[](const std::string & filter) const {
-                  std::map<std::string,std::vector<PathAndFlags> >::const_iterator it = map_.find(filter);
-                  return (it == map_.end() ? empty_ : it->second);
-              }
-          private:
-              void insert(const std::string & filter, const std::string &path, unsigned int pathIndex, bool lastFilter, bool l3Filter) {
-                  map_[filter].push_back(PathAndFlags(path, pathIndex, lastFilter, l3Filter));
-              }
-              std::map<std::string,std::vector<PathAndFlags> > map_;
-              const std::vector<PathAndFlags> empty_;
-      };
-      ModuleLabelToPathAndFlags moduleLabelToPathAndFlags_;
-
-  };
-}
-
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/StringResolutionProviderESProducer.cc b/PhysicsTools/PatAlgos/plugins/StringResolutionProviderESProducer.cc
deleted file mode 100644
index 5fa579d..0000000
--- a/PhysicsTools/PatAlgos/plugins/StringResolutionProviderESProducer.cc
+++ /dev/null
@@ -1,33 +0,0 @@
-#include <FWCore/Framework/interface/ESProducer.h>
-#include <FWCore/ParameterSet/interface/ParameterSet.h>
-
-#include "PhysicsTools/PatAlgos/interface/StringResolutionProvider.h"
-#include "PhysicsTools/PatAlgos/interface/KinematicResolutionRcd.h"
-
-class StringResolutionProviderESProducer : public edm::ESProducer 
-                                         {
-        public:
-                StringResolutionProviderESProducer() { }
-                StringResolutionProviderESProducer(const edm::ParameterSet &iConfig) ;
-
-                std::auto_ptr<KinematicResolutionProvider>  produce(const KinematicResolutionRcd &rcd) ;
-
-        private:
-                edm::ParameterSet cfg_;
-};
-
-StringResolutionProviderESProducer::StringResolutionProviderESProducer(const edm::ParameterSet &iConfig) :
-           cfg_(iConfig) {
-   std::string myName = iConfig.getParameter<std::string>("@module_label");
-   setWhatProduced(this,myName);
-}
-
-std::auto_ptr<KinematicResolutionProvider> 
-StringResolutionProviderESProducer::produce(const KinematicResolutionRcd &rcd) {
-        return std::auto_ptr<KinematicResolutionProvider>(new StringResolutionProvider(cfg_));
-}
-
-#include "FWCore/PluginManager/interface/ModuleDef.h"
-#include "FWCore/Framework/interface/MakerMacros.h"
-#include "FWCore/Framework/interface/ModuleFactory.h"
-DEFINE_FWK_EVENTSETUP_MODULE( StringResolutionProviderESProducer );
diff --git a/PhysicsTools/PatAlgos/plugins/TauJetCorrFactorsProducer.cc b/PhysicsTools/PatAlgos/plugins/TauJetCorrFactorsProducer.cc
deleted file mode 100644
index 247503e..0000000
--- a/PhysicsTools/PatAlgos/plugins/TauJetCorrFactorsProducer.cc
+++ /dev/null
@@ -1,150 +0,0 @@
-#include "PhysicsTools/PatAlgos/plugins/TauJetCorrFactorsProducer.h"
-
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-
-#include "JetMETCorrections/Objects/interface/JetCorrectionsRecord.h"
-#include "FWCore/Framework/interface/ESHandle.h"
-
-#include "DataFormats/TauReco/interface/PFTau.h"
-
-/// value map for JetCorrFactors (to be written into the event)
-typedef edm::ValueMap<pat::TauJetCorrFactors> TauJetCorrFactorsMap;
-
-using namespace pat;
-
-TauJetCorrFactorsProducer::TauJetCorrFactorsProducer(const edm::ParameterSet& cfg)
-  : moduleLabel_(cfg.getParameter<std::string>("@module_label")),
-    src_(cfg.getParameter<edm::InputTag>("src")),
-    levels_(cfg.getParameter<std::vector<std::string> >("levels")) 
-{
-  typedef std::vector<edm::ParameterSet> vParameterSet;
-  vParameterSet parameters = cfg.getParameter<vParameterSet>("parameters");
-  for ( vParameterSet::const_iterator param = parameters.begin();
-	param != parameters.end(); ++param ) {
-    payloadMappingType payloadMapping;
-
-    payloadMapping.payload_ = param->getParameter<std::string>("payload");
-
-    vstring decayModes_string = param->getParameter<vstring>("decayModes");
-    for ( vstring::const_iterator decayMode = decayModes_string.begin(); 
-	  decayMode != decayModes_string.end(); ++decayMode ) {
-      if ( (*decayMode) == "*" ) {
-	defaultPayload_ = payloadMapping.payload_;
-      } else {
-	payloadMapping.decayModes_.push_back(atoi(decayMode->data()));
-      }
-    }
-
-    if ( payloadMapping.decayModes_.size() > 0 ) payloadMappings_.push_back(payloadMapping);
-  }
-
-  produces<TauJetCorrFactorsMap>();
-}
-
-std::vector<JetCorrectorParameters>
-TauJetCorrFactorsProducer::params(const JetCorrectorParametersCollection& jecParameters, const std::vector<std::string>& levels) const 
-{
-  std::vector<JetCorrectorParameters> retVal;
-  for ( std::vector<std::string>::const_iterator corrLevel = levels.begin(); 
-	corrLevel != levels.end(); ++corrLevel ) { 
-    const JetCorrectorParameters& jecParameter_level = jecParameters[*corrLevel]; 
-    retVal.push_back(jecParameter_level); 
-  } 
-  return retVal;
-}
-
-float
-TauJetCorrFactorsProducer::evaluate(edm::View<reco::BaseTau>::const_iterator& tauJet, 
-				    boost::shared_ptr<FactorizedJetCorrector>& corrector, int corrLevel)
-{
-  corrector->setJetEta(tauJet->eta()); 
-  corrector->setJetPt(tauJet->pt()); 
-  corrector->setJetE(tauJet->energy()); 
-  return corrector->getSubCorrections()[corrLevel];
-}
-
-void 
-TauJetCorrFactorsProducer::produce(edm::Event& evt, const edm::EventSetup& es) 
-{
-  // get tau-jet collection from the event
-  edm::Handle<edm::View<reco::BaseTau> > tauJets;
-  evt.getByLabel(src_, tauJets);
-
-  typedef boost::shared_ptr<FactorizedJetCorrector> FactorizedJetCorrectorPtr;
-  std::map<std::string, FactorizedJetCorrectorPtr> correctorMapping;
-
-  // fill the tauJetCorrFactors
-  std::vector<TauJetCorrFactors> tauJetCorrections;
-  for ( edm::View<reco::BaseTau>::const_iterator tauJet = tauJets->begin(); 
-	tauJet != tauJets->end(); ++tauJet ) {
-
-    // the TauJetCorrFactors::CorrectionFactor is a std::pair<std::string, float>
-    // the string corresponds to the label of the correction level, the float to the tau-jet energy correction factor.
-    // The first correction level is predefined with label 'Uncorrected'. The correction factor is 1.
-    std::vector<TauJetCorrFactors::CorrectionFactor> jec;
-    jec.push_back(std::make_pair(std::string("Uncorrected"), 1.0));
-
-    if ( levels_.size() == 0 ) 
-      throw cms::Exception("No JECFactors") 
-	<< "You request to create a jetCorrFactors object with no JEC Levels indicated. \n"
-	<< "This makes no sense, either you should correct this or drop the module from \n"
-	<< "the sequence."; 
-
-    std::string payload = defaultPayload_;
-    if ( dynamic_cast<const reco::PFTau*>(&(*tauJet)) ) {
-      const reco::PFTau* pfTauJet = dynamic_cast<const reco::PFTau*>(&(*tauJet));
-      for ( std::vector<payloadMappingType>::const_iterator payloadMapping = payloadMappings_.begin();
-	    payloadMapping != payloadMappings_.end(); ++payloadMapping ) {
-	for( vint::const_iterator decayMode = payloadMapping->decayModes_.begin();
-	     decayMode != payloadMapping->decayModes_.end(); ++decayMode ) {
-	  if ( pfTauJet->decayMode() == (*decayMode) ) payload = payloadMapping->payload_;
-	}
-      }
-    }
-
-    // retrieve JEC parameters from the DB and build a new corrector,
-    // in case it does not exist already for current payload
-    if ( correctorMapping.find(payload) == correctorMapping.end() ) {
-      edm::ESHandle<JetCorrectorParametersCollection> jecParameters;
-      es.get<JetCorrectionsRecord>().get(payload, jecParameters); 
-
-      correctorMapping[payload] = FactorizedJetCorrectorPtr(new FactorizedJetCorrector(params(*jecParameters, levels_)));
-    }
-    FactorizedJetCorrectorPtr& corrector = correctorMapping[payload];
-
-    // evaluate tau-jet energy corrections
-    size_t numLevels = levels_.size();
-    for ( size_t idx = 0; idx < numLevels; ++idx ) {
-      const std::string& corrLevel = levels_[idx];
-  
-      float jecFactor = evaluate(tauJet, corrector, idx);
-      
-      // push back the set of JetCorrFactors: the first entry corresponds to the label 
-      // of the correction level. The second parameter corresponds to the jec factor. 
-      // In the default configuration the CorrectionFactor will look like this: 
-      //   'Uncorrected' : 1 ; 
-      //   'L2Relative'  : x ; 
-      //   'L3Absolute'  : x ;
-      jec.push_back(std::make_pair(corrLevel.substr(0, corrLevel.find("_")), jecFactor));
-    }
-
-    // create the actual object with the scale factors we want the valuemap to refer to
-    // moduleLabel_ corresponds to the python label of the TauJetCorrFactorsProducer module instance
-    TauJetCorrFactors tauJetCorrection(moduleLabel_, jec);
-    tauJetCorrections.push_back(tauJetCorrection);
-  }
-
-  // build the valuemap
-  std::auto_ptr<TauJetCorrFactorsMap> jecMapping(new TauJetCorrFactorsMap());
-  TauJetCorrFactorsMap::Filler filler(*jecMapping);
-  // tauJets and tauJetCorrections vectors have their indices aligned by construction
-  filler.insert(tauJets, tauJetCorrections.begin(), tauJetCorrections.end());
-  filler.fill(); // do the actual filling
-
-  // add valuemap to the event
-  evt.put(jecMapping);
-}
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(TauJetCorrFactorsProducer);
diff --git a/PhysicsTools/PatAlgos/plugins/TauJetCorrFactorsProducer.h b/PhysicsTools/PatAlgos/plugins/TauJetCorrFactorsProducer.h
deleted file mode 100644
index 2dfbbca..0000000
--- a/PhysicsTools/PatAlgos/plugins/TauJetCorrFactorsProducer.h
+++ /dev/null
@@ -1,93 +0,0 @@
-#ifndef PhysicsTools_PatAlgos_TauJetCorrFactorsProducer_h
-#define PhysicsTools_PatAlgos_TauJetCorrFactorsProducer_h
-
-/**
-  \class    pat::TauJetCorrFactorsProducer TauJetCorrFactorsProducer.h "PhysicsTools/PatAlgos/interface/TauJetCorrFactorsProducer.h"
-  \brief    Produces a ValueMap between TauJetCorrFactors and the originating reco taus
-
-   The TauJetCorrFactorsProducer produces a set of tau-jet energy correction factors, defined in the class pat::TauJetCorrFactors. 
-   This vector is linked to the originating reco taus through an edm::ValueMap. The initializing parameters of the module can be found 
-   in the recoLayer1/tauJetCorrFactors_cfi.py of the PatAlgos package. In the standard PAT workflow the module has to be run 
-   before the creation of the pat::Tau. The edm::ValueMap will then be embedded into the pat::Tau. 
-
-   Jets corrected up to a given correction level can then be accessed via the pat::Tau member function correctedJet. For 
-   more details have a look into the class description of the pat::Tau.
-*/
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/EventSetup.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-
-#include "CondFormats/JetMETObjects/interface/FactorizedJetCorrector.h"
-#include "CondFormats/JetMETObjects/interface/JetCorrectorParameters.h"
-
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/TauReco/interface/BaseTau.h"
-#include "DataFormats/PatCandidates/interface/TauJetCorrFactors.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-
-#include <boost/shared_ptr.hpp>
-
-#include <map>
-#include <string>
-
-namespace pat {
-
-  class TauJetCorrFactorsProducer : public edm::EDProducer 
-  {
-   public:
-    /// value map for JetCorrFactors (to be written into the event)
-    typedef edm::ValueMap<pat::TauJetCorrFactors> JetCorrFactorsMap;
-
-   public:
-    /// default constructor
-    explicit TauJetCorrFactorsProducer(const edm::ParameterSet&);
-    /// default destructor
-    ~TauJetCorrFactorsProducer() {};
-
-    /// everything that needs to be done per event
-    virtual void produce(edm::Event&, const edm::EventSetup&);
-    
-   private:
-    /// return the jec parameters as input to the FactorizedJetCorrector for different flavors
-    std::vector<JetCorrectorParameters> params(const JetCorrectorParametersCollection&, const std::vector<std::string>&) const;
-
-    /// evaluate jet correction factor up to a given level
-    float evaluate(edm::View<reco::BaseTau>::const_iterator&, boost::shared_ptr<FactorizedJetCorrector>&, int);
-    
-  private:
-    /// python label of this TauJetCorrFactorsProducer module
-    std::string moduleLabel_;
-
-     /// input tau-jet collection
-    edm::InputTag src_;
-
-    /// mapping of reconstructed tau decay modes to payloads
-    typedef std::vector<int> vint;
-    struct payloadMappingType
-    {
-      /// reconstructed tau decay modes associated to this payload, 
-      /// as defined in DataFormats/TauReco/interface/PFTau.h
-      vint decayModes_;
-
-      /// payload label
-      std::string payload_;
-    };
-    std::vector<payloadMappingType> payloadMappings_;
-
-    /// payload to be used for decay modes not explicitely specified
-    ///
-    /// NOTE: no decay mode reconstruction implemented for CaloTaus so far
-    ///      --> this payload is used for all CaloTaus
-    ///
-    std::string defaultPayload_;
-
-    /// jec levels 
-    typedef std::vector<std::string> vstring;
-    vstring levels_;
-  };
-}
-
-#endif
diff --git a/PhysicsTools/PatAlgos/plugins/VertexAssociationProducer.cc b/PhysicsTools/PatAlgos/plugins/VertexAssociationProducer.cc
deleted file mode 100644
index a62953a..0000000
--- a/PhysicsTools/PatAlgos/plugins/VertexAssociationProducer.cc
+++ /dev/null
@@ -1,100 +0,0 @@
-/**
-  \class    pat::PATVertexAssociationProducer PATVertexAssociationProducer.h "PhysicsTools/PatAlgos/interface/PATVertexAssociationProducer.h"
-  \brief    Produces VertexAssociation and a ValueMap to the originating
-            reco jets
-
-   The PATVertexAssociationProducer produces a set of vertex associations for one or more
-   collection of Candidates, and saves them in a ValueMap in the event.
-
-   These can be retrieved in PAT Layer 1 to be embedded in PAT Objects 
-
-  \author   Giovanni Petrucciani
-  \version  $Id: VertexAssociationProducer.cc,v 1.2 2010/02/20 21:00:29 wmtan Exp $
-*/
-
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/PatCandidates/interface/Vertexing.h"
-#include "PhysicsTools/PatAlgos/interface/VertexingHelper.h"
-
-
-namespace pat {
-
-  class PATVertexAssociationProducer : public edm::EDProducer {
-
-    typedef edm::ValueMap<pat::VertexAssociation> VertexAssociationMap;
-
-    public:
-
-      explicit PATVertexAssociationProducer(const edm::ParameterSet & iConfig);
-      ~PATVertexAssociationProducer();
-
-      virtual void produce(edm::Event & iEvent, const edm::EventSetup & iSetup);
-
-    private:
-      typedef std::vector<edm::InputTag> VInputTag;
-      // configurables
-      std::vector<edm::InputTag>   particles_;
-      pat::helper::VertexingHelper vertexing_;
-  
-  };
-
-}
-
-using pat::PATVertexAssociationProducer;
-
-PATVertexAssociationProducer::PATVertexAssociationProducer(const edm::ParameterSet& iConfig) :
-  particles_( iConfig.existsAs<VInputTag>("candidates") ?       // if it's a VInputTag
-                iConfig.getParameter<VInputTag>("candidates") :
-                VInputTag(1, iConfig.getParameter<edm::InputTag>("candidates")) ),
-  vertexing_(iConfig) 
-{
-    produces<VertexAssociationMap>();
-}
-
-
-PATVertexAssociationProducer::~PATVertexAssociationProducer() {
-}
-
-
-void PATVertexAssociationProducer::produce(edm::Event & iEvent, const edm::EventSetup & iSetup) {
-  using namespace edm; using namespace std; 
-  // read in vertices and EventSetup
-  vertexing_.newEvent(iEvent, iSetup);
-
-  // prepare room and tools for output
-  auto_ptr<VertexAssociationMap> result(new VertexAssociationMap());
-  VertexAssociationMap::Filler filler(*result);
-  vector<pat::VertexAssociation> assos;
- 
-  // loop on input tags  
-  for (VInputTag::const_iterator it = particles_.begin(), end = particles_.end(); it != end; ++it) {
-      // read candidates
-      Handle<View<reco::Candidate> > cands;
-      iEvent.getByLabel(*it, cands);
-      assos.clear(); assos.reserve(cands->size()); 
-      // loop on candidates
-      for (size_t i = 0, n = cands->size(); i < n; ++i) {
-        assos.push_back( vertexing_(cands->refAt(i)) );
-      }
-      // insert into ValueMap
-      filler.insert(cands, assos.begin(), assos.end());
-  }
-
-  // do the real filling
-  filler.fill(); 
-
-  // put our produced stuff in the event
-  iEvent.put(result);
-}
-
-
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-DEFINE_FWK_MODULE(PATVertexAssociationProducer);
diff --git a/PhysicsTools/PatAlgos/python/cleaningLayer1/cleanPatCandidates_cff.py b/PhysicsTools/PatAlgos/python/cleaningLayer1/cleanPatCandidates_cff.py
deleted file mode 100644
index 5664f20..0000000
--- a/PhysicsTools/PatAlgos/python/cleaningLayer1/cleanPatCandidates_cff.py
+++ /dev/null
@@ -1,31 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.cleaningLayer1.electronCleaner_cfi import *
-from PhysicsTools.PatAlgos.cleaningLayer1.muonCleaner_cfi import *
-from PhysicsTools.PatAlgos.cleaningLayer1.tauCleaner_cfi import *
-from PhysicsTools.PatAlgos.cleaningLayer1.photonCleaner_cfi import *
-from PhysicsTools.PatAlgos.cleaningLayer1.jetCleaner_cfi import *
-from PhysicsTools.PatAlgos.producersLayer1.hemisphereProducer_cfi import *
-#FIXME ADD MHT
-
-# One module to count objects
-cleanPatCandidateSummary = cms.EDAnalyzer("CandidateSummaryTable",
-    logName = cms.untracked.string("cleanPatCandidates|PATSummaryTables"),
-    candidates = cms.VInputTag(
-        cms.InputTag("cleanPatElectrons"),
-        cms.InputTag("cleanPatMuons"),
-        cms.InputTag("cleanPatTaus"),
-        cms.InputTag("cleanPatPhotons"),
-        cms.InputTag("cleanPatJets"),
-    )
-)
-
-
-cleanPatCandidates = cms.Sequence(
-    cleanPatMuons     *        # NOW WE MUST USE '*' AS THE ORDER MATTERS
-    cleanPatElectrons *
-    cleanPatPhotons   *
-    cleanPatTaus      *
-    cleanPatJets      *
-    cleanPatCandidateSummary
-)
diff --git a/PhysicsTools/PatAlgos/python/cleaningLayer1/electronCleaner_cfi.py b/PhysicsTools/PatAlgos/python/cleaningLayer1/electronCleaner_cfi.py
deleted file mode 100644
index 138f775..0000000
--- a/PhysicsTools/PatAlgos/python/cleaningLayer1/electronCleaner_cfi.py
+++ /dev/null
@@ -1,25 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-cleanPatElectrons = cms.EDProducer("PATElectronCleaner",
-    ## pat electron input source
-    src = cms.InputTag("selectedPatElectrons"), 
-
-    # preselection (any string-based cut for pat::Electron)
-    preselection = cms.string(''),
-
-    # overlap checking configurables
-    checkOverlaps = cms.PSet(
-        muons = cms.PSet(
-           src       = cms.InputTag("cleanPatMuons"),
-           algorithm = cms.string("byDeltaR"),
-           preselection        = cms.string(""),  # don't preselect the muons
-           deltaR              = cms.double(0.3),
-           checkRecoComponents = cms.bool(False), # don't check if they share some AOD object ref
-           pairCut             = cms.string(""),
-           requireNoOverlaps   = cms.bool(False), # overlaps don't cause the electron to be discared
-        )
-    ),
-
-    # finalCut (any string-based cut for pat::Electron)
-    finalCut = cms.string(''),
-)
diff --git a/PhysicsTools/PatAlgos/python/cleaningLayer1/genericTrackCleaner_cfi.py b/PhysicsTools/PatAlgos/python/cleaningLayer1/genericTrackCleaner_cfi.py
deleted file mode 100644
index d394118..0000000
--- a/PhysicsTools/PatAlgos/python/cleaningLayer1/genericTrackCleaner_cfi.py
+++ /dev/null
@@ -1,35 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-cleanPatTracks = cms.EDProducer("PATGenericParticleCleaner",
-    src = cms.InputTag("REPLACE_ME"), 
-
-    # preselection (any string-based cut on pat::GenericParticle)
-    preselection = cms.string(''),
-
-    # overlap checking configurables
-    checkOverlaps = cms.PSet(
-        muons = cms.PSet(
-           src       = cms.InputTag("cleanPatMuons"),
-           algorithm = cms.string("byDeltaR"),
-           preselection        = cms.string(""),
-           deltaR              = cms.double(0.3),
-           checkRecoComponents = cms.bool(True), # remove them if the use the same reco::Track
-           pairCut             = cms.string(""),
-           requireNoOverlaps   = cms.bool(True), # overlaps don't cause the electron to be discared
-        ),
-        electrons = cms.PSet(
-           src       = cms.InputTag("cleanPatElectrons"),
-           algorithm = cms.string("byDeltaR"),
-           preselection        = cms.string(""),
-           deltaR              = cms.double(0.3),
-           checkRecoComponents = cms.bool(False), # don't check if they share some AOD object ref
-                                                  # as electrons have reco::GsfTrack, not reco::Track
-           pairCut             = cms.string("0.5 < ele.pt/part.pt < 1.5"),  # let's do a check on relative P_T
-                                                                            # 'part' is the generic particle, 'ele' the electron
-           requireNoOverlaps   = cms.bool(True), # overlaps don't cause the electron to be discared
-        ),
-    ),
-
-    # finalCut (any string-based cut on pat::GenericParticle)
-    finalCut = cms.string(''),
-)
diff --git a/PhysicsTools/PatAlgos/python/cleaningLayer1/jetCleaner_cfi.py b/PhysicsTools/PatAlgos/python/cleaningLayer1/jetCleaner_cfi.py
deleted file mode 100644
index 0f43572..0000000
--- a/PhysicsTools/PatAlgos/python/cleaningLayer1/jetCleaner_cfi.py
+++ /dev/null
@@ -1,59 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-cleanPatJets = cms.EDProducer("PATJetCleaner",
-    src = cms.InputTag("selectedPatJets"), 
-
-    # preselection (any string-based cut on pat::Jet)
-    preselection = cms.string(''),
-
-    # overlap checking configurables
-    checkOverlaps = cms.PSet(
-        muons = cms.PSet(
-           src       = cms.InputTag("cleanPatMuons"),
-           algorithm = cms.string("byDeltaR"),
-           preselection        = cms.string(""),
-           deltaR              = cms.double(0.5),
-           checkRecoComponents = cms.bool(False), # don't check if they share some AOD object ref
-           pairCut             = cms.string(""),
-           requireNoOverlaps   = cms.bool(False), # overlaps don't cause the jet to be discared
-        ),
-        electrons = cms.PSet(
-           src       = cms.InputTag("cleanPatElectrons"),
-           algorithm = cms.string("byDeltaR"),
-           preselection        = cms.string(""),
-           deltaR              = cms.double(0.5),
-           checkRecoComponents = cms.bool(False), # don't check if they share some AOD object ref
-           pairCut             = cms.string(""),
-           requireNoOverlaps   = cms.bool(False), # overlaps don't cause the jet to be discared
-        ),
-        photons = cms.PSet(
-           src       = cms.InputTag("cleanPatPhotons"),
-           algorithm = cms.string("byDeltaR"),
-           preselection        = cms.string(""),
-           deltaR              = cms.double(0.5),
-           checkRecoComponents = cms.bool(False), # don't check if they share some AOD object ref
-           pairCut             = cms.string(""),
-           requireNoOverlaps   = cms.bool(False), # overlaps don't cause the jet to be discared
-        ),
-        taus = cms.PSet(
-           src       = cms.InputTag("cleanPatTaus"),
-           algorithm = cms.string("byDeltaR"),
-           preselection        = cms.string(""),
-           deltaR              = cms.double(0.5),
-           checkRecoComponents = cms.bool(False), # don't check if they share some AOD object ref
-           pairCut             = cms.string(""),
-           requireNoOverlaps   = cms.bool(False), # overlaps don't cause the jet to be discared
-        ),
-        tkIsoElectrons = cms.PSet(
-           src       = cms.InputTag("cleanPatElectrons"),
-           algorithm = cms.string("byDeltaR"),
-           preselection        = cms.string("pt > 10 && trackIso < 3"),
-           deltaR              = cms.double(0.3),
-           checkRecoComponents = cms.bool(False), # don't check if they share some AOD object ref
-           pairCut             = cms.string(""),
-           requireNoOverlaps   = cms.bool(False), # overlaps don't cause the jet to be discared
-        )
-    ),
-    # finalCut (any string-based cut on pat::Jet)
-    finalCut = cms.string(''),
-)
diff --git a/PhysicsTools/PatAlgos/python/cleaningLayer1/muonCleaner_cfi.py b/PhysicsTools/PatAlgos/python/cleaningLayer1/muonCleaner_cfi.py
deleted file mode 100644
index 1e75f1e..0000000
--- a/PhysicsTools/PatAlgos/python/cleaningLayer1/muonCleaner_cfi.py
+++ /dev/null
@@ -1,14 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-cleanPatMuons = cms.EDProducer("PATMuonCleaner",
-    src = cms.InputTag("selectedPatMuons"), 
-
-    # preselection (any string-based cut for pat::Muon)
-    preselection = cms.string(''),
-
-    # overlap checking configurables
-    checkOverlaps = cms.PSet(),
-
-    # finalCut (any string-based cut for pat::Muon)
-    finalCut = cms.string(''),
-)
diff --git a/PhysicsTools/PatAlgos/python/cleaningLayer1/photonCleaner_cfi.py b/PhysicsTools/PatAlgos/python/cleaningLayer1/photonCleaner_cfi.py
deleted file mode 100644
index 78fd5b8..0000000
--- a/PhysicsTools/PatAlgos/python/cleaningLayer1/photonCleaner_cfi.py
+++ /dev/null
@@ -1,24 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-cleanPatPhotons = cms.EDProducer("PATPhotonCleaner",
-    ## Input collection of Photons
-    src = cms.InputTag("selectedPatPhotons"),
-
-    # preselection (any string-based cut for pat::Photon)
-    preselection = cms.string(''),
-
-    # overlap checking configurables
-    checkOverlaps = cms.PSet(
-        electrons = cms.PSet(
-           src       = cms.InputTag("cleanPatElectrons"),
-           algorithm = cms.string("bySuperClusterSeed"),
-           requireNoOverlaps = cms.bool(False), # mark photons that overlap with electrons
-                                                # for further studies, but DO NOT discard
-                                                # them
-        ),
-    ),
-
-    # finalCut (any string-based cut for pat::Photon)
-    finalCut = cms.string(''),
-
-)
diff --git a/PhysicsTools/PatAlgos/python/cleaningLayer1/tauCleaner_cfi.py b/PhysicsTools/PatAlgos/python/cleaningLayer1/tauCleaner_cfi.py
deleted file mode 100644
index 8324720..0000000
--- a/PhysicsTools/PatAlgos/python/cleaningLayer1/tauCleaner_cfi.py
+++ /dev/null
@@ -1,38 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-cleanPatTaus = cms.EDProducer("PATTauCleaner",
-    src = cms.InputTag("selectedPatTaus"),
-
-    # preselection (any string-based cut on pat::Tau)
-    preselection = cms.string(
-        'tauID("decayModeFinding") > 0.5 &'
-        ' tauID("byLooseCombinedIsolationDeltaBetaCorr") > 0.5 &'
-        ' tauID("againstMuonMedium") > 0.5 &'
-        ' tauID("againstElectronMedium") > 0.5'
-    ),
-
-    # overlap checking configurables
-    checkOverlaps = cms.PSet(
-        muons = cms.PSet(
-           src       = cms.InputTag("cleanPatMuons"),
-           algorithm = cms.string("byDeltaR"),
-           preselection        = cms.string(""),
-           deltaR              = cms.double(0.3),
-           checkRecoComponents = cms.bool(False), # don't check if they share some AOD object ref
-           pairCut             = cms.string(""),
-           requireNoOverlaps   = cms.bool(False), # overlaps don't cause the electron to be discared
-        ),
-        electrons = cms.PSet(
-           src       = cms.InputTag("cleanPatElectrons"),
-           algorithm = cms.string("byDeltaR"),
-           preselection        = cms.string(""),
-           deltaR              = cms.double(0.3),
-           checkRecoComponents = cms.bool(False), # don't check if they share some AOD object ref
-           pairCut             = cms.string(""),
-           requireNoOverlaps   = cms.bool(False), # overlaps don't cause the electron to be discared
-        ),
-    ),
-
-    # finalCut (any string-based cut on pat::Tau)
-    finalCut = cms.string('pt > 20. & abs(eta) < 2.3'),
-)
diff --git a/PhysicsTools/PatAlgos/python/famos/boostrapWithFamos_cff.py b/PhysicsTools/PatAlgos/python/famos/boostrapWithFamos_cff.py
deleted file mode 100644
index 7f4ffb5..0000000
--- a/PhysicsTools/PatAlgos/python/famos/boostrapWithFamos_cff.py
+++ /dev/null
@@ -1,21 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-#
-# General fast simulation configuration ###
-#
-# Random number generator service
-from FastSimulation.Configuration.RandomServiceInitialization_cff import *
-# Generate ttbar events
-from FastSimulation.Configuration.ttbar_cfi import *
-# Famos sequences
-from FastSimulation.Configuration.CommonInputsFake_cff import *
-from FastSimulation.Configuration.FamosSequences_cff import *
-from Configuration.StandardSequences.MagneticField_cff import *
-# If you want to turn on/off pile-up (e.g. default low lumi: 5.0)
-famosPileUp.PileUpSimulator.averageNumber = 0
-# You may not want to simulate everything for your study
-famosSimHits.SimulateCalorimetry = True
-famosSimHits.SimulateTracking = True
-famosSimHits.SimulateMuons = True
-VolumeBasedMagneticFieldESProducer.useParametrizedTrackerField = True
-
diff --git a/PhysicsTools/PatAlgos/python/mcMatchLayer0/electronMatch_cfi.py b/PhysicsTools/PatAlgos/python/mcMatchLayer0/electronMatch_cfi.py
deleted file mode 100644
index 413b652..0000000
--- a/PhysicsTools/PatAlgos/python/mcMatchLayer0/electronMatch_cfi.py
+++ /dev/null
@@ -1,19 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-#
-# Example for a configuration of the MC match
-# for electrons
-#
-electronMatch = cms.EDProducer("MCMatcher",       # cut on deltaR, deltaPt/Pt; pick best by deltaR
-    src         = cms.InputTag("gsfElectrons"), # RECO objects to match
-    matched     = cms.InputTag("genParticles"), # mc-truth particle collection
-    mcPdgId     = cms.vint32(11),               # one or more PDG ID (11 = electron); absolute values (see below)
-    checkCharge = cms.bool(True),               # True = require RECO and MC objects to have the same charge
-    mcStatus    = cms.vint32(1),                # PYTHIA status code (1 = stable, 2 = shower, 3 = hard scattering)
-    maxDeltaR   = cms.double(0.5),              # Minimum deltaR for the match
-    maxDPtRel   = cms.double(0.5),              # Minimum deltaPt/Pt for the match
-    resolveAmbiguities    = cms.bool(True),     # Forbid two RECO objects to match to the same GEN object
-    resolveByMatchQuality = cms.bool(False),    # False = just match input in order; True = pick lowest deltaR pair first
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/mcMatchLayer0/jetFlavourId_cff.py b/PhysicsTools/PatAlgos/python/mcMatchLayer0/jetFlavourId_cff.py
deleted file mode 100644
index 2e2d38f..0000000
--- a/PhysicsTools/PatAlgos/python/mcMatchLayer0/jetFlavourId_cff.py
+++ /dev/null
@@ -1,21 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patJetPartons = cms.EDProducer("PartonSelector",
-    withLeptons = cms.bool(False),
-    src = cms.InputTag("genParticles")                            
-)
-
-patJetPartonAssociation = cms.EDProducer("JetPartonMatcher",
-    jets    = cms.InputTag("ak5CaloJets"),
-    partons = cms.InputTag("patJetPartons"),
-    coneSizeToAssociate = cms.double(0.3),
-)
-
-patJetFlavourAssociation = cms.EDProducer("JetFlavourIdentifier",
-    srcByReference    = cms.InputTag("patJetPartonAssociation"),
-    physicsDefinition = cms.bool(False)
-)
-
-# default PAT sequence for jet flavour identification
-patJetFlavourId = cms.Sequence(patJetPartons * patJetPartonAssociation * patJetFlavourAssociation)
-
diff --git a/PhysicsTools/PatAlgos/python/mcMatchLayer0/jetMatch_cfi.py b/PhysicsTools/PatAlgos/python/mcMatchLayer0/jetMatch_cfi.py
deleted file mode 100644
index 39bb3a1..0000000
--- a/PhysicsTools/PatAlgos/python/mcMatchLayer0/jetMatch_cfi.py
+++ /dev/null
@@ -1,30 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-#
-# Example for a configuration of the MC match
-#
-patJetPartonMatch = cms.EDProducer("MCMatcher",        # cut on deltaR, deltaPt/Pt; pick best by deltaR
-    src         = cms.InputTag("ak5CaloJets"),       # RECO objects to match
-    matched     = cms.InputTag("genParticles"),      # mc-truth particle collection
-    mcPdgId     = cms.vint32(1, 2, 3, 4, 5, 21),     # one or more PDG ID (quarks except top; gluons)
-    mcStatus    = cms.vint32(3),                     # PYTHIA status code (3 = hard scattering)
-    checkCharge = cms.bool(False),                   # False = any value of the charge of MC and RECO is ok
-    maxDeltaR   = cms.double(0.4),                   # Minimum deltaR for the match
-    maxDPtRel   = cms.double(3.0),                   # Minimum deltaPt/Pt for the match
-    resolveAmbiguities    = cms.bool(True),          # Forbid two RECO objects to match to the same GEN object
-    resolveByMatchQuality = cms.bool(False),         # False = just match input in order; True = pick lowest deltaR pair first
-)
-
-patJetGenJetMatch = cms.EDProducer("GenJetMatcher",    # cut on deltaR, deltaPt/Pt; pick best by deltaR
-    src         = cms.InputTag("ak5CaloJets"),       # RECO jets (any View<Jet> is ok)
-    matched     = cms.InputTag("ak5GenJets"),        # GEN jets  (must be GenJetCollection)
-    mcPdgId     = cms.vint32(),                      # n/a
-    mcStatus    = cms.vint32(),                      # n/a
-    checkCharge = cms.bool(False),                   # n/a
-    maxDeltaR   = cms.double(0.4),                   # Minimum deltaR for the match
-    maxDPtRel   = cms.double(3.0),                   # Minimum deltaPt/Pt for the match
-    resolveAmbiguities    = cms.bool(True),          # Forbid two RECO objects to match to the same GEN object
-    resolveByMatchQuality = cms.bool(False),         # False = just match input in order; True = pick lowest deltaR pair first
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/mcMatchLayer0/mcMatchSequences_cff.py b/PhysicsTools/PatAlgos/python/mcMatchLayer0/mcMatchSequences_cff.py
deleted file mode 100644
index 08c44aa..0000000
--- a/PhysicsTools/PatAlgos/python/mcMatchLayer0/mcMatchSequences_cff.py
+++ /dev/null
@@ -1,27 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.mcMatchLayer0.electronMatch_cfi import *
-from PhysicsTools.PatAlgos.mcMatchLayer0.muonMatch_cfi import *
-from PhysicsTools.PatAlgos.mcMatchLayer0.tauMatch_cfi import *
-from PhysicsTools.PatAlgos.mcMatchLayer0.photonMatch_cfi import *
-from PhysicsTools.PatAlgos.mcMatchLayer0.jetMatch_cfi import *
-from PhysicsTools.PatAlgos.mcMatchLayer0.jetFlavourId_cff import *
-from PhysicsTools.JetMCAlgos.TauGenJets_cfi import tauGenJets
-
-
-patMCTruth_LeptonPhoton = cms.Sequence (electronMatch+
-                                        muonMatch+
-                                        photonMatch)
-
-patMCTruth_Jet = cms.Sequence ( patJetPartonMatch +
-                                patJetGenJetMatch +
-                                patJetFlavourId )
-
-patMCTruth_Tau =  cms.Sequence ( tauMatch+
-                                 tauGenJets*
-                                 tauGenJetMatch )
-
-patMCTruth = cms.Sequence(patMCTruth_LeptonPhoton+
-                          patMCTruth_Jet+
-                          patMCTruth_Tau )
-
diff --git a/PhysicsTools/PatAlgos/python/mcMatchLayer0/muonMatch_cfi.py b/PhysicsTools/PatAlgos/python/mcMatchLayer0/muonMatch_cfi.py
deleted file mode 100644
index 4f844d7..0000000
--- a/PhysicsTools/PatAlgos/python/mcMatchLayer0/muonMatch_cfi.py
+++ /dev/null
@@ -1,19 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-#
-# Example for a configuration of the MC match
-# for muons (cuts are NOT tuned)
-# (using old values from TQAF, january 2008)
-#
-muonMatch = cms.EDProducer("MCMatcher", # cut on deltaR, deltaPt/Pt; pick best by deltaR
-    src     = cms.InputTag("muons"), # RECO objects to match  
-    matched = cms.InputTag("genParticles"),   # mc-truth particle collection
-    mcPdgId     = cms.vint32(13), # one or more PDG ID (13 = muon); absolute values (see below)
-    checkCharge = cms.bool(True), # True = require RECO and MC objects to have the same charge
-    mcStatus = cms.vint32(1),     # PYTHIA status code (1 = stable, 2 = shower, 3 = hard scattering)
-    maxDeltaR = cms.double(0.5),  # Minimum deltaR for the match
-    maxDPtRel = cms.double(0.5),  # Minimum deltaPt/Pt for the match
-    resolveAmbiguities = cms.bool(True),     # Forbid two RECO objects to match to the same GEN object
-    resolveByMatchQuality = cms.bool(False), # False = just match input in order; True = pick lowest deltaR pair first
-)
-
diff --git a/PhysicsTools/PatAlgos/python/mcMatchLayer0/photonMatch_cfi.py b/PhysicsTools/PatAlgos/python/mcMatchLayer0/photonMatch_cfi.py
deleted file mode 100644
index 207dea9..0000000
--- a/PhysicsTools/PatAlgos/python/mcMatchLayer0/photonMatch_cfi.py
+++ /dev/null
@@ -1,20 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-#
-# Example for a configuration of the MC match
-# for photons (cuts are NOT tuned)
-# (using old values from TQAF, january 2008)
-#
-photonMatch = cms.EDProducer("MCMatcher", # cut on deltaR, deltaPt/Pt; pick best by deltaR
-    src = cms.InputTag("photons"), # RECO objects to match
-    matched = cms.InputTag("genParticles"),       # mc-truth particle collection
-    mcPdgId     = cms.vint32(22), # one or more PDG ID (11 = electron); absolute values (see below)
-    checkCharge = cms.bool(True), # True = require RECO and MC objects to have the same charge
-    mcStatus = cms.vint32(1),     # PYTHIA status code (1 = stable, 2 = shower, 3 = hard scattering)
-    maxDeltaR = cms.double(0.2),  # Minimum deltaR for the match
-    maxDPtRel = cms.double(1.0),  # Minimum deltaPt/Pt for the match
-    resolveAmbiguities = cms.bool(True),     # Forbid two RECO objects to match to the same GEN object
-    resolveByMatchQuality = cms.bool(False), # False = just match input in order; True = pick lowest deltaR pair first
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/mcMatchLayer0/tauMatch_cfi.py b/PhysicsTools/PatAlgos/python/mcMatchLayer0/tauMatch_cfi.py
deleted file mode 100644
index f4db77c..0000000
--- a/PhysicsTools/PatAlgos/python/mcMatchLayer0/tauMatch_cfi.py
+++ /dev/null
@@ -1,31 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-#
-# Example for a configuration of the MC match
-# for taus (cuts are NOT tuned)
-# (using old values from TQAF, january 2008)
-#
-tauMatch = cms.EDProducer("MCMatcher",
-    src         = cms.InputTag("hpsPFTauProducer"),          # RECO objects to match
-    matched     = cms.InputTag("genParticles"),              # mc-truth particle collection
-    mcPdgId     = cms.vint32(15),                            # one or more PDG ID (15 = tau); absolute values (see below)
-    checkCharge = cms.bool(True),                            # True = require RECO and MC objects to have the same charge
-    mcStatus    = cms.vint32(2),                             # PYTHIA status code (1 = stable, 2 = shower, 3 = hard scattering)
-                                                             # NOTE that Taus can only be status 3 or 2, never 1!
-    maxDeltaR   = cms.double(999.9),                         # Minimum deltaR for the match.     By default any deltaR is allowed (why??)
-    maxDPtRel   = cms.double(999.9),                         # Minimum deltaPt/Pt for the match. By default anything is allowed   ( ""  )
-    resolveAmbiguities    = cms.bool(True),                  # Forbid two RECO objects to match to the same GEN object
-    resolveByMatchQuality = cms.bool(False),                 # False = just match input in order; True = pick lowest deltaR pair first
-)
-
-tauGenJetMatch = cms.EDProducer("GenJetMatcher",             # cut on deltaR, deltaPt/Pt; pick best by deltaR
-    src         = cms.InputTag("hpsPFTauProducer"),          # RECO jets (any View<Jet> is ok)
-    matched     = cms.InputTag("tauGenJetsSelectorAllHadrons"),  # GEN jets  (must be GenJetCollection)
-    mcPdgId     = cms.vint32(),                              # n/a
-    mcStatus    = cms.vint32(),                              # n/a
-    checkCharge = cms.bool(False),                           # n/a
-    maxDeltaR   = cms.double(0.1),                           # Minimum deltaR for the match
-    maxDPtRel   = cms.double(3.0),                           # Minimum deltaPt/Pt for the match
-    resolveAmbiguities    = cms.bool(True),                  # Forbid two RECO objects to match to the same GEN object
-    resolveByMatchQuality = cms.bool(False),                 # False = just match input in order; True = pick lowest deltaR pair first
-)
diff --git a/PhysicsTools/PatAlgos/python/mcMatchLayer0/trackMuMatch_cfi.py b/PhysicsTools/PatAlgos/python/mcMatchLayer0/trackMuMatch_cfi.py
deleted file mode 100644
index bba604a..0000000
--- a/PhysicsTools/PatAlgos/python/mcMatchLayer0/trackMuMatch_cfi.py
+++ /dev/null
@@ -1,19 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-#
-# Example for a configuration of the MC match
-# for muons (cuts are NOT tuned)
-# (using old values from TQAF, january 2008)
-#
-trackMuMatch = cms.EDProducer("MCMatcher", # cut on deltaR, deltaPt/Pt; pick best by deltaR
-    src     = cms.InputTag("allLayer0TrackCands"), # RECO objects to match  
-    matched = cms.InputTag("genParticles"),   # mc-truth particle collection
-    mcPdgId     = cms.vint32(13), # one or more PDG ID (13 = muon); absolute values (see below)
-    checkCharge = cms.bool(True), # True = require RECO and MC objects to have the same charge
-    mcStatus = cms.vint32(1),     # PYTHIA status code (1 = stable, 2 = shower, 3 = hard scattering)
-    maxDeltaR = cms.double(0.5),  # Minimum deltaR for the match
-    maxDPtRel = cms.double(0.5),  # Minimum deltaPt/Pt for the match
-    resolveAmbiguities = cms.bool(True),     # Forbid two RECO objects to match to the same GEN object
-    resolveByMatchQuality = cms.bool(False), # False = just match input in order; True = pick lowest deltaR pair first
-)
-
diff --git a/PhysicsTools/PatAlgos/python/patEventContent_cff.py b/PhysicsTools/PatAlgos/python/patEventContent_cff.py
deleted file mode 100644
index d3b2cfe..0000000
--- a/PhysicsTools/PatAlgos/python/patEventContent_cff.py
+++ /dev/null
@@ -1,91 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patEventContentNoCleaning = [
-    'keep *_selectedPatPhotons*_*_*',
-    'keep *_selectedPatElectrons*_*_*',
-    'keep *_selectedPatMuons*_*_*',
-    'keep *_selectedPatTaus*_*_*',
-    'keep *_selectedPatJets*_*_*',
-    'drop *_selectedPatJets_pfCandidates_*', ## drop for default patJets which are CaloJets
-    'drop *_*PF_caloTowers_*',
-    'drop *_*JPT_pfCandidates_*',
-    'drop *_*Calo_pfCandidates_*',
-    'keep *_patMETs*_*_*',
-    'keep *_selectedPatPFParticles*_*_*',
-    'keep *_selectedPatTrackCands*_*_*'
-]
-
-patEventContent = [
-    'keep *_selectedPatJets*_*_*',           ## keep refactorized pat jet elements
-    'drop patJets_selectedPatJets*_*_*',     ## drop the actual selected pat jets, they're redundant
-    'drop *_selectedPatJets_pfCandidates_*', ## drop for default patJets which are CaloJets
-    'drop *_*PF_caloTowers_*',               ## drop collections not needed for the corresponding jet types
-    'drop *_*JPT_pfCandidates_*',            ## drop collections not needed for the corresponding jet types
-    'drop *_*Calo_pfCandidates_*',           ## drop collections not needed for the corresponding jet types
-    'keep *_cleanPatPhotons*_*_*',
-    'keep *_cleanPatElectrons*_*_*',
-    'keep *_cleanPatMuons*_*_*',
-    'keep *_cleanPatTaus*_*_*',
-    'keep *_cleanPatJets*_*_*',
-    'keep *_patMETs*_*_*',
-    'keep *_cleanPatHemispheres*_*_*',
-    'keep *_cleanPatPFParticles*_*_*',
-    'keep *_cleanPatTrackCands*_*_*'
-]
-
-patExtraAodEventContent = [
-    # GEN
-    'keep recoGenParticles_genParticles*_*_*',
-    'keep GenEventInfoProduct_*_*_*',
-    'keep GenRunInfoProduct_*_*_*',
-    # RECO
-    'keep recoTracks_generalTracks*_*_*',
-    'keep *_towerMaker_*_*',
-    'keep *_offlineBeamSpot_*_*',
-    'keep *_offlinePrimaryVertices*_*_*',
-    # TRIGGER
-    'keep edmTriggerResults_TriggerResults*_*_*',
-    'keep *_hltTriggerSummaryAOD_*_*',
-    'keep L1GlobalTriggerReadoutRecord_gtDigis_*_*',
-    # COND
-    'keep edmConditionsIn*Block_conditionsInEdm_*_*'
-]
-
-patTriggerEventContent = [
-    'keep patTriggerAlgorithms_patTrigger_*_*',
-    'keep patTriggerConditions_patTrigger_*_*',
-    'keep patTriggerObjects_patTrigger_*_*',
-    'keep patTriggerFilters_patTrigger_*_*',
-    'keep patTriggerPaths_patTrigger_*_*',
-    'keep *_patTriggerEvent_*_*'
-]
-patTriggerStandAloneEventContent = [
-    'keep patTriggerObjectStandAlones_patTrigger_*_*',
-    'keep patTriggerObjectStandAlonesedmAssociation_*_*_*'
-]
-patTriggerL1RefsEventContent = [
-    'keep *_l1extraParticles_*_*',
-    'keep *_gctDigis_*_*'
-]
-
-patEventContentTriggerMatch = [
-    'keep *_*PatPhotons*TriggerMatch_*_*',
-    'keep *_*PatElectrons*TriggerMatch_*_*',
-    'keep *_*PatMuons*TriggerMatch_*_*',
-    'keep *_*PatTaus*TriggerMatch_*_*',
-    'keep *_*PatJets*TriggerMatch_*_*',
-    'keep *_patMETs*TriggerMatch_*_*'
-]
-
-patHiEventContent = [
-    'keep patPhotons_selected*_*_*',
-    'keep patMuons_selected*_*_*',
-    'keep patJets_selected*_*_*',
-    'keep patHeavyIon_heavyIon_*_*'
-]
-
-patHiExtraAodEventContent = [
-    'keep recoGenParticles_hiGenParticles*_*_*',
-    'keep recoGenJets_iterativeCone5HiGenJets*_*_*', # until a better solution
-    'keep recoTracks_hiSelectedTracks*_*_*'
-]
diff --git a/PhysicsTools/PatAlgos/python/patHeavyIonSequences_cff.py b/PhysicsTools/PatAlgos/python/patHeavyIonSequences_cff.py
deleted file mode 100644
index 731bbd0..0000000
--- a/PhysicsTools/PatAlgos/python/patHeavyIonSequences_cff.py
+++ /dev/null
@@ -1,14 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# make heavyIonPatCandidates
-from PhysicsTools.PatAlgos.producersHeavyIons.heavyIonPatCandidates_cff import *
-
-# make selectedLayer1Objects
-from PhysicsTools.PatAlgos.selectionLayer1.selectedPatCandidates_cff import *
-
-patHeavyIonDefaultSequence = cms.Sequence(
-    heavyIonPatCandidates  * 
-    selectedPatJets        *
-    selectedPatMuons       *
-    selectedPatPhotons
-)
diff --git a/PhysicsTools/PatAlgos/python/patInputFiles_cff.py b/PhysicsTools/PatAlgos/python/patInputFiles_cff.py
deleted file mode 100644
index 4b10d7f..0000000
--- a/PhysicsTools/PatAlgos/python/patInputFiles_cff.py
+++ /dev/null
@@ -1,30 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-from PhysicsTools.PatAlgos.tools.cmsswVersionTools import pickRelValInputFiles
-
-filesRelValProdTTbarAODSIM = cms.untracked.vstring(
-    pickRelValInputFiles( cmsswVersion  = 'CMSSW_5_3_6'
-                        , relVal        = 'RelValProdTTbar'
-                        , globalTag     = 'START53_V14'
-                        , dataTier      = 'AODSIM'
-                        , maxVersions   = 2
-                        , numberOfFiles = 1
-                        )
-    )
-filesRelValProdTTbarGENSIMRECO = cms.untracked.vstring(
-    pickRelValInputFiles( cmsswVersion  = 'CMSSW_5_3_6'
-                        , relVal        = 'RelValProdTTbar'
-                        , globalTag     = 'START53_V14'
-                        , dataTier      = 'GEN-SIM-RECO'
-                        , maxVersions   = 2
-                        , numberOfFiles = 1
-                        )
-    )
-filesSingleMuRECO = cms.untracked.vstring(
-    pickRelValInputFiles( cmsswVersion  = 'CMSSW_5_3_6'
-                        , relVal        = 'SingleMu'
-                        , dataTier      = 'RECO'
-                        , globalTag     = 'GR_R_53_V15_RelVal_mu2012B'
-                        , maxVersions   = 2
-                        , numberOfFiles = 1
-                        )
-    )
diff --git a/PhysicsTools/PatAlgos/python/patSequences_cff.py b/PhysicsTools/PatAlgos/python/patSequences_cff.py
deleted file mode 100644
index 55c094a..0000000
--- a/PhysicsTools/PatAlgos/python/patSequences_cff.py
+++ /dev/null
@@ -1,20 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# make patCandidates
-from PhysicsTools.PatAlgos.producersLayer1.patCandidates_cff import *
-
-# make selectedPatCandidates
-from PhysicsTools.PatAlgos.selectionLayer1.selectedPatCandidates_cff import *
-
-# make cleanPatCandidates
-from PhysicsTools.PatAlgos.cleaningLayer1.cleanPatCandidates_cff import *
-
-# count cleanPatCandidates (including total number of leptons)
-from PhysicsTools.PatAlgos.selectionLayer1.countPatCandidates_cff import *
-
-patDefaultSequence = cms.Sequence(
-    patCandidates * 
-    selectedPatCandidates *
-    cleanPatCandidates *
-    countPatCandidates
-)
diff --git a/PhysicsTools/PatAlgos/python/patTemplate_cfg.py b/PhysicsTools/PatAlgos/python/patTemplate_cfg.py
deleted file mode 100644
index feb3b89..0000000
--- a/PhysicsTools/PatAlgos/python/patTemplate_cfg.py
+++ /dev/null
@@ -1,40 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-process = cms.Process("PAT")
-
-## MessageLogger
-process.load("FWCore.MessageLogger.MessageLogger_cfi")
-
-## Options and Output Report
-process.options = cms.untracked.PSet( wantSummary = cms.untracked.bool(True) )
-
-## Source
-process.source = cms.Source("PoolSource",
-    fileNames = cms.untracked.vstring()
-)
-## Maximal Number of Events
-process.maxEvents = cms.untracked.PSet( input = cms.untracked.int32(100) )
-
-## Geometry and Detector Conditions (needed for a few patTuple production steps)
-process.load("Configuration.Geometry.GeometryIdeal_cff")
-process.load("Configuration.StandardSequences.FrontierConditions_GlobalTag_cff")
-#from Configuration.AlCa.autoCond import autoCond
-#process.GlobalTag.globaltag = cms.string( autoCond[ 'startup' ] )
-process.GlobalTag.globaltag = cms.string( 'START53_V27::All' )
-process.load("Configuration.StandardSequences.MagneticField_cff")
-
-## Standard PAT Configuration File
-process.load("PhysicsTools.PatAlgos.patSequences_cff")
-
-## Output Module Configuration (expects a path 'p')
-from PhysicsTools.PatAlgos.patEventContent_cff import patEventContent
-process.out = cms.OutputModule("PoolOutputModule",
-                               fileName = cms.untracked.string('patTuple.root'),
-                               # save only events passing the full path
-                               SelectEvents   = cms.untracked.PSet( SelectEvents = cms.vstring('p') ),
-                               # save PAT Layer 1 output; you need a '*' to
-                               # unpack the list of commands 'patEventContent'
-                               outputCommands = cms.untracked.vstring('drop *', *patEventContent )
-                               )
-
-process.outpath = cms.EndPath(process.out)
diff --git a/PhysicsTools/PatAlgos/python/patTestJEC_cfi.py b/PhysicsTools/PatAlgos/python/patTestJEC_cfi.py
deleted file mode 100644
index be29a6a..0000000
--- a/PhysicsTools/PatAlgos/python/patTestJEC_cfi.py
+++ /dev/null
@@ -1,48 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# Be sure to change the "V5" to whatever is in your payloads. 
-from CondCore.DBCommon.CondDBSetup_cfi import *
-jec = cms.ESSource("PoolDBESSource",CondDBSetup,
-                   connect = cms.string("frontier://FrontierPrep/CMS_COND_PHYSICSTOOLS"),
-                   toGet =  cms.VPSet(
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_AK5Calo"),
-                                label=cms.untracked.string("AK5Calo")),
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_AK5PF"),
-                                label=cms.untracked.string("AK5PF")),                                   
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_AK5JPT"),
-                                label=cms.untracked.string("AK5JPT")),
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_AK5TRK"),
-                                label=cms.untracked.string("AK5TRK")),
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_AK7Calo"),
-                                label=cms.untracked.string("AK7Calo")),
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_AK7PF"),
-                                label=cms.untracked.string("AK7PF")),
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_IC5Calo"),
-                                label=cms.untracked.string("IC5Calo")),
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_IC5PF"),
-                                label=cms.untracked.string("IC5PF")),
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_KT4Calo"),
-                                label=cms.untracked.string("KT4Calo")),
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_KT4PF"),
-                                label=cms.untracked.string("KT4PF")),
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_KT6Calo"),
-                                label=cms.untracked.string("KT6PF")),
-                       cms.PSet(record = cms.string("JetCorrectionsRecord"),
-                                tag = cms.string("JetCorrectorParametersCollection_Jec10V1_KT6PF"),
-                                label=cms.untracked.string("KT6PF")),
-                       )
-                   
-                   )
-
-es_prefer_jec = cms.ESPrefer("PoolDBESSource","jec")
diff --git a/PhysicsTools/PatAlgos/python/patTestJEC_local_cfi.py b/PhysicsTools/PatAlgos/python/patTestJEC_local_cfi.py
deleted file mode 100644
index 8bd1b92..0000000
--- a/PhysicsTools/PatAlgos/python/patTestJEC_local_cfi.py
+++ /dev/null
@@ -1,20 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from CondCore.DBCommon.CondDBCommon_cfi import *
-jec = cms.ESSource("PoolDBESSource",
-      DBParameters = cms.PSet(
-        messageLevel = cms.untracked.int32(0)
-        ),
-      timetype = cms.string('runnumber'),
-      toGet = cms.VPSet(
-      cms.PSet(
-            record = cms.string('JetCorrectionsRecord'),
-            tag    = cms.string('JetCorrectorParametersCollection_Jec43x_AK5PF'),
-            label  = cms.untracked.string('AK5PF')
-            )
-      ),
-      ## here you add as many jet types as you need (AK5Calo, AK5JPT, AK7PF, AK7Calo, KT4PF, KT4Calo, KT6PF, KT6Calo)
-      connect = cms.string('sqlite_file:Jec43x.db')
-)
-
-es_prefer_jec = cms.ESPrefer('PoolDBESSource','jec')
diff --git a/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonJets_cff.py b/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonJets_cff.py
deleted file mode 100644
index 205d557..0000000
--- a/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonJets_cff.py
+++ /dev/null
@@ -1,19 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.producersLayer1.jetProducer_cff import *
-from RecoHI.HiJetAlgos.HiGenCleaner_cff import *
-heavyIonCleaned = cms.Sequence(genPartons*hiPartons+heavyIonCleanedGenJets)
-
-makeHeavyIonJets = cms.Sequence(
-    patJetCorrections *
-
-    # pat and HI specifics
-    heavyIonCleaned *
-    patJetGenJetMatch *
-    patJetPartonMatch *
-
-    # object production
-    patJets
-    )
-
-
diff --git a/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonMuons_cff.py b/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonMuons_cff.py
deleted file mode 100644
index 168444c..0000000
--- a/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonMuons_cff.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.producersLayer1.muonProducer_cff import *
-
-makeHeavyIonMuons = cms.Sequence(
-    # pat and HI specifics
-    muonMatch *
-    # object production
-    patMuons
-    )
-
-
diff --git a/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonPatCandidates_cff.py b/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonPatCandidates_cff.py
deleted file mode 100644
index e03e845..0000000
--- a/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonPatCandidates_cff.py
+++ /dev/null
@@ -1,13 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.producersHeavyIons.heavyIonJets_cff import *
-from PhysicsTools.PatAlgos.producersHeavyIons.heavyIonMuons_cff import *
-from PhysicsTools.PatAlgos.producersHeavyIons.heavyIonPhotons_cff import *
-from PhysicsTools.PatAlgos.producersHeavyIons.heavyIonProducer_cfi import *
-
-heavyIonPatCandidates = cms.Sequence(
-    heavyIon +
-    makeHeavyIonJets +
-    makeHeavyIonPhotons +
-    makeHeavyIonMuons
-)
diff --git a/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonPhotons_cff.py b/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonPhotons_cff.py
deleted file mode 100644
index f549d9e..0000000
--- a/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonPhotons_cff.py
+++ /dev/null
@@ -1,18 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.producersLayer1.photonProducer_cff import *
-# (must be decleared after PAT sequence Yen-Jie)
-from RecoHI.HiEgammaAlgos.HiEgammaIsolation_cff import *
-
-makeHeavyIonPhotons = cms.Sequence(
-    # reco pre-production
-    hiEgammaIsolationSequence *
-    patPhotonIsolation *
-    # pat and HI specifics    
-    photonMatch *
-    # object production
-    patPhotons
-    )
-
-
-
diff --git a/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonProducer_cfi.py
deleted file mode 100644
index 7a4de97..0000000
--- a/PhysicsTools/PatAlgos/python/producersHeavyIons/heavyIonProducer_cfi.py
+++ /dev/null
@@ -1,10 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-heavyIon = cms.EDProducer("GenHIEventProducer",
-  doReco     = cms.bool(True),
-  doMC       = cms.bool(True),
-  generators = cms.vstring("generator")
-)
-
-
-
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/electronProducer_cff.py b/PhysicsTools/PatAlgos/python/producersLayer1/electronProducer_cff.py
deleted file mode 100644
index e8050f0..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/electronProducer_cff.py
+++ /dev/null
@@ -1,21 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# prepare reco information
-from PhysicsTools.PatAlgos.recoLayer0.electronId_cff import *
-from PhysicsTools.PatAlgos.recoLayer0.electronIsolation_cff import *
-
-# add PAT specifics
-from PhysicsTools.PatAlgos.mcMatchLayer0.electronMatch_cfi import *
-
-# produce object
-from PhysicsTools.PatAlgos.producersLayer1.electronProducer_cfi import *
-
-makePatElectrons = cms.Sequence(
-    # reco pre-production
-    # patElectronId *
-    # patElectronIsolation *
-    # pat specifics
-    electronMatch *
-    # object production
-    patElectrons
-    )
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/electronProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersLayer1/electronProducer_cfi.py
deleted file mode 100644
index 6953d7e5..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/electronProducer_cfi.py
+++ /dev/null
@@ -1,91 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patElectrons = cms.EDProducer("PATElectronProducer",
-    # input collection
-    electronSource = cms.InputTag("gsfElectrons"),
-
-    # use particle flow instead of std reco
-    useParticleFlow  =  cms.bool( False ),
-    pfElectronSource = cms.InputTag("particleFlow"),
-    pfCandidateMap = cms.InputTag("particleFlow:electrons"),
-
-    # collections for mva input variables
-    reducedBarrelRecHitCollection = cms.InputTag("reducedEcalRecHitsEB"),
-    reducedEndcapRecHitCollection = cms.InputTag("reducedEcalRecHitsEE"),
-
-    # user data to add
-    userData = cms.PSet(
-      # add custom classes here
-      userClasses = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add doubles here
-      userFloats = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add ints here
-      userInts = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add candidate ptrs here
-      userCands = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add "inline" functions here
-      userFunctions = cms.vstring(),
-      userFunctionLabels = cms.vstring()
-    ),
-
-    # embedding of AOD items
-    embedGsfElectronCore = cms.bool(True),  ## embed in AOD externally stored gsf electron core
-    embedGsfTrack        = cms.bool(True),  ## embed in AOD externally stored gsf track
-    embedSuperCluster    = cms.bool(True),  ## embed in AOD externally stored supercluster
-    embedPflowSuperCluster         = cms.bool(True),  ## embed in AOD externally stored supercluster
-    embedSeedCluster               = cms.bool(True),  ## embed in AOD externally stored the electron's seedcluster 
-    embedBasicClusters             = cms.bool(True),  ## embed in AOD externally stored the electron's basic clusters 
-    embedPreshowerClusters         = cms.bool(True),  ## embed in AOD externally stored the electron's preshower clusters 
-    embedPflowBasicClusters        = cms.bool(True),  ## embed in AOD externally stored the electron's pflow basic clusters 
-    embedPflowPreshowerClusters    = cms.bool(True),  ## embed in AOD externally stored the electron's pflow preshower clusters 
-    embedPFCandidate     = cms.bool(True),  ## embed in AOD externally stored particle flow candidate
-    embedTrack           = cms.bool(True), ## embed in AOD externally stored track (note: gsf electrons don't have a track)
-    embedRecHits         = cms.bool(True),  ## embed in AOD externally stored the RecHits - can be called from the PATElectronProducer 
-
-    # embed IsoDeposits to recompute isolation
-    isoDeposits = cms.PSet(),
-
-    # user defined isolation variables the variables defined here will be accessible
-    # via pat::Electron::userIsolation(IsolationKeys key) with the key as defined in
-    # DataFormats/PatCandidates/interface/Isolation.h
-    userIsolation = cms.PSet(),
-
-    # electron ID
-    addElectronID = cms.bool(True),
-    electronIDSources = cms.PSet(
-        # configure many IDs as InputTag <someName> = <someTag> you
-        # can comment out those you don't want to save some disk space
-        eidRobustLoose      = cms.InputTag("eidRobustLoose"),
-        eidRobustTight      = cms.InputTag("eidRobustTight"),
-        eidLoose            = cms.InputTag("eidLoose"),
-        eidTight            = cms.InputTag("eidTight"),
-        eidRobustHighEnergy = cms.InputTag("eidRobustHighEnergy"),
-    ),
-
-    # mc matching
-    addGenMatch      = cms.bool(True),
-    embedGenMatch    = cms.bool(True),
-    genParticleMatch = cms.InputTag("electronMatch"), ## Association between electrons and generator particles
-
-    # efficiencies
-    addEfficiencies = cms.bool(False),
-    efficiencies    = cms.PSet(),
-
-    # resolution configurables
-    addResolutions   = cms.bool(False),
-    resolutions      = cms.PSet(),
-
-    # high level selections
-    embedHighLevelSelection = cms.bool(True),
-    usePV                   = cms.bool(True),
-    beamLineSrc             = cms.InputTag("offlineBeamSpot"),
-    pvSrc                   = cms.InputTag("offlinePrimaryVertices")
-)
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/genericParticleProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersLayer1/genericParticleProducer_cfi.py
deleted file mode 100644
index 76e2936..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/genericParticleProducer_cfi.py
+++ /dev/null
@@ -1,67 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# NOTE: THIS IS JUST A SKELETON, YOU SHOULD FILL IT IN WITH "replace"
-
-patGenericParticles = cms.EDProducer("PATGenericParticleProducer",
-    ## Input (anything readable with View<Candidate>
-    src = cms.InputTag("REPLACE_ME"),
-
-    # add user data
-    userData = cms.PSet(
-      # add custom classes here
-      userClasses = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add doubles here
-      userFloats = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add ints here
-      userInts = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add candidate ptrs here
-      userCands = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add "inline" functions here
-      userFunctions = cms.vstring(),
-      userFunctionLabels = cms.vstring()
-    ),
-
-    # AOD embedding
-    embedTrack          = cms.bool(False),
-    embedGsfTrack       = cms.bool(False), ## whether to embed in AOD externally stored gsf track
-    embedStandAloneMuon = cms.bool(False), ## whether to embed in AOD externally stored standalone muon track
-    embedCombinedMuon   = cms.bool(False), ## whether to embed in AOD externally stored combined muon track
-    embedMultipleTracks = cms.bool(False), ## whether to embed in AOD externally stored multiple tracks (as per recoCandidate.track(int idx) )
-    embedSuperCluster   = cms.bool(False), ## whether to embed in AOD externally stored supercluster
-    embedCaloTower      = cms.bool(False), ## whether to embed in AOD externally stored calo tower
-
-    # embed IsoDeposits to recompute isolation
-    isoDeposits = cms.PSet(
-    ),
-
-    # user defined isolation variables the variables defined here will be accessible
-    # via pat::GenericParticle::userIsolation(IsolationKeys key) with the key as defined in
-    # DataFormats/PatCandidates/interface/Isolation.h
-    userIsolation = cms.PSet(
-    ),
-                                           
-    # any sort of "quality" value
-    addQuality = cms.bool(False),
-    qualitySource = cms.InputTag("REPLACE_ME"), ## must be ValueMap<float> associated to the input collection
-
-    # MC matching configurables
-    addGenMatch = cms.bool(False),
-    embedGenMatch = cms.bool(False),
-    genParticleMatch = cms.InputTag("REPLACE_ME"), ## particles source to be used for the matching
-
-    # Efficiencies
-    addEfficiencies = cms.bool(False),
-    efficiencies    = cms.PSet(),
-
-    # resolution
-    addResolutions  = cms.bool(False),
-    resolutions     = cms.PSet(),
-)
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/hemisphereProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersLayer1/hemisphereProducer_cfi.py
deleted file mode 100644
index d362144..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/hemisphereProducer_cfi.py
+++ /dev/null
@@ -1,24 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patHemispheres = cms.EDProducer("PATHemisphereProducer",
-    patElectrons = cms.InputTag("cleanLayer1Electrons"),
-    patJets      = cms.InputTag("cleanLayer1Jets"),
-    patMuons     = cms.InputTag("cleanLayer1Muons"),
-    patPhotons   = cms.InputTag("cleanLayer1Photons"),
-    patTaus      = cms.InputTag("cleanLayer1Taus"),
-    patMets      = cms.InputTag("layer1METs"),
-
-    minJetEt = cms.double(30),
-    minMuonEt = cms.double(7),
-    minElectronEt = cms.double(7),
-    minTauEt = cms.double(1000000),
-    minPhotonEt = cms.double(200000),
-    maxJetEta = cms.double(5),
-    maxMuonEta = cms.double(5),
-    maxElectronEta = cms.double(5),
-    maxTauEta = cms.double(-1),
-    maxPhotonEta = cms.double(5),
-
-    seedMethod        = cms.int32(3),
-    combinationMethod = cms.int32(3),
-)
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/jetProducer_cff.py b/PhysicsTools/PatAlgos/python/producersLayer1/jetProducer_cff.py
deleted file mode 100644
index c495404..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/jetProducer_cff.py
+++ /dev/null
@@ -1,28 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# prepare reco information
-from PhysicsTools.PatAlgos.recoLayer0.jetTracksCharge_cff import *
-from PhysicsTools.PatAlgos.recoLayer0.jetMETCorrections_cff import *
-from PhysicsTools.PatAlgos.recoLayer0.bTagging_cff import *
-#from PhysicsTools.PatAlgos.recoLayer0.jetID_cff import *
-
-# add PAT specifics
-from PhysicsTools.PatAlgos.mcMatchLayer0.jetFlavourId_cff import *
-from PhysicsTools.PatAlgos.mcMatchLayer0.jetMatch_cfi import *
-
-# produce object
-from PhysicsTools.PatAlgos.producersLayer1.jetProducer_cfi import *
-
-makePatJets = cms.Sequence(
-    # reco pre-production
-    patJetCorrections *
-    patJetCharge *
-   #secondaryVertexNegativeTagInfos *
-   #simpleSecondaryVertexNegativeBJetTags *
-    # pat specifics
-    patJetPartonMatch *
-    patJetGenJetMatch *
-    patJetFlavourId *
-    # object production
-    patJets
-    )
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/jetProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersLayer1/jetProducer_cfi.py
deleted file mode 100644
index 5193c16..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/jetProducer_cfi.py
+++ /dev/null
@@ -1,97 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patJets = cms.EDProducer("PATJetProducer",
-    # input
-    jetSource = cms.InputTag("ak5CaloJets"),
-                               
-    # add user data
-    userData = cms.PSet(
-      # add custom classes here
-      userClasses = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add doubles here
-      userFloats = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add ints here
-      userInts = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add candidate ptrs here
-      userCands = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add "inline" functions here
-      userFunctions = cms.vstring(),
-      userFunctionLabels = cms.vstring()
-    ),
-    
-    # embedding of AOD items
-    embedCaloTowers = cms.bool(True), ## switch on/off embedding of supercluster (externally stored in AOD)
-    embedPFCandidates = cms.bool(True), 
-
-    # jet energy corrections
-    addJetCorrFactors    = cms.bool(True),
-    jetCorrFactorsSource = cms.VInputTag(cms.InputTag("patJetCorrFactors") ),
-
-    # btag information
-    addBTagInfo          = cms.bool(True),   ## master switch
-    addDiscriminators    = cms.bool(True),   ## addition btag discriminators
-    discriminatorSources = cms.VInputTag(
-        cms.InputTag("combinedSecondaryVertexBJetTags"),
-        cms.InputTag("combinedSecondaryVertexMVABJetTags"),
-        cms.InputTag("jetBProbabilityBJetTags"),
-        cms.InputTag("jetProbabilityBJetTags"),
-        cms.InputTag("simpleSecondaryVertexHighEffBJetTags"),
-        cms.InputTag("simpleSecondaryVertexHighPurBJetTags"),
-        cms.InputTag("softElectronByPtBJetTags"),                
-        cms.InputTag("softElectronByIP3dBJetTags"),
-        cms.InputTag("softMuonBJetTags"),
-        cms.InputTag("softMuonByPtBJetTags"),                
-        cms.InputTag("softMuonByIP3dBJetTags"),
-        cms.InputTag("trackCountingHighEffBJetTags"),
-        cms.InputTag("trackCountingHighPurBJetTags"),
-    ),
-    # clone tag infos ATTENTION: these take lots of space!
-    # usually the discriminators from the default algos
-    # are sufficient
-    addTagInfos     = cms.bool(False),
-    tagInfoSources  = cms.VInputTag(),
-
-    # track association
-    addAssociatedTracks    = cms.bool(True),
-    trackAssociationSource = cms.InputTag("ak5JetTracksAssociatorAtVertex"),
-
-    # jet charge
-    addJetCharge    = cms.bool(True),
-    jetChargeSource = cms.InputTag("patJetCharge"),
-
-    # add jet ID
-    addJetID = cms.bool(True),
-    jetIDMap = cms.InputTag("ak5JetID"),
-
-    # mc matching
-    addGenPartonMatch   = cms.bool(True),                           ## switch on/off matching to quarks from hard scatterin
-    embedGenPartonMatch = cms.bool(True),                           ## switch on/off embedding of the GenParticle parton for this jet
-    genPartonMatch      = cms.InputTag("patJetPartonMatch"),        ## particles source to be used for the matching
-    addGenJetMatch      = cms.bool(True),                           ## switch on/off matching to GenJet's
-    embedGenJetMatch    = cms.bool(True),                           ## switch on/off embedding of matched genJet's
-    genJetMatch         = cms.InputTag("patJetGenJetMatch"),        ## GenJet source to be used for the matching
-    addPartonJetMatch   = cms.bool(False),                          ## switch on/off matching to PartonJet's (not implemented yet)
-    partonJetSource     = cms.InputTag("NOT_IMPLEMENTED"),          ## ParticleJet source to be used for the matching
-
-    # jet flavour idetification configurables
-    getJetMCFlavour    = cms.bool(True),
-    JetPartonMapSource = cms.InputTag("patJetFlavourAssociation"),
-
-    # efficiencies
-    addEfficiencies = cms.bool(False),
-    efficiencies    = cms.PSet(),
-
-    # resolution
-    addResolutions = cms.bool(False),
-    resolutions     = cms.PSet()
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/metProducer_cff.py b/PhysicsTools/PatAlgos/python/producersLayer1/metProducer_cff.py
deleted file mode 100644
index 8acec7a..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/metProducer_cff.py
+++ /dev/null
@@ -1,15 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# prepare reco information
-from PhysicsTools.PatAlgos.recoLayer0.jetMETCorrections_cff import *
-
-# produce object
-from PhysicsTools.PatAlgos.producersLayer1.metProducer_cfi import *
-
-makePatMETs = cms.Sequence(
-    # reco pre-production
-    patMETCorrections *
-    # pat specifics
-    # object production
-    patMETs
-    )
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/metProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersLayer1/metProducer_cfi.py
deleted file mode 100644
index 7692e1c..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/metProducer_cfi.py
+++ /dev/null
@@ -1,47 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patMETs = cms.EDProducer("PATMETProducer",
-    # input 
-    metSource  = cms.InputTag("caloType1CorrectedMet"),
-
-    # add user data
-    userData = cms.PSet(
-      # add custom classes here
-      userClasses = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add doubles here
-      userFloats = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add ints here
-      userInts = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add candidate ptrs here
-      userCands = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add "inline" functions here
-      userFunctions = cms.vstring(),
-      userFunctionLabels = cms.vstring()
-    ),
-
-    # muon correction
-    addMuonCorrections = cms.bool(True),
-    muonSource         = cms.InputTag("muons"),
-
-    # mc matching configurables
-    addGenMET    = cms.bool(True),
-    genMETSource = cms.InputTag("genMetTrue"),
-
-    # efficiencies
-    addEfficiencies = cms.bool(False),
-    efficiencies    = cms.PSet(),
-
-    # resolution
-    addResolutions  = cms.bool(False),
-    resolutions     = cms.PSet(),
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/mhtProducer_cff.py b/PhysicsTools/PatAlgos/python/producersLayer1/mhtProducer_cff.py
deleted file mode 100644
index 7dc1818..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/mhtProducer_cff.py
+++ /dev/null
@@ -1,11 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# prepare reco information
-# from PhysicsTools.PatAlgos.recoLayer0.jetMETCorrections_cff import *
-
-# produce object
-from PhysicsTools.PatAlgos.producersLayer1.mhtProducer_cfi import *
-
-makePatMHTs = cms.Sequence(
-    patMHTs
-    )
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/mhtProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersLayer1/mhtProducer_cfi.py
deleted file mode 100644
index cbbbc83..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/mhtProducer_cfi.py
+++ /dev/null
@@ -1,71 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patMHTs = cms.EDProducer("PATMHTProducer",
-    # input 
-    verbose = cms.double(0.),
-    
-    jetTag       = cms.untracked.InputTag("allLayer1Jets"),
-    electronTag  = cms.untracked.InputTag("allLayer1Electrons"),
-    muonTag      = cms.untracked.InputTag("allLayer1Muons"),
-    tauTag       = cms.untracked.InputTag("allLayer1Taus"),
-    photonTag    = cms.untracked.InputTag("allLayer1Photons"),
-    
-    # Selection configurables
-    
-    jetPtMin      = cms.double( 20.),
-    jetEtaMax     = cms.double( 5. ),
-    jetEMfracMax  = cms.double( 0.9),
-    elePtMin      = cms.double( 10.),
-    eleEtaMax     = cms.double( 3. ),
-    muonPtMin     = cms.double( 10.),
-    muonEtaMax    = cms.double( 2.5),
-    
-    # Resolution configurables
-    
-    uncertaintyScaleFactor = cms.double(1.0 ),
-    
-    controlledUncertainty = cms.bool(True), #use controlled uncertainty parameters.
-    
-    # -------------------------------------------
-    #  Jet Uncertainties
-    # -------------------------------------------
-    # //-- values from PTDR 1, ch 11.4 --//
-    jetEtUncertaintyParameter0 = cms.double(5.6 ), 
-    jetEtUncertaintyParameter1 = cms.double(1.25),
-    jetEtUncertaintyParameter2 = cms.double(0.033),
-    
-    # // values from :
-    # http://indico.cern.ch/getFile.py/access?contribId=9&sessionId=0&resId=0&materialId=slides&confId=46394
-    jetPhiUncertaintyParameter0 =cms.double(4.75  ),
-    jetPhiUncertaintyParameter1 =cms.double(-0.426),
-    jetPhiUncertaintyParameter2 =cms.double(0.023 ), 
-    
-    # -------------------------------------------
-    #  Electron Uncertainties
-    # -------------------------------------------
-    eleEtUncertaintyParameter0  =cms.double ( 0.01),   
-    elePhiUncertaintyParameter0 =cms.double (0.01 ),  
-    
-    # -------------------------------------------
-    #  Muon Uncertainties
-    # -------------------------------------------
-
-    muonEtUncertaintyParameter0  = cms.double(0.01),   
-    muonPhiUncertaintyParameter0 = cms.double(0.01),   
- 
-    # -------------------------------------------
-    #  For MET Significance 
-    # -------------------------------------------
-   
-    #CaloTowerTag    = cms.InputTag("caloTowers"),
-    CaloTowerTag    = cms.InputTag("towerMaker"),
-    noHF            = cms.bool(False),
-    # only include towers whose Et > 0.5 since 
-    # by default the MET only includes towers with Et > 0.5
-    # from http://cmssw.cvs.cern.ch/cgi-bin/cmssw.cgi/CMSSW/JetMETCorrections/Type1MET/src/MuonMETAlgo.cc?revision=1.6&view=markup&pathrev=CMSSW_2_2_9
-    towerEtThreshold  = cms.double(0.5),   	
-    useHO  = cms.bool(False)
-    )
-    
-
-
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/muonProducer_cff.py b/PhysicsTools/PatAlgos/python/producersLayer1/muonProducer_cff.py
deleted file mode 100644
index d86d5af..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/muonProducer_cff.py
+++ /dev/null
@@ -1,18 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# prepare reco information
-# NOT NEEDED AT THE MOMENT
-
-# add PAT specifics
-from PhysicsTools.PatAlgos.mcMatchLayer0.muonMatch_cfi import *
-
-# produce object
-from PhysicsTools.PatAlgos.producersLayer1.muonProducer_cfi import *
-
-makePatMuons = cms.Sequence(
-    # reco pre-production
-    # pat specifics
-    muonMatch *
-    # object production
-    patMuons
-    )
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/muonProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersLayer1/muonProducer_cfi.py
deleted file mode 100644
index b7d04c9..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/muonProducer_cfi.py
+++ /dev/null
@@ -1,114 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patMuons = cms.EDProducer("PATMuonProducer",
-    # input
-    muonSource      = cms.InputTag("muons"),
-
-    # use particle flow instead of std reco
-    useParticleFlow =  cms.bool( False ),
-    pfMuonSource    = cms.InputTag("particleFlow"),
-
-    # add user data
-    userData = cms.PSet(
-      # add custom classes here
-      userClasses = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add doubles here
-      userFloats = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add ints here
-      userInts = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add candidate ptrs here
-      userCands = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add "inline" functions here
-      userFunctions = cms.vstring(),
-      userFunctionLabels = cms.vstring()
-    ),
-
-    # embedding objects
-    embedMuonBestTrack          = cms.bool(True),  ## embed in AOD externally stored muon best track
-    embedImprovedMuonBestTrack  = cms.bool(True),  ## embed in AOD externally stored muon best track, with new tuneP (option available only in 53X)
-    embedTrack          = cms.bool(False), ## embed in AOD externally stored tracker track
-    embedCombinedMuon   = cms.bool(True),  ## embed in AOD externally stored combined muon track
-    embedStandAloneMuon = cms.bool(True),  ## embed in AOD externally stored standalone muon track
-    embedPickyMuon      = cms.bool(True),  ## embed in AOD externally stored TeV-refit picky muon track
-    embedTpfmsMuon      = cms.bool(True),  ## embed in AOD externally stored TeV-refit TPFMS muon track
-    embedDytMuon        = cms.bool(True),  ## embed in AOD externally stored TeV-refit DYT muon track
-    embedPFCandidate    = cms.bool(True),  ## embed in AOD externally stored particle flow candidate
-
-    # embedding of muon MET corrections for caloMET
-    embedCaloMETMuonCorrs = cms.bool(True),
-    caloMETMuonCorrs = cms.InputTag("muonMETValueMapProducer"  , "muCorrData"),
-    # embedding of muon MET corrections for tcMET
-    embedTcMETMuonCorrs   = cms.bool(True),
-    tcMETMuonCorrs   = cms.InputTag("muonTCMETValueMapProducer", "muCorrData"),
-
-    # embed IsoDeposits
-    isoDeposits = cms.PSet(
-        #user    = cms.VInputTag(
-        #             cms.InputTag("muIsoDepositCalByAssociatorTowers","ho"),
-        #             cms.InputTag("muIsoDepositJets")
-        #          ),
-    ),
-
-    # user defined isolation variables the variables defined here will be accessible
-    # via pat::Muon::userIsolation(IsolationKeys key) with the key as defined in
-    # DataFormats/PatCandidates/interface/Isolation.h
-    userIsolation = cms.PSet(
-        #user = cms.VPSet(cms.PSet(
-        #    src = cms.InputTag("muIsoDepositCalByAssociatorTowers","ho"),
-        #    deltaR = cms.double(0.3)
-        #    ),
-        #    cms.PSet(
-        #        src = cms.InputTag("muIsoDepositJets"),
-        #        deltaR = cms.double(0.3)
-        #    )),
-    ),
-
-    # mc matching
-    addGenMatch   = cms.bool(True),
-    embedGenMatch = cms.bool(True),
-    genParticleMatch = cms.InputTag("muonMatch"), ## particles source to be used for the matching
-
-    # efficiencies
-    addEfficiencies = cms.bool(False),
-    efficiencies    = cms.PSet(),
-
-    # resolution configurables
-    addResolutions  = cms.bool(False),
-    resolutions      = cms.PSet(),
-
-    # high level selections
-    embedHighLevelSelection = cms.bool(True),
-    usePV                   = cms.bool(True),
-    beamLineSrc             = cms.InputTag("offlineBeamSpot"),
-    pvSrc                   = cms.InputTag("offlinePrimaryVertices")
-)
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
-
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/patCandidates_cff.py b/PhysicsTools/PatAlgos/python/producersLayer1/patCandidates_cff.py
deleted file mode 100644
index 2d5f65f..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/patCandidates_cff.py
+++ /dev/null
@@ -1,35 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# Build the Objects from AOD (Jets, Muons, Electrons, METs, Taus)
-from PhysicsTools.PatAlgos.producersLayer1.electronProducer_cff import *
-from PhysicsTools.PatAlgos.producersLayer1.muonProducer_cff import *
-from PhysicsTools.PatAlgos.producersLayer1.tauProducer_cff import *
-from PhysicsTools.PatAlgos.producersLayer1.photonProducer_cff import *
-from PhysicsTools.PatAlgos.producersLayer1.jetProducer_cff import *
-from PhysicsTools.PatAlgos.producersLayer1.metProducer_cff import *
-from PhysicsTools.PatAlgos.producersLayer1.mhtProducer_cff import *
-
-# One module to count objects
-patCandidateSummary = cms.EDAnalyzer("CandidateSummaryTable",
-    logName = cms.untracked.string("patCandidates|PATSummaryTables"),
-    candidates = cms.VInputTag(
-        cms.InputTag("patElectrons"),
-        cms.InputTag("patMuons"),
-        cms.InputTag("patTaus"),
-        cms.InputTag("patPhotons"),
-        cms.InputTag("patJets"),
-        cms.InputTag("patMETs"),
-#       cms.InputTag("patMHTs")
-    )
-)
-
-patCandidates = cms.Sequence(
-    makePatElectrons +
-    makePatMuons     +
-    makePatTaus      +
-    makePatPhotons   +
-    makePatJets      +
-    makePatMETs      +
-#   makePatMHTs      +    
-    patCandidateSummary
-)
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/pfParticleProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersLayer1/pfParticleProducer_cfi.py
deleted file mode 100644
index bcca931..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/pfParticleProducer_cfi.py
+++ /dev/null
@@ -1,46 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patPFParticles = cms.EDProducer("PATPFParticleProducer",
-    # General configurables
-    pfCandidateSource = cms.InputTag("noJet"),
-
-    # MC matching configurables
-    addGenMatch = cms.bool(False),
-    genParticleMatch = cms.InputTag(""),   ## particles source to be used for the MC matching
-                                           ## must be an InputTag or VInputTag to a product of
-                                           ## type edm::Association<reco::GenParticleCollection>
-    embedGenMatch = cms.bool(False),       ## embed gen match inside the object instead of storing the ref
-
-    # add user data
-    userData = cms.PSet(
-      # add custom classes here
-      userClasses = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add doubles here
-      userFloats = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add ints here
-      userInts = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add candidate ptrs here
-      userCands = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add "inline" functions here
-      userFunctions = cms.vstring(),
-      userFunctionLabels = cms.vstring()
-    ),
-
-    # Efficiencies
-    addEfficiencies = cms.bool(False),
-    efficiencies    = cms.PSet(),
-
-    # resolution
-    addResolutions  = cms.bool(False),
-    resolutions     = cms.PSet(),
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/photonProducer_cff.py b/PhysicsTools/PatAlgos/python/producersLayer1/photonProducer_cff.py
deleted file mode 100644
index f56c27b..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/photonProducer_cff.py
+++ /dev/null
@@ -1,19 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# prepare reco information
-from PhysicsTools.PatAlgos.recoLayer0.photonIsolation_cff import *
-
-# add PAT specifics
-from PhysicsTools.PatAlgos.mcMatchLayer0.photonMatch_cfi import *
-
-# produce object
-from PhysicsTools.PatAlgos.producersLayer1.photonProducer_cfi import *
-
-makePatPhotons = cms.Sequence(
-    # reco pre-production
-    # patPhotonIsolation *
-    # pat specifics
-    photonMatch *
-    # object production
-    patPhotons
-    )
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/photonProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersLayer1/photonProducer_cfi.py
deleted file mode 100644
index de44700..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/photonProducer_cfi.py
+++ /dev/null
@@ -1,62 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patPhotons = cms.EDProducer("PATPhotonProducer",
-    # input collection
-    photonSource = cms.InputTag("photons"),
-                                 
-    # user data to add
-    userData = cms.PSet(
-      # add custom classes here
-      userClasses = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add doubles here
-      userFloats = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add ints here
-      userInts = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add candidate ptrs here
-      userCands = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add "inline" functions here
-      userFunctions = cms.vstring(),
-      userFunctionLabels = cms.vstring()
-    ),
-
-    # embedding of AOD items
-    embedSuperCluster = cms.bool(True), ## whether to embed in AOD externally stored supercluster
-
-    # embed IsoDeposits to recompute isolation
-    isoDeposits = cms.PSet(),
-
-    # user defined isolation variables the variables defined here will be accessible
-    # via pat::Photon::userIsolation(IsolationKeys key) with the key as defined in
-    # DataFormats/PatCandidates/interface/Isolation.h
-    userIsolation = cms.PSet(),
-
-    # photon ID
-    addPhotonID = cms.bool(True),
-    photonIDSources = cms.PSet(
-             PhotonCutBasedIDLoose = cms.InputTag('PhotonIDProd',
-                                                  'PhotonCutBasedIDLoose'),
-             PhotonCutBasedIDTight = cms.InputTag('PhotonIDProd',
-                                                  'PhotonCutBasedIDTight')
-           ),
-    # mc matching
-    addGenMatch = cms.bool(True),
-    embedGenMatch = cms.bool(True),
-    genParticleMatch = cms.InputTag("photonMatch"), ## particles source to be used for the matching
-
-    # efficiencies
-    addEfficiencies = cms.bool(False),
-    efficiencies    = cms.PSet(),
-
-    # resolutions
-    addResolutions  = cms.bool(False),
-    resolutions     = cms.PSet()
-
-)
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/tauProducer_cff.py b/PhysicsTools/PatAlgos/python/producersLayer1/tauProducer_cff.py
deleted file mode 100644
index 279f255..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/tauProducer_cff.py
+++ /dev/null
@@ -1,57 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# prepare reco information
-from PhysicsTools.PatAlgos.recoLayer0.pfCandidateIsoDepositSelection_cff import *
-from PhysicsTools.PatAlgos.recoLayer0.tauIsolation_cff import *
-from PhysicsTools.PatAlgos.recoLayer0.tauDiscriminators_cff import *
-# CV: do **not** load PhysicsTools/PatAlgos/python/recoLayer0/tauJetCorrections_cff
-#     in order to avoid triggering FileInPath to SQLlite file
-#       CondFormats/JetMETObjects/data/TauJec11_V1.db
-#    (which is not included in all _4_2_x/4_3_x/4_4_x CMSSW releases yet)
-#from PhysicsTools.PatAlgos.recoLayer0.tauJetCorrections_cff import *
-
-# add PAT specifics
-from PhysicsTools.JetMCAlgos.TauGenJets_cfi import *
-from PhysicsTools.JetMCAlgos.TauGenJetsDecayModeSelectorAllHadrons_cfi import *
-from PhysicsTools.PatAlgos.mcMatchLayer0.tauMatch_cfi import *
-
-# produce object
-from PhysicsTools.PatAlgos.producersLayer1.tauProducer_cfi import *
-
-#check whether we have defined update or not
-updateDiscriminators=True
-try:
-    from RecoTauTag.Configuration.updateHPSPFTaus_cff import *
-except ImportError:
-    updateDiscriminators=False
-
-if updateDiscriminators:
-    makePatTaus = cms.Sequence(
-    # reco pre-production
-        patHPSPFTauDiscriminationUpdate *
-        patPFCandidateIsoDepositSelection *
-        patPFTauIsolation *
-        #patTauJetCorrections *
-        # pat specifics
-        tauMatch *
-        tauGenJets *
-        tauGenJetsSelectorAllHadrons *
-        tauGenJetMatch *
-        # object production
-        patTaus
-        )
-else:
-    makePatTaus = cms.Sequence(
-        # reco pre-production
-        patPFCandidateIsoDepositSelection *
-        patPFTauIsolation *
-        #patTauJetCorrections *
-        # pat specifics
-        tauMatch *
-        tauGenJets *
-        tauGenJetsSelectorAllHadrons *
-        tauGenJetMatch *
-        # object production
-        patTaus
-        )
-    
diff --git a/PhysicsTools/PatAlgos/python/producersLayer1/tauProducer_cfi.py b/PhysicsTools/PatAlgos/python/producersLayer1/tauProducer_cfi.py
deleted file mode 100644
index 4bc0b76..0000000
--- a/PhysicsTools/PatAlgos/python/producersLayer1/tauProducer_cfi.py
+++ /dev/null
@@ -1,175 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patTaus = cms.EDProducer("PATTauProducer",
-    # input
-    tauSource = cms.InputTag("hpsPFTauProducer"),
-
-    # add user data
-    userData = cms.PSet(
-      # add custom classes here
-      userClasses = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add doubles here
-      userFloats = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add ints here
-      userInts = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add candidate ptrs here
-      userCands = cms.PSet(
-        src = cms.VInputTag('')
-      ),
-      # add "inline" functions here
-      userFunctions = cms.vstring(),
-      userFunctionLabels = cms.vstring()
-    ),
-
-    # jet energy corrections
-    addTauJetCorrFactors = cms.bool(False),
-    tauJetCorrFactorsSource = cms.VInputTag(cms.InputTag("patTauJetCorrFactors")),
-
-    # embedding objects (for Calo- and PFTaus)
-    embedLeadTrack = cms.bool(False), ## embed in AOD externally stored leading track
-    embedSignalTracks = cms.bool(False), ## embed in AOD externally stored signal tracks
-    embedIsolationTracks = cms.bool(False), ## embed in AOD externally stored isolation tracks
-    # embedding objects (for PFTaus only)
-    embedLeadPFCand = cms.bool(False), ## embed in AOD externally stored leading PFCandidate
-    embedLeadPFChargedHadrCand = cms.bool(False), ## embed in AOD externally stored leading PFChargedHadron candidate
-    embedLeadPFNeutralCand = cms.bool(False), ## embed in AOD externally stored leading PFNeutral Candidate
-    embedSignalPFCands = cms.bool(False), ## embed in AOD externally stored signal PFCandidates
-    embedSignalPFChargedHadrCands = cms.bool(False), ## embed in AOD externally stored signal PFChargedHadronCandidates
-    embedSignalPFNeutralHadrCands = cms.bool(False), ## embed in AOD externally stored signal PFNeutralHadronCandidates
-    embedSignalPFGammaCands = cms.bool(False), ## embed in AOD externally stored signal PFGammaCandidates
-    embedIsolationPFCands = cms.bool(False), ## embed in AOD externally stored isolation PFCandidates
-    embedIsolationPFChargedHadrCands = cms.bool(False), ## embed in AOD externally stored isolation PFChargedHadronCandidates
-    embedIsolationPFNeutralHadrCands = cms.bool(False), ## embed in AOD externally stored isolation PFNeutralHadronCandidates
-    embedIsolationPFGammaCands = cms.bool(False), ## embed in AOD externally stored isolation PFGammaCandidates
-
-    # embed IsoDeposits
-    isoDeposits = cms.PSet(
-        pfAllParticles = cms.InputTag("tauIsoDepositPFCandidates"),
-        pfChargedHadron = cms.InputTag("tauIsoDepositPFChargedHadrons"),
-        pfNeutralHadron = cms.InputTag("tauIsoDepositPFNeutralHadrons"),
-        pfGamma = cms.InputTag("tauIsoDepositPFGammas")
-    ),
-
-    # user defined isolation variables the variables defined here will be accessible
-    # via pat::Tau::userIsolation(IsolationKeys key) with the key as defined in
-    # DataFormats/PatCandidates/interface/Isolation.h
-    #
-    # (set Pt thresholds for PFChargedHadrons (PFGammas) to 1.0 (1.5) GeV,
-    # matching the thresholds used when computing the tau iso. discriminators
-    # in RecoTauTag/RecoTau/python/PFRecoTauDiscriminationByIsolation_cfi.py)
-    userIsolation = cms.PSet(
-        pfAllParticles = cms.PSet(
-            src = cms.InputTag("tauIsoDepositPFCandidates"),
-            deltaR = cms.double(0.5),
-            threshold = cms.double(0.)
-        ),
-        pfChargedHadron = cms.PSet(
-            src = cms.InputTag("tauIsoDepositPFChargedHadrons"),
-            deltaR = cms.double(0.5),
-            threshold = cms.double(0.)
-        ),
-        pfNeutralHadron = cms.PSet(
-            src = cms.InputTag("tauIsoDepositPFNeutralHadrons"),
-            deltaR = cms.double(0.5),
-            threshold = cms.double(0.)
-        ),
-        pfGamma = cms.PSet(
-            src = cms.InputTag("tauIsoDepositPFGammas"),
-            deltaR = cms.double(0.5),
-            threshold = cms.double(0.)
-        )
-    ),
-
-    # tau ID (for efficiency studies)
-    addTauID     = cms.bool(True),
-    tauIDSources = cms.PSet(
-        # configure many IDs as InputTag <someName> = <someTag>
-        # you can comment out those you don't want to save some
-        # disk space
-        decayModeFinding = cms.InputTag("hpsPFTauDiscriminationByDecayModeFinding"),
-        byCombinedIsolationDeltaBetaCorrRaw = cms.InputTag("hpsPFTauDiscriminationByRawCombinedIsolationDBSumPtCorr"),
-        byVLooseCombinedIsolationDeltaBetaCorr = cms.InputTag("hpsPFTauDiscriminationByVLooseCombinedIsolationDBSumPtCorr"),
-        byLooseCombinedIsolationDeltaBetaCorr = cms.InputTag("hpsPFTauDiscriminationByLooseCombinedIsolationDBSumPtCorr"),
-        byMediumCombinedIsolationDeltaBetaCorr = cms.InputTag("hpsPFTauDiscriminationByMediumCombinedIsolationDBSumPtCorr"),
-        byTightCombinedIsolationDeltaBetaCorr = cms.InputTag("hpsPFTauDiscriminationByTightCombinedIsolationDBSumPtCorr"),
-        byIsolationMVAraw = cms.InputTag("hpsPFTauDiscriminationByIsolationMVAraw"),
-        byLooseIsolationMVA = cms.InputTag("hpsPFTauDiscriminationByLooseIsolationMVA"),
-        byMediumIsolationMVA = cms.InputTag("hpsPFTauDiscriminationByMediumIsolationMVA"),
-        byTightIsolationMVA = cms.InputTag("hpsPFTauDiscriminationByTightIsolationMVA"),
-        byIsolationMVA2raw = cms.InputTag("hpsPFTauDiscriminationByIsolationMVA2raw"),
-        byLooseIsolationMVA2 = cms.InputTag("hpsPFTauDiscriminationByLooseIsolationMVA2"),
-        byMediumIsolationMVA2 = cms.InputTag("hpsPFTauDiscriminationByMediumIsolationMVA2"),
-        byTightIsolationMVA2 = cms.InputTag("hpsPFTauDiscriminationByTightIsolationMVA2"), 
-        againstElectronLoose = cms.InputTag("hpsPFTauDiscriminationByLooseElectronRejection"),
-        againstElectronMedium = cms.InputTag("hpsPFTauDiscriminationByMediumElectronRejection"),
-        againstElectronTight = cms.InputTag("hpsPFTauDiscriminationByTightElectronRejection"),
-#         againstElectronMVA = cms.InputTag("hpsPFTauDiscriminationByMVAElectronRejection"),
-#         againstElectronMVA2raw = cms.InputTag("hpsPFTauDiscriminationByMVA2rawElectronRejection"),
-#         againstElectronMVA2category = cms.InputTag("hpsPFTauDiscriminationByMVA2rawElectronRejection:category"),                     
-#         againstElectronVLooseMVA2 = cms.InputTag("hpsPFTauDiscriminationByMVA2VLooseElectronRejection"),
-#         againstElectronLooseMVA2 = cms.InputTag("hpsPFTauDiscriminationByMVA2LooseElectronRejection"),
-#         againstElectronMediumMVA2 = cms.InputTag("hpsPFTauDiscriminationByMVA2MediumElectronRejection"),
-#         againstElectronTightMVA2 = cms.InputTag("hpsPFTauDiscriminationByMVA2TightElectronRejection"),                             
-        againstMuonLoose = cms.InputTag("hpsPFTauDiscriminationByLooseMuonRejection"),
-        againstMuonMedium = cms.InputTag("hpsPFTauDiscriminationByMediumMuonRejection"),
-        againstMuonTight = cms.InputTag("hpsPFTauDiscriminationByTightMuonRejection"),
-        againstMuonLoose2 = cms.InputTag("hpsPFTauDiscriminationByLooseMuonRejection2"),
-        againstMuonMedium2 = cms.InputTag("hpsPFTauDiscriminationByMediumMuonRejection2"),
-        againstMuonTight2 = cms.InputTag("hpsPFTauDiscriminationByTightMuonRejection2"),
-        byCombinedIsolationDeltaBetaCorrRaw3Hits = cms.InputTag("hpsPFTauDiscriminationByRawCombinedIsolationDBSumPtCorr3Hits"),
-        byLooseCombinedIsolationDeltaBetaCorr3Hits = cms.InputTag("hpsPFTauDiscriminationByLooseCombinedIsolationDBSumPtCorr3Hits"),
-        byMediumCombinedIsolationDeltaBetaCorr3Hits = cms.InputTag("hpsPFTauDiscriminationByMediumCombinedIsolationDBSumPtCorr3Hits"),
-        byTightCombinedIsolationDeltaBetaCorr3Hits = cms.InputTag("hpsPFTauDiscriminationByTightCombinedIsolationDBSumPtCorr3Hits"),
-        againstElectronMVA3raw = cms.InputTag("hpsPFTauDiscriminationByMVA3rawElectronRejection"),
-        againstElectronMVA3category = cms.InputTag("hpsPFTauDiscriminationByMVA3rawElectronRejection:category"),
-        againstElectronLooseMVA3 = cms.InputTag("hpsPFTauDiscriminationByMVA3LooseElectronRejection"),
-        againstElectronMediumMVA3 = cms.InputTag("hpsPFTauDiscriminationByMVA3MediumElectronRejection"),
-        againstElectronTightMVA3 = cms.InputTag("hpsPFTauDiscriminationByMVA3TightElectronRejection"),
-        againstElectronVTightMVA3 = cms.InputTag("hpsPFTauDiscriminationByMVA3VTightElectronRejection"),
-        againstElectronDeadECAL = cms.InputTag("hpsPFTauDiscriminationByDeadECALElectronRejection")
-      ),
-
-    # mc matching configurables
-    addGenMatch      = cms.bool(True),
-    embedGenMatch    = cms.bool(True),
-    genParticleMatch = cms.InputTag("tauMatch"),
-    addGenJetMatch   = cms.bool(True),
-    embedGenJetMatch = cms.bool(True),
-    genJetMatch      = cms.InputTag("tauGenJetMatch"),
-
-    # efficiencies
-    addEfficiencies = cms.bool(False),
-    efficiencies    = cms.PSet(),
-
-    # resolution
-    addResolutions  = cms.bool(False),
-    resolutions     = cms.PSet()
-)
-
-NoUpdateDiscriminators=False
-try:
-    from RecoTauTag.Configuration.updateHPSPFTaus_cff import *
-except ImportError:
-    NoUpdateDiscriminators=True
-
-if NoUpdateDiscriminators:
-    patTaus.tauIDSources = cms.PSet(
-                         decayModeFinding = cms.InputTag("hpsPFTauDiscriminationByDecayModeFinding"),
-                         byVLooseCombinedIsolationDeltaBetaCorr = cms.InputTag("hpsPFTauDiscriminationByVLooseCombinedIsolationDBSumPtCorr"),
-                         byLooseCombinedIsolationDeltaBetaCorr = cms.InputTag("hpsPFTauDiscriminationByLooseCombinedIsolationDBSumPtCorr"),
-                         byMediumCombinedIsolationDeltaBetaCorr = cms.InputTag("hpsPFTauDiscriminationByMediumCombinedIsolationDBSumPtCorr"),
-                         byTightCombinedIsolationDeltaBetaCorr = cms.InputTag("hpsPFTauDiscriminationByTightCombinedIsolationDBSumPtCorr"),
-                         againstElectronLoose = cms.InputTag("hpsPFTauDiscriminationByLooseElectronRejection"),
-                         againstElectronMedium = cms.InputTag("hpsPFTauDiscriminationByMediumElectronRejection"),
-                         againstElectronTight = cms.InputTag("hpsPFTauDiscriminationByTightElectronRejection"),
-                         againstElectronMVA = cms.InputTag("hpsPFTauDiscriminationByMVAElectronRejection"),
-                         againstMuonLoose = cms.InputTag("hpsPFTauDiscriminationByLooseMuonRejection"),
-                         againstMuonMedium = cms.InputTag("hpsPFTauDiscriminationByMediumMuonRejection"),
-                         againstMuonTight = cms.InputTag("hpsPFTauDiscriminationByTightMuonRejection")
-                     )
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/bTagging_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/bTagging_cff.py
deleted file mode 100644
index 2b4fff8..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/bTagging_cff.py
+++ /dev/null
@@ -1,7 +0,0 @@
-#add negative secondary vertex tagger
-
-from TrackingTools.TransientTrack.TransientTrackBuilder_cfi import *
-from RecoBTau.JetTagComputer.jetTagRecord_cfi import *
-from RecoBTag.SecondaryVertex.secondaryVertexNegativeTagInfos_cfi import *
-from RecoBTag.SecondaryVertex.simpleSecondaryVertex2TrkES_cfi import *
-from RecoBTag.SecondaryVertex.simpleSecondaryVertexNegativeBJetTags_cfi import *
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/duplicatedElectrons_cfi.py b/PhysicsTools/PatAlgos/python/recoLayer0/duplicatedElectrons_cfi.py
deleted file mode 100644
index e96525f..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/duplicatedElectrons_cfi.py
+++ /dev/null
@@ -1,8 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# Remove duplicates from the electron list
-
-electronsNoDuplicates = cms.EDFilter("DuplicatedElectronCleaner",
-    ## reco electron input source
-    electronSource = cms.InputTag("gsfElectrons"), 
-)
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/duplicatedPhotons_cfi.py b/PhysicsTools/PatAlgos/python/recoLayer0/duplicatedPhotons_cfi.py
deleted file mode 100644
index 67703f7..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/duplicatedPhotons_cfi.py
+++ /dev/null
@@ -1,13 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# Remove duplicates from the photon list
-
-photonsNoDuplicates = cms.EDFilter("DuplicatedPhotonCleaner",
-    ## reco photon input source
-    photonSource = cms.InputTag("photons"), 
-
-    ## Algorithm used to clean.
-    ##   bySeed         = using supercluster seed
-    ##   bySuperCluster = using only the supercluster
-    removalAlgo  = cms.string("bySeed"),
-)
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/electronId_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/electronId_cff.py
deleted file mode 100644
index 9a9fedc..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/electronId_cff.py
+++ /dev/null
@@ -1,7 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from RecoEgamma.ElectronIdentification.electronIdSequence_cff import *
-
-patElectronId = cms.Sequence(
-    eidRobustHighEnergy
-)
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/electronIsolation_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/electronIsolation_cff.py
deleted file mode 100644
index b35a0cd..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/electronIsolation_cff.py
+++ /dev/null
@@ -1,28 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-## compute isolation, using POG modules
-from RecoEgamma.EgammaIsolationAlgos.eleIsoDeposits_cff import eleIsoDepositTk, eleIsoDepositEcalFromHits, eleIsoDepositHcalFromTowers
-from RecoEgamma.EgammaIsolationAlgos.eleIsoFromDeposits_cff import eleIsoFromDepsTk, eleIsoFromDepsEcalFromHitsByCrystal, eleIsoFromDepsHcalFromTowers
- 
-
-eleIsoDepositEcalFromHits.ExtractorPSet.barrelEcalHits = cms.InputTag("reducedEcalRecHitsEB")
-eleIsoDepositEcalFromHits.ExtractorPSet.endcapEcalHits = cms.InputTag("reducedEcalRecHitsEE")
-
-## sequence to run on AOD 
-patElectronTrackIsolation = cms.Sequence(
-    eleIsoDepositTk * eleIsoFromDepsTk
-)
-
-patElectronEcalIsolation = cms.Sequence(
-    eleIsoDepositEcalFromHits * eleIsoFromDepsEcalFromHitsByCrystal
-)
-
-patElectronHcalIsolation = cms.Sequence(
-    eleIsoDepositHcalFromTowers * eleIsoFromDepsHcalFromTowers
-)
-
-patElectronIsolation = cms.Sequence(
-    patElectronTrackIsolation +
-    patElectronEcalIsolation  +
-    patElectronHcalIsolation
-)
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/genericTrackCandidates_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/genericTrackCandidates_cff.py
deleted file mode 100644
index e3f962d..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/genericTrackCandidates_cff.py
+++ /dev/null
@@ -1,67 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from SimGeneral.HepPDTESSource.pythiapdt_cfi           import *
-from Configuration.StandardSequences.MagneticField_cff import *
-
-patAODTrackCandsUnfiltered = cms.EDProducer("ConcreteChargedCandidateProducer",
-    src          = cms.InputTag("generalTracks"),
-    particleType = cms.string('mu+')   # to fix mass hypothesis
-)
-
-patAODTrackCands = cms.EDFilter("CandViewSelector",
-    src = cms.InputTag("patAODTrackCandsUnfiltered"),
-    cut = cms.string('pt > 15')
-)
-
-## Configure tracker isolation
-from RecoMuon.MuonIsolationProducers.trackExtractorBlocks_cff import MIsoTrackExtractorCtfBlock
-patAODTrackIsoDepositCtfTk = cms.EDProducer("CandIsoDepositProducer",
-    src                  = cms.InputTag("patAODTrackCands"),
-    trackType            = cms.string('best'),
-    MultipleDepositsFlag = cms.bool(False),
-    ExtractorPSet        = cms.PSet( MIsoTrackExtractorCtfBlock )
-)
-
-## Configure calorimetric isolation
-from RecoMuon.MuonIsolationProducers.caloExtractorByAssociatorBlocks_cff import MIsoCaloExtractorByAssociatorTowersBlock
-patAODTrackIsoDepositCalByAssociatorTowers = cms.EDProducer("CandIsoDepositProducer",
-    src                  = cms.InputTag("patAODTrackCands"),
-    trackType            = cms.string('best'),
-    MultipleDepositsFlag = cms.bool(True),
-    ExtractorPSet        = cms.PSet( MIsoCaloExtractorByAssociatorTowersBlock )
-)
-
-## Select isolation labels to use
-patAODTrackIsolationLabels = cms.VInputTag(
-    cms.InputTag("patAODTrackIsoDepositCalByAssociatorTowers","ecal"), 
-    cms.InputTag("patAODTrackIsoDepositCalByAssociatorTowers","hcal"), 
-    cms.InputTag("patAODTrackIsoDepositCalByAssociatorTowers","ho"), 
-    cms.InputTag("patAODTrackIsoDepositCtfTk")
-)
-
-# Isolation converter module
-patAODTrackIsolations = cms.EDFilter("MultipleIsoDepositsToValueMaps",
-    collection   = cms.InputTag("patAODTrackCands"),
-    associations = patAODTrackIsolationLabels
-)
-
-# Isolation re-keying to clean layer 0 output collection
-layer0TrackIsolations = cms.EDFilter("CandManyValueMapsSkimmerIsoDeposits",
-    collection   = cms.InputTag("allLayer0TrackCands"),
-    backrefs     = cms.InputTag("allLayer0TrackCands"),
-    commonLabel  = cms.InputTag("patAODTrackIsolations"),
-    associations = patAODTrackIsolationLabels
-)
-
-# sequence to run on AOD before PAT cleaners
-patAODTrackCandSequence = cms.Sequence(
-        patAODTrackCandsUnfiltered *
-        patAODTrackCands *
-        patAODTrackIsoDepositCalByAssociatorTowers *
-        patAODTrackIsoDepositCtfTk *
-        patAODTrackIsolations
-)
-
-# sequence to run at end of layer 0 
-patLayer0TrackCandSequence = cms.Sequence( layer0TrackIsolations )
-
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/jetCorrFactors_cfi.py b/PhysicsTools/PatAlgos/python/recoLayer0/jetCorrFactors_cfi.py
deleted file mode 100644
index 45e391e..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/jetCorrFactors_cfi.py
+++ /dev/null
@@ -1,34 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to produce jet correction factors associated in a valuemap
-patJetCorrFactors = cms.EDProducer("JetCorrFactorsProducer",
-    ## the use of emf in the JEC is not yet implemented
-    emf = cms.bool(False),
-    ## input collection of jets
-    src = cms.InputTag("ak5CaloJets"),
-    ## payload postfix for testing
-    payload = cms.string('AK5Calo'),
-    ## correction levels
-    levels = cms.vstring(
-        ## tags for the individual jet corrections; when
-        ## not available the string should be set to 'none'
-        'L1FastJet', 'L2Relative', 'L3Absolute'#, 'L5Flavor', 'L7Parton'
-    ),
-    flavorType = cms.string('J'), ## alternatively use 'T'
-    ## in case that L1Offset or L1FastJet corrections are part
-    ## of the parameter levels add the optional parameter
-    ## primaryVertices here to specify the primary vertex
-    ## collection, which was used to determine the L1Offset
-    ## or L1FastJet correction from. This parameter will ONLY
-    ## be read out if the correction level L1Offset or
-    ## L1FastJet is found in levels.
-    useNPV = cms.bool(True),
-    primaryVertices = cms.InputTag('offlinePrimaryVertices'),
-    ## in case that L1FastJet corrections are part of the
-    ## parameter levels add the optional parameter rho
-    ## here to specify the energy density parameter for
-    ## the corresponding jet collection (this variable is
-    ## typically taken from kt6PFJets).
-    useRho = cms.bool(True),
-    rho = cms.InputTag('kt6PFJets', 'rho'),
-)
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/jetID_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/jetID_cff.py
deleted file mode 100644
index d784934..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/jetID_cff.py
+++ /dev/null
@@ -1,5 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from RecoJets.Configuration.JetIDProducers_cff import ak5JetID
-
-recoJetId = cms.Sequence( ak5JetID )
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/jetMETCorrections_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/jetMETCorrections_cff.py
deleted file mode 100644
index 48dc93c..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/jetMETCorrections_cff.py
+++ /dev/null
@@ -1,19 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# produce associated jet correction factors in a valuemap
-from PhysicsTools.PatAlgos.recoLayer0.jetCorrFactors_cfi import *
-patJetCorrections = cms.Sequence(patJetCorrFactors)
-
-# MET correction for JES
-from JetMETCorrections.Type1MET.caloMETCorrections_cff import *
-from JetMETCorrections.Type1MET.pfMETCorrections_cff import *
-#from JetMETCorrections.Configuration.JetCorrectionCondDB_cff import *
-from JetMETCorrections.Configuration.JetCorrectionServicesAllAlgos_cff import *
-
-# MET corrections
-patMETCorrections = cms.Sequence(produceCaloMETCorrections+producePFMETCorrections)
-
-# default PAT sequence for JetMET corrections before cleaners
-patJetMETCorrections = cms.Sequence(patJetCorrections)
-
-
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/jetPlusTrack_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/jetPlusTrack_cff.py
deleted file mode 100644
index 099a340..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/jetPlusTrack_cff.py
+++ /dev/null
@@ -1,15 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# Moved to reco
-
-#from JetMETCorrections.Configuration.ZSPJetCorrections219_cff import *
-#from JetMETCorrections.Configuration.JetPlusTrackCorrections_cff import *
-
-#jptCaloJets = cms.Sequence(
-#    ZSPJetCorrectionsIcone5 *
-#    ZSPJetCorrectionsSisCone5 *
-#    ZSPJetCorrectionsAntiKt5 *
-#    JetPlusTrackCorrectionsIcone5 *
-#    JetPlusTrackCorrectionsSisCone5 *
-#    JetPlusTrackCorrectionsAntiKt5
-#    )
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/jetTracksCharge_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/jetTracksCharge_cff.py
deleted file mode 100644
index f56aac4..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/jetTracksCharge_cff.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-## Compute JET Charge
-patJetCharge = cms.EDProducer("JetChargeProducer",
-    src = cms.InputTag("ak5JetTracksAssociatorAtVertex"), ## a reco::JetTracksAssociation::Container
-    # -- JetCharge parameters --
-    var = cms.string('Pt'),
-    exp = cms.double(1.0)
-)
-
-# removed for testing and final cleanup
-# patJetTracksCharge = cms.Sequence(patAK5CaloJetCharge)
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/pfCandidateIsoDepositSelection_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/pfCandidateIsoDepositSelection_cff.py
deleted file mode 100644
index f8a4c3b..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/pfCandidateIsoDepositSelection_cff.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from CommonTools.ParticleFlow.ParticleSelectors.pfSortByType_cff import *
-from CommonTools.ParticleFlow.pfNoPileUpIso_cff  import *
-
-pfPileUpIso.PFCandidates = 'particleFlow'
-pfNoPileUpIso.bottomCollection='particleFlow'
-
-patPFCandidateIsoDepositSelection = cms.Sequence(
-       pfNoPileUpIsoSequence +
-       pfSortByTypeSequence
-       )
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/photonIsolation_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/photonIsolation_cff.py
deleted file mode 100644
index 67ea666..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/photonIsolation_cff.py
+++ /dev/null
@@ -1,28 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-### Compute isolation values, using POG modules
-from RecoEgamma.EgammaIsolationAlgos.gamIsoDeposits_cff import gamIsoDepositTk, gamIsoDepositEcalFromHits, gamIsoDepositHcalFromTowers
-from RecoEgamma.EgammaIsolationAlgos.gamIsoFromDepsModules_cff import gamIsoFromDepsTk, gamIsoFromDepsEcalFromHits, gamIsoFromDepsHcalFromTowers
-
-
-gamIsoDepositEcalFromHits.ExtractorPSet.barrelEcalHits = cms.InputTag("reducedEcalRecHitsEB")
-gamIsoDepositEcalFromHits.ExtractorPSet.endcapEcalHits = cms.InputTag("reducedEcalRecHitsEE")
-
-# sequence to run on AOD 
-patPhotonTrackIsolation = cms.Sequence(
-    gamIsoDepositTk * gamIsoFromDepsTk
-)
-
-patPhotonEcalIsolation = cms.Sequence(
-    gamIsoDepositEcalFromHits * gamIsoFromDepsEcalFromHits
-)
-
-patPhotonHcalIsolation = cms.Sequence(
-    gamIsoDepositHcalFromTowers * gamIsoFromDepsHcalFromTowers
-)
-
-patPhotonIsolation = cms.Sequence(
-    patPhotonTrackIsolation +
-    patPhotonEcalIsolation  +
-    patPhotonHcalIsolation
-)
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/stringResolutionProvider_cfi.py b/PhysicsTools/PatAlgos/python/recoLayer0/stringResolutionProvider_cfi.py
deleted file mode 100644
index 73ed4dc..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/stringResolutionProvider_cfi.py
+++ /dev/null
@@ -1,23 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-stringResolution = cms.ESProducer("StringResolutionProviderESProducer",
-  ## specify parametrization (see
-  ## SWGuidePATKinematicResolutions for more details)
-  parametrization = cms.string ('EtEtaPhi'),
-  functions = cms.VPSet(
-    cms.PSet(
-      ## set the eta bin as selection string.(optional)
-      ## See SWGuidePhysicsCutParser for more details
-      bin = cms.string(""),
-      ## define resolution functions of each parameter
-      et  = cms.string("et * (sqrt(0.08^2 + (1./sqrt(et))^2 + (5./et)^2))"),
-      eta = cms.string("sqrt(0.008^2 + (1.5/et)^2)"),
-      phi = cms.string("sqrt(0.008^2 + (2.6/et)^2)"),
-    ),
-  ),
-  ## add constraints (depending on the choice of para-
-  ## metrization); for et/eta/phi this has to be set
-  ## to 0 (have a look at SWGuidePATKinematicResolutions
-  ## for more details)
-  constraints = cms.vdouble(0)
-)
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/stringResolutions_etEtaPhi_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/stringResolutions_etEtaPhi_cff.py
deleted file mode 100644
index 5179fbf..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/stringResolutions_etEtaPhi_cff.py
+++ /dev/null
@@ -1,507 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.recoLayer0.stringResolutionProvider_cfi import *
-
-## <--- these resolutions do not exist yet --->
-## electronResolution = stringResolution.clone(parametrization = 'EtEtaPhi',
-##                                        resolutions     = ['et * (sqrt(5.6*5.6/(et*et) + 1.25/et + 0.033))', # add sigma(Et) not sigma(Et)/Et here
-##                                                           '0.03  + 1.0/et',                                 # add sigma(eta) here
-##                                                           '0.015 + 1.5/et'                                  # add sigma(phi) here
-##                                                           ],
-##                                        constraints     =  cms.vdouble(0)                                    # add constraints here
-##                                        )
-
-muonResolution = stringResolution.clone(parametrization = 'EtEtaPhi',
-                                        functions = cms.VPSet(
-    cms.PSet(
-    bin = cms.string('0.000<=abs(eta) && abs(eta)<0.100'),
-    et  = cms.string('et * (0.00465 + 0.0002471 * et)'),
-    eta = cms.string('sqrt(0.0004331^2 + (0.001071/sqrt(et))^2 + (0/et)^2)'),
-    phi = cms.string('sqrt(6.21e-05^2 + (0/sqrt(et))^2 + (0.004634/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.100<=abs(eta) && abs(eta)<0.200'),
-    et  = cms.string('et * (0.005072 + 0.0002368 * et)'),
-    eta = cms.string('sqrt(0.0003896^2 + (0.000858/sqrt(et))^2 + (0.00201/et)^2)'),
-    phi = cms.string('sqrt(5.36e-05^2 + (0/sqrt(et))^2 + (0.004865/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.200<=abs(eta) && abs(eta)<0.300'),
-    et  = cms.string('et * (0.005875 + 0.0002207 * et)'),
-    eta = cms.string('sqrt(0.0003387^2 + (0.000904/sqrt(et))^2 + (0.00142/et)^2)'),
-    phi = cms.string('sqrt(5.16e-05^2 + (0/sqrt(et))^2 + (0.004923/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.300<=abs(eta) && abs(eta)<0.400'),
-    et  = cms.string('et * (0.006974 + 0.0002021 * et)'),
-    eta = cms.string('sqrt(0.0003164^2 + (0.000704/sqrt(et))^2 + (0.00169/et)^2)'),
-    phi = cms.string('sqrt(5.21e-05^2 + (0/sqrt(et))^2 + (0.005102/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.400<=abs(eta) && abs(eta)<0.500'),
-    et  = cms.string('et * (0.007159 + 0.0002023 * et)'),
-    eta = cms.string('sqrt(0.0002926^2 + (0.000722/sqrt(et))^2 + (0.00154/et)^2)'),
-    phi = cms.string('sqrt(5.3e-05^2 + (0/sqrt(et))^2 + (0.005151/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.500<=abs(eta) && abs(eta)<0.600'),
-    et  = cms.string('et * (0.007502 + 0.000193 * et)'),
-    eta = cms.string('sqrt(0.0002897^2 + (0.000754/sqrt(et))^2 + (0.00159/et)^2)'),
-    phi = cms.string('sqrt(5.32e-05^2 + (0/sqrt(et))^2 + (0.005276/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.600<=abs(eta) && abs(eta)<0.700'),
-    et  = cms.string('et * (0.007842 + 0.0001886 * et)'),
-    eta = cms.string('sqrt(0.0003089^2 + (0.000684/sqrt(et))^2 + (0.00189/et)^2)'),
-    phi = cms.string('sqrt(5.31e-05^2 + (0/sqrt(et))^2 + (0.00538/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.700<=abs(eta) && abs(eta)<0.800'),
-    et  = cms.string('et * (0.008325 + 0.0001833 * et)'),
-    eta = cms.string('sqrt(0.00029^2 + (0.000868/sqrt(et))^2 + (0.00181/et)^2)'),
-    phi = cms.string('sqrt(5.54e-05^2 + (0/sqrt(et))^2 + (0.005242/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.800<=abs(eta) && abs(eta)<0.900'),
-    et  = cms.string('et * (0.00925 + 0.0001917 * et)'),
-    eta = cms.string('sqrt(0.0002935^2 + (0.000783/sqrt(et))^2 + (0.00204/et)^2)'),
-    phi = cms.string('sqrt(6.05e-05^2 + (0/sqrt(et))^2 + (0.00561/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.900<=abs(eta) && abs(eta)<1.000'),
-    et  = cms.string('et * (0.01095 + 0.000192 * et)'),
-    eta = cms.string('sqrt(0.0002772^2 + (0.000916/sqrt(et))^2 + (0.00149/et)^2)'),
-    phi = cms.string('sqrt(7.7e-05^2 + (0/sqrt(et))^2 + (0.005576/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.000<=abs(eta) && abs(eta)<1.100'),
-    et  = cms.string('et * (0.01267 + 0.0001638 * et)'),
-    eta = cms.string('sqrt(0.0002908^2 + (0.000919/sqrt(et))^2 + (0.0018/et)^2)'),
-    phi = cms.string('sqrt(7.53e-05^2 + (0/sqrt(et))^2 + (0.005775/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.100<=abs(eta) && abs(eta)<1.200'),
-    et  = cms.string('et * (0.01374 + 0.0001666 * et)'),
-    eta = cms.string('sqrt(0.0002931^2 + (0.000943/sqrt(et))^2 + (0.00201/et)^2)'),
-    phi = cms.string('sqrt(8.18e-05^2 + (0/sqrt(et))^2 + (0.00606/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.200<=abs(eta) && abs(eta)<1.300'),
-    et  = cms.string('et * (0.01492 + 0.0001584 * et)'),
-    eta = cms.string('sqrt(0.0002936^2 + (0.000794/sqrt(et))^2 + (0.00214/et)^2)'),
-    phi = cms.string('sqrt(7.43e-05^2 + (0.000429/sqrt(et))^2 + (0.006143/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.300<=abs(eta) && abs(eta)<1.400'),
-    et  = cms.string('et * (0.01535 + 0.0001721 * et)'),
-    eta = cms.string('sqrt(0.0002927^2 + (0.000856/sqrt(et))^2 + (0.0023/et)^2)'),
-    phi = cms.string('sqrt(5.6e-05^2 + (0.000724/sqrt(et))^2 + (0.005829/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.400<=abs(eta) && abs(eta)<1.500'),
-    et  = cms.string('et * (0.01477 + 0.0001847 * et)'),
-    eta = cms.string('sqrt(0.0003012^2 + (0.000872/sqrt(et))^2 + (0.00229/et)^2)'),
-    phi = cms.string('sqrt(4.9e-05^2 + (0.000815/sqrt(et))^2 + (0.005459/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.500<=abs(eta) && abs(eta)<1.600'),
-    et  = cms.string('et * (0.01353 + 0.0002351 * et)'),
-    eta = cms.string('sqrt(0.0003027^2 + (0.00077/sqrt(et))^2 + (0.00258/et)^2)'),
-    phi = cms.string('sqrt(7.63e-05^2 + (0.000745/sqrt(et))^2 + (0.005747/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.600<=abs(eta) && abs(eta)<1.700'),
-    et  = cms.string('et * (0.01301 + 0.0002884 * et)'),
-    eta = cms.string('sqrt(0.0003074^2 + (0.000725/sqrt(et))^2 + (0.00271/et)^2)'),
-    phi = cms.string('sqrt(7.5e-05^2 + (0.000967/sqrt(et))^2 + (0.00546/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.700<=abs(eta) && abs(eta)<1.800'),
-    et  = cms.string('et * (0.01295 + 0.000388 * et)'),
-    eta = cms.string('sqrt(0.0003168^2 + (0.00067/sqrt(et))^2 + (0.00295/et)^2)'),
-    phi = cms.string('sqrt(0.000109^2 + (0.000978/sqrt(et))^2 + (0.00572/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.800<=abs(eta) && abs(eta)<1.900'),
-    et  = cms.string('et * (0.01382 + 0.000506 * et)'),
-    eta = cms.string('sqrt(0.000344^2 + (0.00063/sqrt(et))^2 + (0.00303/et)^2)'),
-    phi = cms.string('sqrt(0.000134^2 + (0.001074/sqrt(et))^2 + (0.00561/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.900<=abs(eta) && abs(eta)<2.000'),
-    et  = cms.string('et * (0.01519 + 0.000565 * et)'),
-    eta = cms.string('sqrt(0.000337^2 + (0.00087/sqrt(et))^2 + (0.00322/et)^2)'),
-    phi = cms.string('sqrt(0.000186^2 + (0.00084/sqrt(et))^2 + (0.0061/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('2.000<=abs(eta) && abs(eta)<2.100'),
-    et  = cms.string('et * (0.01712 + 0.000755 * et)'),
-    eta = cms.string('sqrt(0.00036^2 + (0.00065/sqrt(et))^2 + (0.00393/et)^2)'),
-    phi = cms.string('sqrt(0.000216^2 + (0.00124/sqrt(et))^2 + (0.00572/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('2.100<=abs(eta) && abs(eta)<2.200'),
-    et  = cms.string('et * (0.01979 + 0.00085 * et)'),
-    eta = cms.string('sqrt(0.000372^2 + (0.00096/sqrt(et))^2 + (0.0037/et)^2)'),
-    phi = cms.string('sqrt(0.00031^2 + (0.00072/sqrt(et))^2 + (0.0062/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('2.200<=abs(eta) && abs(eta)<2.300'),
-    et  = cms.string('et * (0.02143 + 0.00109 * et)'),
-    eta = cms.string('sqrt(0.000432^2 + (0.00063/sqrt(et))^2 + (0.00447/et)^2)'),
-    phi = cms.string('sqrt(0.000333^2 + (0.00146/sqrt(et))^2 + (0.00566/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('2.300<=abs(eta) && abs(eta)<2.400'),
-    et  = cms.string('et * (0.02144 + 0.001458 * et)'),
-    eta = cms.string('sqrt(0.000417^2 + (0.00149/sqrt(et))^2 + (0.00416/et)^2)'),
-    phi = cms.string('sqrt(0.000365^2 + (0.00172/sqrt(et))^2 + (0.00628/et)^2)'),
-    )
-    ),
-                                        constraints = cms.vdouble(0)
-                                        )
-
-## <--- these resolutions do not exist yet --->
-## tauResolution = stringResolution.clone(parametrization = 'EtEtaPhi',
-##                                        resolutions     = ['et * (sqrt(5.6*5.6/(et*et) + 1.25/et + 0.033))',
-##                                                           '0.03  + 1.0/et',
-##                                                           '0.015 + 1.5/et'
-##                                                           ],
-##                                        constraints     =  cms.vdouble(0)
-##                                        )
-
-udscResolution = stringResolution.clone(parametrization = 'EtEtaPhi',
-                                        functions = cms.VPSet(
-    cms.PSet(
-    bin = cms.string('0.000<=abs(eta) && abs(eta)<0.087'),
-    et  = cms.string('et * (sqrt(0.0334^2 + (1.221/sqrt(et))^2 + (4.7/et)^2))'),
-    eta = cms.string('sqrt(0.00809^2 + (0/sqrt(et))^2 + (1.5398/et)^2)'),
-    phi = cms.string('sqrt(0.00783^2 + (0/sqrt(et))^2 + (2.581/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.087<=abs(eta) && abs(eta)<0.174'),
-    et  = cms.string('et * (sqrt(0.0485^2 + (1.146/sqrt(et))^2 + (5.44/et)^2))'),
-    eta = cms.string('sqrt(0.00847^2 + (0/sqrt(et))^2 + (1.5396/et)^2)'),
-    phi = cms.string('sqrt(0.00691^2 + (0/sqrt(et))^2 + (2.633/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.174<=abs(eta) && abs(eta)<0.261'),
-    et  = cms.string('et * (sqrt(0.0531^2 + (1.122/sqrt(et))^2 + (5.65/et)^2))'),
-    eta = cms.string('sqrt(0.00851^2 + (0/sqrt(et))^2 + (1.5647/et)^2)'),
-    phi = cms.string('sqrt(0.00869^2 + (0/sqrt(et))^2 + (2.589/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.261<=abs(eta) && abs(eta)<0.348'),
-    et  = cms.string('et * (sqrt(0.0436^2 + (1.139/sqrt(et))^2 + (5.6/et)^2))'),
-    eta = cms.string('sqrt(0.00809^2 + (0/sqrt(et))^2 + (1.5762/et)^2)'),
-    phi = cms.string('sqrt(0.00673^2 + (0/sqrt(et))^2 + (2.627/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.348<=abs(eta) && abs(eta)<0.435'),
-    et  = cms.string('et * (sqrt(0.0499^2 + (1.111/sqrt(et))^2 + (5.55/et)^2))'),
-    eta = cms.string('sqrt(0.00786^2 + (0/sqrt(et))^2 + (1.602/et)^2)'),
-    phi = cms.string('sqrt(0.00767^2 + (0/sqrt(et))^2 + (2.62/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.435<=abs(eta) && abs(eta)<0.522'),
-    et  = cms.string('et * (sqrt(0.0551^2 + (1.081/sqrt(et))^2 + (5.6/et)^2))'),
-    eta = cms.string('sqrt(0.00832^2 + (0/sqrt(et))^2 + (1.6007/et)^2)'),
-    phi = cms.string('sqrt(0.0057^2 + (0/sqrt(et))^2 + (2.645/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.522<=abs(eta) && abs(eta)<0.609'),
-    et  = cms.string('et * (sqrt(0.0605^2 + (1.054/sqrt(et))^2 + (5.73/et)^2))'),
-    eta = cms.string('sqrt(0.00838^2 + (0/sqrt(et))^2 + (1.5511/et)^2)'),
-    phi = cms.string('sqrt(0.00577^2 + (0/sqrt(et))^2 + (2.603/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.609<=abs(eta) && abs(eta)<0.696'),
-    et  = cms.string('et * (sqrt(0.0563^2 + (1.052/sqrt(et))^2 + (5.83/et)^2))'),
-    eta = cms.string('sqrt(0.00882^2 + (0/sqrt(et))^2 + (1.5473/et)^2)'),
-    phi = cms.string('sqrt(0.00715^2 + (0/sqrt(et))^2 + (2.569/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.696<=abs(eta) && abs(eta)<0.783'),
-    et  = cms.string('et * (sqrt(0.0508^2 + (1.119/sqrt(et))^2 + (5.29/et)^2))'),
-    eta = cms.string('sqrt(0.00858^2 + (0/sqrt(et))^2 + (1.5522/et)^2)'),
-    phi = cms.string('sqrt(0.00657^2 + (0/sqrt(et))^2 + (2.605/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.783<=abs(eta) && abs(eta)<0.870'),
-    et  = cms.string('et * (sqrt(0.0504^2 + (1.141/sqrt(et))^2 + (5.31/et)^2))'),
-    eta = cms.string('sqrt(0.00811^2 + (0/sqrt(et))^2 + (1.618/et)^2)'),
-    phi = cms.string('sqrt(0.00631^2 + (0/sqrt(et))^2 + (2.64/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.870<=abs(eta) && abs(eta)<0.957'),
-    et  = cms.string('et * (sqrt(0.0591^2 + (1.132/sqrt(et))^2 + (5.37/et)^2))'),
-    eta = cms.string('sqrt(0.00649^2 + (0.055/sqrt(et))^2 + (1.58/et)^2)'),
-    phi = cms.string('sqrt(0.00659^2 + (0/sqrt(et))^2 + (2.612/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.957<=abs(eta) && abs(eta)<1.044'),
-    et  = cms.string('et * (sqrt(0.0539^2 + (1.136/sqrt(et))^2 + (5.57/et)^2))'),
-    eta = cms.string('sqrt(0.00806^2 + (0/sqrt(et))^2 + (1.6097/et)^2)'),
-    phi = cms.string('sqrt(0.00654^2 + (0/sqrt(et))^2 + (2.631/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.044<=abs(eta) && abs(eta)<1.131'),
-    et  = cms.string('et * (sqrt(0.0542^2 + (1.186/sqrt(et))^2 + (5.36/et)^2))'),
-    eta = cms.string('sqrt(0.00801^2 + (0/sqrt(et))^2 + (1.6478/et)^2)'),
-    phi = cms.string('sqrt(0.00707^2 + (0/sqrt(et))^2 + (2.645/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.131<=abs(eta) && abs(eta)<1.218'),
-    et  = cms.string('et * (sqrt(0.0583^2 + (1.184/sqrt(et))^2 + (5.41/et)^2))'),
-    eta = cms.string('sqrt(0.00834^2 + (0/sqrt(et))^2 + (1.6736/et)^2)'),
-    phi = cms.string('sqrt(0.00603^2 + (0/sqrt(et))^2 + (2.681/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.218<=abs(eta) && abs(eta)<1.305'),
-    et  = cms.string('et * (sqrt(0.0504^2 + (1.235/sqrt(et))^2 + (5.24/et)^2))'),
-    eta = cms.string('sqrt(0.00935^2 + (0/sqrt(et))^2 + (1.7398/et)^2)'),
-    phi = cms.string('sqrt(0.00738^2 + (0/sqrt(et))^2 + (2.707/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.305<=abs(eta) && abs(eta)<1.392'),
-    et  = cms.string('et * (sqrt(0.055^2 + (1.239/sqrt(et))^2 + (5.57/et)^2))'),
-    eta = cms.string('sqrt(0.0123^2 + (0/sqrt(et))^2 + (1.773/et)^2)'),
-    phi = cms.string('sqrt(0.00726^2 + (0/sqrt(et))^2 + (2.765/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.392<=abs(eta) && abs(eta)<1.479'),
-    et  = cms.string('et * (sqrt(0.028^2 + (1.351/sqrt(et))^2 + (5.09/et)^2))'),
-    eta = cms.string('sqrt(0.01199^2 + (0/sqrt(et))^2 + (1.784/et)^2)'),
-    phi = cms.string('sqrt(0.00808^2 + (0/sqrt(et))^2 + (2.912/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.479<=abs(eta) && abs(eta)<1.566'),
-    et  = cms.string('et * (sqrt(0.016^2 + (1.317/sqrt(et))^2 + (5.48/et)^2))'),
-    eta = cms.string('sqrt(0.013^2 + (0/sqrt(et))^2 + (1.747/et)^2)'),
-    phi = cms.string('sqrt(0.00887^2 + (0/sqrt(et))^2 + (2.924/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.566<=abs(eta) && abs(eta)<1.653'),
-    et  = cms.string('et * (sqrt(0.007^2 + (1.228/sqrt(et))^2 + (5.66/et)^2))'),
-    eta = cms.string('sqrt(0.00981^2 + (0/sqrt(et))^2 + (1.702/et)^2)'),
-    phi = cms.string('sqrt(0.00441^2 + (0/sqrt(et))^2 + (2.78/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.653<=abs(eta) && abs(eta)<1.740'),
-    et  = cms.string('et * (sqrt(0.028^2 + (1.14/sqrt(et))^2 + (5.7/et)^2))'),
-    eta = cms.string('sqrt(0.00943^2 + (0/sqrt(et))^2 + (1.777/et)^2)'),
-    phi = cms.string('sqrt(0.00804^2 + (0/sqrt(et))^2 + (2.601/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.740<=abs(eta) && abs(eta)<1.830'),
-    et  = cms.string('et * (sqrt(0.0274^2 + (1.112/sqrt(et))^2 + (5.48/et)^2))'),
-    eta = cms.string('sqrt(0.01049^2 + (0.052/sqrt(et))^2 + (1.723/et)^2)'),
-    phi = cms.string('sqrt(0.01001^2 + (0/sqrt(et))^2 + (2.515/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.830<=abs(eta) && abs(eta)<1.930'),
-    et  = cms.string('et * (sqrt(0.0395^2 + (1.007/sqrt(et))^2 + (5.48/et)^2))'),
-    eta = cms.string('sqrt(0.01144^2 + (0.075/sqrt(et))^2 + (1.584/et)^2)'),
-    phi = cms.string('sqrt(0.01056^2 + (0/sqrt(et))^2 + (2.32/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.930<=abs(eta) && abs(eta)<2.043'),
-    et  = cms.string('et * (sqrt(0.0503^2 + (0.82/sqrt(et))^2 + (5.59/et)^2))'),
-    eta = cms.string('sqrt(0.01055^2 + (0.041/sqrt(et))^2 + (1.605/et)^2)'),
-    phi = cms.string('sqrt(0.0109^2 + (0/sqrt(et))^2 + (2.183/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('2.043<=abs(eta) && abs(eta)<2.172'),
-    et  = cms.string('et * (sqrt(0.0392^2 + (0.828/sqrt(et))^2 + (5.08/et)^2))'),
-    eta = cms.string('sqrt(0.01093^2 + (0/sqrt(et))^2 + (1.599/et)^2)'),
-    phi = cms.string('sqrt(0.01189^2 + (0/sqrt(et))^2 + (2.056/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('2.172<=abs(eta) && abs(eta)<2.322'),
-    et  = cms.string('et * (sqrt(0.0461^2 + (0.769/sqrt(et))^2 + (4.73/et)^2))'),
-    eta = cms.string('sqrt(0.01176^2 + (0/sqrt(et))^2 + (1.49/et)^2)'),
-    phi = cms.string('sqrt(0.01082^2 + (0/sqrt(et))^2 + (1.906/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('2.322<=abs(eta) && abs(eta)<2.500'),
-    et  = cms.string('et * (sqrt(0.0436^2 + (0.72/sqrt(et))^2 + (4.2/et)^2))'),
-    eta = cms.string('sqrt(0.01413^2 + (0/sqrt(et))^2 + (1.522/et)^2)'),
-    phi = cms.string('sqrt(0.01097^2 + (0/sqrt(et))^2 + (1.82/et)^2)'),
-    )
-    ),
-                                        constraints = cms.vdouble(0)
-                                        )
-
-bjetResolution = stringResolution.clone(parametrization = 'EtEtaPhi',
-                                        functions = cms.VPSet(
-    cms.PSet(
-    bin = cms.string('0.000<=abs(eta) && abs(eta)<0.087'),
-    et  = cms.string('et * (sqrt(0.0897^2 + (1.091/sqrt(et))^2 + (6.01/et)^2))'),
-    eta = cms.string('sqrt(0.00475^2 + (0/sqrt(et))^2 + (1.8057/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.255/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.087<=abs(eta) && abs(eta)<0.174'),
-    et  = cms.string('et * (sqrt(0.0814^2 + (1.218/sqrt(et))^2 + (5.36/et)^2))'),
-    eta = cms.string('sqrt(0.00401^2 + (0/sqrt(et))^2 + (1.8376/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.256/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.174<=abs(eta) && abs(eta)<0.261'),
-    et  = cms.string('et * (sqrt(0.0872^2 + (1.147/sqrt(et))^2 + (5.86/et)^2))'),
-    eta = cms.string('sqrt(0.00447^2 + (0/sqrt(et))^2 + (1.8346/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.24/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.261<=abs(eta) && abs(eta)<0.348'),
-    et  = cms.string('et * (sqrt(0.0834^2 + (1.151/sqrt(et))^2 + (5.75/et)^2))'),
-    eta = cms.string('sqrt(0.00434^2 + (0/sqrt(et))^2 + (1.8592/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.269/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.348<=abs(eta) && abs(eta)<0.435'),
-    et  = cms.string('et * (sqrt(0.0926^2 + (1.085/sqrt(et))^2 + (5.68/et)^2))'),
-    eta = cms.string('sqrt(0.00466^2 + (0/sqrt(et))^2 + (1.8458/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.241/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.435<=abs(eta) && abs(eta)<0.522'),
-    et  = cms.string('et * (sqrt(0.0724^2 + (1.226/sqrt(et))^2 + (5.36/et)^2))'),
-    eta = cms.string('sqrt(0.00482^2 + (0/sqrt(et))^2 + (1.8723/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.263/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.522<=abs(eta) && abs(eta)<0.609'),
-    et  = cms.string('et * (sqrt(0.0697^2 + (1.253/sqrt(et))^2 + (4.94/et)^2))'),
-    eta = cms.string('sqrt(0.00566^2 + (0/sqrt(et))^2 + (1.8605/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.201/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.609<=abs(eta) && abs(eta)<0.696'),
-    et  = cms.string('et * (sqrt(0.0823^2 + (1.095/sqrt(et))^2 + (6.1/et)^2))'),
-    eta = cms.string('sqrt(0.00539^2 + (0/sqrt(et))^2 + (1.859/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.26/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.696<=abs(eta) && abs(eta)<0.783'),
-    et  = cms.string('et * (sqrt(0.079^2 + (1.171/sqrt(et))^2 + (5.35/et)^2))'),
-    eta = cms.string('sqrt(0.00561^2 + (0/sqrt(et))^2 + (1.862/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.225/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.783<=abs(eta) && abs(eta)<0.870'),
-    et  = cms.string('et * (sqrt(0.0855^2 + (1.141/sqrt(et))^2 + (5.47/et)^2))'),
-    eta = cms.string('sqrt(0.00492^2 + (0/sqrt(et))^2 + (1.879/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.226/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.870<=abs(eta) && abs(eta)<0.957'),
-    et  = cms.string('et * (sqrt(0.0856^2 + (1.173/sqrt(et))^2 + (5.3/et)^2))'),
-    eta = cms.string('sqrt(0.00562^2 + (0/sqrt(et))^2 + (1.882/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.219/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('0.957<=abs(eta) && abs(eta)<1.044'),
-    et  = cms.string('et * (sqrt(0.086^2 + (1.199/sqrt(et))^2 + (5.09/et)^2))'),
-    eta = cms.string('sqrt(0.00426^2 + (0/sqrt(et))^2 + (1.906/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.248/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.044<=abs(eta) && abs(eta)<1.131'),
-    et  = cms.string('et * (sqrt(0.0702^2 + (1.326/sqrt(et))^2 + (4.36/et)^2))'),
-    eta = cms.string('sqrt(0.00429^2 + (0/sqrt(et))^2 + (1.938/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.256/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.131<=abs(eta) && abs(eta)<1.218'),
-    et  = cms.string('et * (sqrt(0.0628^2 + (1.406/sqrt(et))^2 + (3.43/et)^2))'),
-    eta = cms.string('sqrt(0.00232^2 + (0/sqrt(et))^2 + (2.012/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.263/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.218<=abs(eta) && abs(eta)<1.305'),
-    et  = cms.string('et * (sqrt(0.0878^2 + (1.235/sqrt(et))^2 + (5.27/et)^2))'),
-    eta = cms.string('sqrt(0.00652^2 + (0/sqrt(et))^2 + (2.03/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.335/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.305<=abs(eta) && abs(eta)<1.392'),
-    et  = cms.string('et * (sqrt(0.0923^2 + (1.255/sqrt(et))^2 + (4.99/et)^2))'),
-    eta = cms.string('sqrt(0.00909^2 + (0/sqrt(et))^2 + (2.046/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.462/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.392<=abs(eta) && abs(eta)<1.479'),
-    et  = cms.string('et * (sqrt(0.085^2 + (1.327/sqrt(et))^2 + (4.66/et)^2))'),
-    eta = cms.string('sqrt(0.00787^2 + (0/sqrt(et))^2 + (2.158/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.632/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.479<=abs(eta) && abs(eta)<1.566'),
-    et  = cms.string('et * (sqrt(0.0929^2 + (1.257/sqrt(et))^2 + (4.87/et)^2))'),
-    eta = cms.string('sqrt(0.01016^2 + (0/sqrt(et))^2 + (2.111/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.668/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.566<=abs(eta) && abs(eta)<1.653'),
-    et  = cms.string('et * (sqrt(0.057^2 + (1.452/sqrt(et))^2 + (3.11/et)^2))'),
-    eta = cms.string('sqrt(0.00405^2 + (0/sqrt(et))^2 + (2.118/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.42/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.653<=abs(eta) && abs(eta)<1.740'),
-    et  = cms.string('et * (sqrt(0.0825^2 + (1.222/sqrt(et))^2 + (4.76/et)^2))'),
-    eta = cms.string('sqrt(0.0029^2 + (0/sqrt(et))^2 + (2.138/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.223/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.740<=abs(eta) && abs(eta)<1.830'),
-    et  = cms.string('et * (sqrt(0.0679^2 + (1.234/sqrt(et))^2 + (4.62/et)^2))'),
-    eta = cms.string('sqrt(0.0041^2 + (0/sqrt(et))^2 + (2.158/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (3.018/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.830<=abs(eta) && abs(eta)<1.930'),
-    et  = cms.string('et * (sqrt(0.0651^2 + (1.186/sqrt(et))^2 + (4.32/et)^2))'),
-    eta = cms.string('sqrt(0.00454^2 + (0/sqrt(et))^2 + (2.04/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (2.839/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('1.930<=abs(eta) && abs(eta)<2.043'),
-    et  = cms.string('et * (sqrt(0.062^2 + (1.117/sqrt(et))^2 + (4.07/et)^2))'),
-    eta = cms.string('sqrt(0.004^2 + (0/sqrt(et))^2 + (1.963/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (2.624/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('2.043<=abs(eta) && abs(eta)<2.172'),
-    et  = cms.string('et * (sqrt(0.1^2 + (1.1/sqrt(et))^2 + (4.1/et)^2))'),
-    eta = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (2/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (2.6/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('2.172<=abs(eta) && abs(eta)<2.322'),
-    et  = cms.string('et * (sqrt(0.0707^2 + (0.939/sqrt(et))^2 + (3.91/et)^2))'),
-    eta = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (1.7876/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (2.223/et)^2)'),
-    ),
-    cms.PSet(
-    bin = cms.string('2.322<=abs(eta) && abs(eta)<2.500'),
-    et  = cms.string('et * (sqrt(0.018^2 + (1.017/sqrt(et))^2 + (3.31/et)^2))'),
-    eta = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (1.802/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (2.104/et)^2)'),
-    ),
-    ),
-                                        constraints = cms.vdouble(0)
-                                        )
-
-metResolution  = stringResolution.clone(parametrization = 'EtEtaPhi',
-                                        functions = cms.VPSet(
-    cms.PSet(
-    bin = cms.string('-3.000<=abs(eta) && abs(eta)<3.000'),
-    et  = cms.string('et * (sqrt(0^2 + (1.597/sqrt(et))^2 + (19.37/et)^2))'),
-    eta = cms.string('sqrt(0^2 + (0/sqrt(et))^2 + (0/et)^2)'),
-    phi = cms.string('sqrt(0^2 + (0.498/sqrt(et))^2 + (22.468/et)^2)'),
-    ),
-    ),
-                                        constraints = cms.vdouble(0)
-                                        )
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/tauDiscriminators_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/tauDiscriminators_cff.py
deleted file mode 100644
index fb7c253..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/tauDiscriminators_cff.py
+++ /dev/null
@@ -1,13 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-try:
-    from RecoTauTag.Configuration.updateHPSPFTaus_cff import *
-    patHPSPFTauDiscriminationUpdate = cms.Sequence(updateHPSPFTaus)
-except ImportError:
-    patHPSPFTauDiscriminationUpdate = cms.Sequence()
-
-patFixedConePFTauDiscrimination = cms.Sequence()
-
-patShrinkingConePFTauDiscrimination = cms.Sequence()
-
-patCaloTauDiscrimination = cms.Sequence()
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/tauIsolation_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/tauIsolation_cff.py
deleted file mode 100644
index 030a927..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/tauIsolation_cff.py
+++ /dev/null
@@ -1,57 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-import copy
-
-# compute IsoDeposits from all PFCandidates
-tauIsoDepositPFCandidates = cms.EDProducer("CandIsoDepositProducer",
-    src = cms.InputTag("hpsPFTauProducer"),
-    MultipleDepositsFlag = cms.bool(False),
-    trackType = cms.string('candidate'),
-    ExtractorPSet = cms.PSet(
-        # PFTau specific Extractor, which allows to exclude particles within tau signal cone from IsoDeposit computation
-        ComponentName = cms.string('PFTauExtractor'),
-
-        # collection of PFCandidates to be used for IsoDeposit computation
-        candidateSource = cms.InputTag("particleFlow"),
-
-        # size of outer cone for which IsoDeposits are computed
-        DR_Max = cms.double(1.0),
-        # size of inner cone excluded from IsoDeposit computation
-        DR_Veto = cms.double(0.),
-
-        # max. distance in z-direction between tau production vertex and PFCandidates included in IsoDeposit computation
-        # (cut per default disabled, since well-defined for PFCandidates associated to tracks (PFChargedHadrons) only)
-        Diff_z = cms.double(1.e+4),
-        # max. distance in x-y between tau production vertex and PFCandidates included in IsoDeposit computation
-        # (cut per default disabled, since well-defined for PFCandidates associated to tracks (PFChargedHadrons) only)
-        Diff_r = cms.double(1.e+4),
-
-        # collection of PFTaus, needed for excluding particles in tau signal cone from IsoDeposit
-        tauSource = cms.InputTag("hpsPFTauProducer"),
-        # maximum distance in eta-phi, needed to match PFTau to direction passed as function argument to Extractor
-        dRmatchPFTau = cms.double(0.1),
-        # size of cones around tau signal cone particles excluded from IsoDeposit computation
-        dRvetoPFTauSignalConeConstituents = cms.double(0.01),
-
-        DepositLabel = cms.untracked.string('')
-    )
-)
-
-# compute IsoDeposits from PFChargedHadrons
-# (enable cut on z and x-y distance between tau and PFCandidate production vertex)
-tauIsoDepositPFChargedHadrons = copy.deepcopy(tauIsoDepositPFCandidates)
-tauIsoDepositPFChargedHadrons.ExtractorPSet.candidateSource = cms.InputTag("pfAllChargedHadrons")
-tauIsoDepositPFChargedHadrons.ExtractorPSet.Diff_z = cms.double(0.2)
-tauIsoDepositPFChargedHadrons.ExtractorPSet.Diff_r = cms.double(0.1)
-
-# compute IsoDeposits from PFNeutralHadrons
-tauIsoDepositPFNeutralHadrons = copy.deepcopy(tauIsoDepositPFCandidates)
-tauIsoDepositPFNeutralHadrons.ExtractorPSet.candidateSource = cms.InputTag("pfAllNeutralHadrons")
-
-# compute IsoDeposits from PFGammas
-tauIsoDepositPFGammas = copy.deepcopy(tauIsoDepositPFCandidates)
-tauIsoDepositPFGammas.ExtractorPSet.candidateSource = cms.InputTag("pfAllPhotons")
-
-patPFTauIsolation = cms.Sequence( tauIsoDepositPFCandidates
-                                 * tauIsoDepositPFChargedHadrons
-                                 * tauIsoDepositPFNeutralHadrons
-                                 * tauIsoDepositPFGammas )
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/tauJetCorrFactors_cfi.py b/PhysicsTools/PatAlgos/python/recoLayer0/tauJetCorrFactors_cfi.py
deleted file mode 100644
index f34fd35..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/tauJetCorrFactors_cfi.py
+++ /dev/null
@@ -1,42 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from RecoTauTag.TauTagTools.tauDecayModes_cfi import *
-
-# module to produce tau-jet energy correction factors
-patTauJetCorrFactors = cms.EDProducer("TauJetCorrFactorsProducer",
-    # input collection of jets
-    src = cms.InputTag('hpsPFTauProducer'),
-    # mapping of tau decay modes to payloads:
-    # for reco::PFTaus, the decay modes are defined in DataFormats/TauReco/interface/PFTau.h ;
-    # 'other' is taken for all reconstructed decay modes not explicitely specified
-    # for reco::CaloTaus, for which no decay mode reconstruction has been implemented yet,
-    # 'other' is taken for all tau-jet candidates
-    parameters = cms.VPSet(
-        cms.PSet(
-            payload    = cms.string('AK5tauHPSlooseCombDBcorrOneProng0Pi0'),
-            decayModes = cms.vstring('%i' % tauToOneProng0PiZero)
-        ),
-        cms.PSet(
-            payload    = cms.string('AK5tauHPSlooseCombDBcorrOneProng1Pi0'),
-            decayModes = cms.vstring('%i' % tauToOneProng1PiZero)
-        ),
-        cms.PSet(
-            payload    = cms.string('AK5tauHPSlooseCombDBcorrOneProng2Pi0'),
-            decayModes = cms.vstring('%i' % tauToOneProng2PiZero)
-        ),
-        cms.PSet(
-            payload    = cms.string('AK5tauHPSlooseCombDBcorrThreeProng0Pi0'),
-            decayModes = cms.vstring('%i' % tauToThreeProng0PiZero)
-        ),
-        cms.PSet(
-            payload    = cms.string('AK5tauHPSlooseCombDBcorr'),
-            decayModes = cms.vstring('*')
-        )
-    ),
-    # correction levels
-    levels = cms.vstring(
-        # tags for the individual jet corrections;
-        # when not available the string should be set to 'none'
-        'L2Relative', 'L3Absolute'
-    )
-)
diff --git a/PhysicsTools/PatAlgos/python/recoLayer0/tauJetCorrections_cff.py b/PhysicsTools/PatAlgos/python/recoLayer0/tauJetCorrections_cff.py
deleted file mode 100644
index afd6ee4..0000000
--- a/PhysicsTools/PatAlgos/python/recoLayer0/tauJetCorrections_cff.py
+++ /dev/null
@@ -1,34 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# load tau-jet specific JEC parameters from SQLlite file
-payloads = [
-    'AK5tauHPSlooseCombDBcorr',
-    'AK5tauHPSlooseCombDBcorrOneProng0Pi0',
-    'AK5tauHPSlooseCombDBcorrOneProng1Pi0',
-    'AK5tauHPSlooseCombDBcorrOneProng2Pi0',
-    'AK5tauHPSlooseCombDBcorrThreeProng0Pi0'
-]    
-
-PoolDBESSource_toGet = []
-for payload in payloads:
-    PoolDBESSource_toGet.append(cms.PSet(
-        record = cms.string('JetCorrectionsRecord'),
-        tag    = cms.string('JetCorrectorParametersCollection_TauJec11_V1_%s' % payload),
-        label  = cms.untracked.string(payload)
-    ))
-
-SQLliteInput = cms.ESSource("PoolDBESSource",
-    DBParameters = cms.PSet(
-        messageLevel = cms.untracked.int32(0)
-    ),
-    timetype = cms.string('runnumber'),
-    toGet = cms.VPSet(PoolDBESSource_toGet),
-    connect = cms.string('sqlite_fip:CondFormats/JetMETObjects/data/TauJec11_V1.db')
-)
-es_prefer_jec = cms.ESPrefer('PoolDBESSource', 'SQLliteInput')
-
-# produce associated tau-jet energy correction factors in a valuemap
-from PhysicsTools.PatAlgos.recoLayer0.tauJetCorrFactors_cfi import *
-patTauJetCorrections = cms.Sequence(patTauJetCorrFactors)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/countPatCandidates_cff.py b/PhysicsTools/PatAlgos/python/selectionLayer1/countPatCandidates_cff.py
deleted file mode 100644
index 599f23c..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/countPatCandidates_cff.py
+++ /dev/null
@@ -1,17 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.selectionLayer1.electronCountFilter_cfi import *
-from PhysicsTools.PatAlgos.selectionLayer1.muonCountFilter_cfi import *
-from PhysicsTools.PatAlgos.selectionLayer1.tauCountFilter_cfi import *
-from PhysicsTools.PatAlgos.selectionLayer1.photonCountFilter_cfi import *
-from PhysicsTools.PatAlgos.selectionLayer1.jetCountFilter_cfi import *
-from PhysicsTools.PatAlgos.selectionLayer1.leptonCountFilter_cfi import *
-
-countPatCandidates = cms.Sequence(
-    countPatElectrons +
-    countPatMuons     +
-    countPatTaus      +
-    countPatLeptons   +
-    countPatPhotons   +
-    countPatJets 
-)
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/electronCountFilter_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/electronCountFilter_cfi.py
deleted file mode 100644
index 80af141..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/electronCountFilter_cfi.py
+++ /dev/null
@@ -1,10 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to filter on the number of Electrons
-countPatElectrons = cms.EDFilter("PATCandViewCountFilter",
-    minNumber = cms.uint32(0),
-    maxNumber = cms.uint32(999999),
-    src = cms.InputTag("cleanPatElectrons")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/electronSelector_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/electronSelector_cfi.py
deleted file mode 100644
index 49b5119..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/electronSelector_cfi.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to select Electrons
-# See https://twiki.cern.ch/twiki/bin/view/CMS/SWGuidePhysicsCutParser
-# on how to use the cut-string
-#
-selectedPatElectrons = cms.EDFilter("PATElectronSelector",
-    src = cms.InputTag("patElectrons"),
-    cut = cms.string("")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/jetCountFilter_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/jetCountFilter_cfi.py
deleted file mode 100644
index 8927cf5..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/jetCountFilter_cfi.py
+++ /dev/null
@@ -1,10 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to filter on the number of Jets
-countPatJets = cms.EDFilter("PATCandViewCountFilter",
-    minNumber = cms.uint32(0),
-    maxNumber = cms.uint32(999999),
-    src = cms.InputTag("cleanPatJets")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/jetSelector_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/jetSelector_cfi.py
deleted file mode 100644
index 506511c..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/jetSelector_cfi.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to select Jets
-# See https://twiki.cern.ch/twiki/bin/view/CMS/SWGuidePhysicsCutParser
-# on how to use the cut-string
-#
-selectedPatJets = cms.EDFilter("PATJetSelector",
-    src = cms.InputTag("patJets"),
-    cut = cms.string("")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/leptonCountFilter_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/leptonCountFilter_cfi.py
deleted file mode 100644
index 7a025c5..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/leptonCountFilter_cfi.py
+++ /dev/null
@@ -1,15 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to filter on the number of Leptons
-countPatLeptons = cms.EDFilter("PATLeptonCountFilter",
-    electronSource = cms.InputTag("cleanPatElectrons"),
-    muonSource     = cms.InputTag("cleanPatMuons"),
-    tauSource      = cms.InputTag("cleanPatTaus"),
-    countElectrons = cms.bool(True),
-    countMuons     = cms.bool(True),
-    countTaus      = cms.bool(False),
-    minNumber = cms.uint32(0),
-    maxNumber = cms.uint32(999999),
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/metCountFilter_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/metCountFilter_cfi.py
deleted file mode 100644
index 08cbbd1..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/metCountFilter_cfi.py
+++ /dev/null
@@ -1,10 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to filter on the number of Jets
-countPatMET = cms.EDFilter("PATCandViewCountFilter",
-    minNumber = cms.uint32(0),
-    maxNumber = cms.uint32(999999),
-    src = cms.InputTag("PatMETs")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/metSelector_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/metSelector_cfi.py
deleted file mode 100644
index f0d8c2f..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/metSelector_cfi.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to select met
-# See https://twiki.cern.ch/twiki/bin/view/CMS/SWGuidePhysicsCutParser
-# on how to use the cut-string
-#
-selectedPatMET = cms.EDFilter("PATMETSelector",
-    src = cms.InputTag("patMETs"),
-    cut = cms.string("")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/muonCountFilter_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/muonCountFilter_cfi.py
deleted file mode 100644
index 1064e9e..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/muonCountFilter_cfi.py
+++ /dev/null
@@ -1,10 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to filter on the number of Muons
-countPatMuons = cms.EDFilter("PATCandViewCountFilter",
-    minNumber = cms.uint32(0),
-    maxNumber = cms.uint32(999999),
-    src = cms.InputTag("cleanPatMuons")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/muonSelector_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/muonSelector_cfi.py
deleted file mode 100644
index f10eedf..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/muonSelector_cfi.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to select Muons
-# See https://twiki.cern.ch/twiki/bin/view/CMS/SWGuidePhysicsCutParser
-# on how to use the cut-string
-#
-selectedPatMuons = cms.EDFilter("PATMuonSelector",
-    src = cms.InputTag("patMuons"),
-    cut = cms.string("")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/objectEnergyScale_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/objectEnergyScale_cfi.py
deleted file mode 100644
index 7fc5377..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/objectEnergyScale_cfi.py
+++ /dev/null
@@ -1,185 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-##
-## Modules for shifting and smearing 4-vectors' energies of Objects
-##
-## Parameters:
-## - InputTag scaledObject: 
-##   Specify objects to shift & smear.
-##   Object type should correspond to module (e.g. Electron in module ElectronEnergyScale) 
-## - bool fixMass:
-##   Set to "true", if mass should not be smeared, e.g. for leptons with known masses.
-##   IMPORTANT: Don't trust this feature at the moment !!! (s. remarks below)
-## - double shiftFactor:
-##   Scales the 4-vector with this fixed value.
-##   E.g. to have all muon energies increased by 12.5%, set "1.125" here.
-##   Default is "1.", which has -- of course -- no effect
-## - bool useDefaultInitialResolution:
-##   Objects contain individual 4-vector resolutions (in terms of Et, theta/eta, phi).
-##   Set this to "true" if these should be used to compute initial resolutions for the smearing.
-## - double initialResolution:
-##   Initial resolution to be used for the energy smearing.
-##   Can be an absolute value (in GeV) or a factor giving the fraction of the smeared energy.
-##   Overwritten, if 'useDefaultInitialResolution' is "true".
-## - bool initialResolutionByFraction:
-##   Flags the usage mode of 'initialResolution'.
-##   E.g. to set the initial resolution to 5% of the energy, set this to "true" and 'initialResolution' to "0.05".
-##   To use a fixed resolution of 1GeV, set this to "false" and 'initialResolution' to "1.".
-## - double worsenResolution:
-##   Used to calculate the final resolution (after smearing) from the initial resolution.
-##   Can be an absolute value (in GeV) or a factor.
-##   The energy is smeared with a Gaussion of
-##   mu    = energy and
-##   sigma = sqrt(finalRes^2-iniRes^2)
-##   with a cut-off at 0.
-## - bool worsenResolutionByFactor:
-##   Flags the usage mode of 'worsenResolution'.
-##
-## Examples:
-## - smear Electron 4-vector (fixed mass) with a fixed initial resolution of 500MeV to as final resolution of 1.25GeV:
-##  scaledElectrons = cms.module(ElectronEnergyScale) {
-##    scaledObject                = cms.InputTag("selectedPatElectrons")
-##    fixMass                     = cms.bool(True)
-##    shiftFactor                 = cms.double(1.)
-##    useDefaultInitialResolution = cms.bool(False)
-##    initialResolution           = cms.double(0.5)
-##    initialResolutionByFraction = cms.bool(False)   ## alternative:
-##    worsenResolution            = cms.double(0.75)  ## 2.5
-##    worsenResolutionByFactor    = cms.bool(False)   ## true
-##   }
-## - smear Muon 4-vector (fixed mass) with a initial resolution of 10% to as final resoltion of 20%:
-##  scaledMuons = cms.module(MuonEnergyScale) {
-##    scaledObject                = cms.InputTag("selectedPatMuons")
-##    fixMass                     = cms.bool(True)
-##    shiftFactor                 = cms.double(1.)
-##    useDefaultInitialResolution = cms.bool(True)
-##    initialResolution           = cms.double(0.1)
-##    initialResolutionByFraction = cms.bool(True)
-##    worsenResolution            = cms.double(2.)
-##    worsenResolutionByFactor    = cms.bool(True)
-##   }
-## - smear Jet 4-vector to a final resoltion of 150% of the default initial resolution:
-##  scaledJets = cms.module(JetEnergyScale) {
-##    scaledObject                = cms.InputTag("selectedPatAK5CaloJets")
-##    fixMass                     = cms.bool(False)  ## ===> no fixed mass for the jet
-##    shiftFactor                 = cms.double(1.)
-##    useDefaultInitialResolution = cms.bool(True)
-##    initialResolution           = cms.double(0.05) ## ===> overwritten by "useDefaultInitialResolution = true"
-##    initialResolutionByFraction = cms.bool(True)
-##    worsenResolution            = cms.double(1.5)
-##    worsenResolutionByFactor    = cms.bool(True)
-##   }
-##
-## Remarks:
-## - Due to the inclusion of the default initial resolutions, these modules are limited to Objects for the moment.
-## - The smearing takes care, that final resolutions do not become smaller than initial resolutions.
-##   E.g. if (worsenResolution=0.6 && worsenResolutionByFactor=true) is set, it is assumed that the final resolution
-##   should be 40% worse than the initial resolution. So, 'worsenResolution' is set to 1.4 internally.
-##   (Analogously for (worsenResolution<0. && worsenResolutionByFactor=false).)
-## - To switch off energy shifting, use (shiftFactor=1.).
-## - To switch off energy smearing, use (worsenResolution=0. && worsenResolutionByFactor=false) or
-##   (worsenResolution=1. && worsenResolutionByFactor=true).
-## - In the standard sequence at the bottom of this file, Taus are commented.
-## - (fixMass=true) isn't reliable so far :-(
-##   The input provided by class Particle is not yet understood (Negative mass for positive mass^2 in contradiction to ROOT::TLorentzVector).
-##
-## Contact: volker.adler@cern.ch
-##
-
-
-## initialize random number generator
-RandomNumberGeneratorService = cms.Service("RandomNumberGeneratorService",
-    scaledElectrons = cms.PSet(
-        initialSeed = cms.untracked.uint32(897867),
-        engineName = cms.untracked.string('HepJamesRandom')
-    ),
-    scaledMuons = cms.PSet(
-        initialSeed = cms.untracked.uint32(17987),
-        engineName = cms.untracked.string('HepJamesRandom')
-    ),
-    theSource = cms.PSet(
-        initialSeed = cms.untracked.uint32(7893456),
-        engineName = cms.untracked.string('HepJamesRandom')
-    ),
-    scaledTaus = cms.PSet(
-        initialSeed = cms.untracked.uint32(38476),
-        engineName = cms.untracked.string('HepJamesRandom')
-    ),
-    scaledJets = cms.PSet(
-        initialSeed = cms.untracked.uint32(61587),
-        engineName = cms.untracked.string('HepJamesRandom')
-    ),
-    scaledMETs = cms.PSet(
-        initialSeed = cms.untracked.uint32(3489766),
-        engineName = cms.untracked.string('HepJamesRandom')
-    )
-)
-
-## Electrons
-scaledElectrons = cms.EDFilter("ElectronEnergyScale",
- scaledObject                = cms.InputTag("selectedPatElectrons"),
- fixMass                     = cms.bool(False),
- shiftFactor                 = cms.double(1.),
- useDefaultInitialResolution = cms.bool(True),
- initialResolution           = cms.double(0.),
- initialResolutionByFraction = cms.bool(True),
- worsenResolution            = cms.double(1.),
- worsenResolutionByFactor    = cms.bool(True),
-)
-
-## Muons
-scaledMuons = cms.EDFilter("MuonEnergyScale",
- scaledObject                = cms.InputTag("selectedPatMuons"),
- fixMass                     = cms.bool(False),
- shiftFactor                 = cms.double(1.),
- useDefaultInitialResolution = cms.bool(True),
- initialResolution           = cms.double(0.),
- initialResolutionByFraction = cms.bool(True),
- worsenResolution            = cms.double(1.),
- worsenResolutionByFactor    = cms.bool(True),
-)
-
-## Taus
-scaledTaus = cms.EDFilter("TauEnergyScale",
- scaledObject                = cms.InputTag("selectedPatTaus"),
- fixMass                     = cms.bool(False),
- shiftFactor                 = cms.double(1.),
- useDefaultInitialResolution = cms.bool(True),
- initialResolution           = cms.double(0.),
- initialResolutionByFraction = cms.bool(True),
- worsenResolution            = cms.double(1.),
- worsenResolutionByFactor    = cms.bool(True),
-)
-
-## Jets
-scaledJets = cms.EDFilter("JetEnergyScale",
- scaledObject                = cms.InputTag("selectedPatJets"),
- fixMass                     = cms.bool(False),
- shiftFactor                 = cms.double(1.),
- useDefaultInitialResolution = cms.bool(True),
- initialResolution           = cms.double(0.),
- initialResolutionByFraction = cms.bool(True),
- worsenResolution            = cms.double(1.),
- worsenResolutionByFactor    = cms.bool(True),
-)
-
-## METs
-scaledMETs = cms.EDFilter("METEnergyScale",
- scaledObject                = cms.InputTag("selectedPatMETs"),
- fixMass                     = cms.bool(False),
- shiftFactor                 = cms.double(1.),
- useDefaultInitialResolution = cms.bool(True),
- initialResolution           = cms.double(0.),
- initialResolutionByFraction = cms.bool(True),
- worsenResolution            = cms.double(1.),
- worsenResolutionByFactor    = cms.bool(True),
-)
-
-## Standard sequence for all Objects
-scaledObjects = cms.Sequence(
-    scaledElectrons + 
-    scaledMuons + 
-    scaledJets + 
-#   scaledTaus +
-    scaledMETs
-)
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/objectSpatialResolution_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/objectSpatialResolution_cfi.py
deleted file mode 100644
index 9d2e59c..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/objectSpatialResolution_cfi.py
+++ /dev/null
@@ -1,139 +0,0 @@
-# The following comments couldn't be translated into the new config version:
-
-#
-# Modules for smearing 4-vector's angles of Objects
-#
-# Parameters:
-# - InputTag movedObject:
-#   Specify object to smear. 
-#   Object type should correspond to module (e.g. Electron in module ElectronSpatialResolution) 
-# - bool useDefaultInitialResolutions :
-#   Objects contain individual 4-vector resolutions (in terms of Et, theta/eta, phi).
-#   Set this to "true" if these should be used to compute initial resolutions for the smearing.
-# - bool usePolarTheta:
-#   Switch to specify, if eta or rather theta is used for the polar angle smearing.
-#   Set this to "true" to smear theta or to "false" to smear eta.
-# - double initialResolutionPolar:
-#   Initial resolution (in radiants for theta) to be used for the eta/theta smearing.
-#   Is given as absolute value only, since factors make no sense for angles.
-#   Overwritten, if 'useDefaultInitialResolution' is "true".
-# - double worsenResolutionPolar:
-#   Used to calculate the final resolution (after smearing) from the initial resolution.
-#   The angle is smeared with a Gaussion of
-#   mu    = angle and
-#   sigma = sqrt(finalRes^2-iniRes^2).
-# - bool worsenResolutionPolarByFactor:
-#   Flags the usage mode of 'worsenResolutionPolar' (how the final resolution is calculated from the initial one)
-# - double initialResolutionPhi, double worsenResolutionPhi and bool worsenResolutionPhiByFactor:
-#   Accordingly...
-#
-# Examples:
-#
-# Remarks:
-# - To switch off angular smearing, use (worsenResolutionPolar=0.) resp. (worsenResolutionPhi=0.)
-# - All numeric values are protected from "meaninglessness" by the usage of absolute values only.
-# - In the standard sequence at the bottom of this file, Taus are commented.
-# - Keep polar smearing switched off for MET objects!!! ;-)
-#
-# Contact: volker.adler@cern.ch
-#
-# initialize random number generator
-
-import FWCore.ParameterSet.Config as cms
-
-RandomNumberGeneratorService = cms.Service("RandomNumberGeneratorService",
-    movedElectrons = cms.PSet(
-        initialSeed = cms.untracked.uint32(897867),
-        engineName = cms.untracked.string('HepJamesRandom')
-    ),
-    movedMuons = cms.PSet(
-        initialSeed = cms.untracked.uint32(17987),
-        engineName = cms.untracked.string('HepJamesRandom')
-    ),
-    theSource = cms.PSet(
-        initialSeed = cms.untracked.uint32(7893456),
-        engineName = cms.untracked.string('HepJamesRandom')
-    ),
-    movedTaus = cms.PSet(
-        initialSeed = cms.untracked.uint32(38476),
-        engineName = cms.untracked.string('HepJamesRandom')
-    ),
-    movedJets = cms.PSet(
-        initialSeed = cms.untracked.uint32(61587),
-        engineName = cms.untracked.string('HepJamesRandom')
-    ),
-    movedMETs = cms.PSet(
-        initialSeed = cms.untracked.uint32(3489766),
-        engineName = cms.untracked.string('HepJamesRandom')
-    )
-)
-
-movedElectrons = cms.EDFilter("ElectronSpatialResolution",
-    worsenResolutionPolar = cms.double(2.0),
-    worsenResolutionPhi = cms.double(1.0),
-    worsenResolutionPolarByFactor = cms.bool(True),
-    usePolarTheta = cms.bool(True),
-    movedObject = cms.InputTag("selectedPatElectrons"),
-    useDefaultInitialResolutions = cms.bool(False),
-    worsenResolutionPhiByFactor = cms.bool(True),
-    initialResolutionPhi = cms.double(0.0),
-    initialResolutionPolar = cms.double(0.005)
-)
-
-movedMuons = cms.EDFilter("MuonSpatialResolution",
-    worsenResolutionPolar = cms.double(2.0),
-    worsenResolutionPhi = cms.double(1.0),
-    worsenResolutionPolarByFactor = cms.bool(True),
-    usePolarTheta = cms.bool(False),
-    movedObject = cms.InputTag("selectedPatMuons"),
-    useDefaultInitialResolutions = cms.bool(False),
-    worsenResolutionPhiByFactor = cms.bool(True),
-    initialResolutionPhi = cms.double(0.0),
-    initialResolutionPolar = cms.double(0.005)
-)
-
-movedTaus = cms.EDFilter("TauSpatialResolution",
-    worsenResolutionPolar = cms.double(1.0),
-    worsenResolutionPhi = cms.double(1.0),
-    worsenResolutionPolarByFactor = cms.bool(True),
-    usePolarTheta = cms.bool(True),
-    movedObject = cms.InputTag("selectedPatTaus"),
-    useDefaultInitialResolutions = cms.bool(False),
-    worsenResolutionPhiByFactor = cms.bool(True),
-    initialResolutionPhi = cms.double(0.0),
-    initialResolutionPolar = cms.double(0.0)
-)
-
-movedJets = cms.EDFilter("JetSpatialResolution",
-    worsenResolutionPolar = cms.double(0.25),
-    worsenResolutionPhi = cms.double(1.0),
-    worsenResolutionPolarByFactor = cms.bool(False),
-    usePolarTheta = cms.bool(True),
-    movedObject = cms.InputTag("selectedPatJets"),
-    useDefaultInitialResolutions = cms.bool(False),
-    worsenResolutionPhiByFactor = cms.bool(True),
-    initialResolutionPhi = cms.double(0.0),
-    initialResolutionPolar = cms.double(0.1)
-)
-
-movedMETs = cms.EDFilter("METSpatialResolution",
-    worsenResolutionPolar = cms.double(1.0),
-    worsenResolutionPhi = cms.double(1.6),
-    worsenResolutionPolarByFactor = cms.bool(True),
-    usePolarTheta = cms.bool(True),
-    movedObject = cms.InputTag("selectedPatMETs"),
-    useDefaultInitialResolutions = cms.bool(False),
-    worsenResolutionPhiByFactor = cms.bool(False),
-    initialResolutionPhi = cms.double(0.8),
-    initialResolutionPolar = cms.double(0.0)
-)
-
-# Standard sequence for all objects
-movedObjects = cms.Sequence(
-    movedElectrons + 
-    movedMuons + 
-    movedJets + 
-#   movedTaus +
-    movedMETs
-)
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/photonCountFilter_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/photonCountFilter_cfi.py
deleted file mode 100644
index 9a259e8..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/photonCountFilter_cfi.py
+++ /dev/null
@@ -1,9 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to filter on the number of Photons
-countPatPhotons = cms.EDFilter("PATCandViewCountFilter",
-    minNumber = cms.uint32(0),
-    maxNumber = cms.uint32(999999),
-    src = cms.InputTag("cleanPatPhotons")
-)
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/photonSelector_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/photonSelector_cfi.py
deleted file mode 100644
index e6bd9ad..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/photonSelector_cfi.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to select Photons
-# See https://twiki.cern.ch/twiki/bin/view/CMS/SWGuidePhysicsCutParser
-# on how to use the cut-string
-#
-selectedPatPhotons = cms.EDFilter("PATPhotonSelector",
-    src = cms.InputTag("patPhotons"),
-    cut = cms.string("")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/selectedPatCandidates_cff.py b/PhysicsTools/PatAlgos/python/selectionLayer1/selectedPatCandidates_cff.py
deleted file mode 100644
index a04f700..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/selectedPatCandidates_cff.py
+++ /dev/null
@@ -1,30 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.selectionLayer1.electronSelector_cfi import *
-from PhysicsTools.PatAlgos.selectionLayer1.muonSelector_cfi import *
-from PhysicsTools.PatAlgos.selectionLayer1.tauSelector_cfi import *
-from PhysicsTools.PatAlgos.selectionLayer1.photonSelector_cfi import *
-from PhysicsTools.PatAlgos.selectionLayer1.jetSelector_cfi import *
-#from PhysicsTools.PatAlgos.producersLayer1.hemisphereProducer_cfi import *
-
-# One module to count objects
-selectedPatCandidateSummary = cms.EDAnalyzer("CandidateSummaryTable",
-    logName = cms.untracked.string("selectedPatCanddiates|PATSummaryTables"),
-    candidates = cms.VInputTag(
-        cms.InputTag("selectedPatElectrons"),
-        cms.InputTag("selectedPatMuons"),
-        cms.InputTag("selectedPatTaus"),
-        cms.InputTag("selectedPatPhotons"),
-        cms.InputTag("selectedPatJets"),
-    )
-)
-
-
-selectedPatCandidates = cms.Sequence(
-    selectedPatElectrons +
-    selectedPatMuons     +
-    selectedPatTaus      +
-    selectedPatPhotons   +
-    selectedPatJets      +
-    selectedPatCandidateSummary
-)
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/tauCountFilter_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/tauCountFilter_cfi.py
deleted file mode 100644
index 9c701fc..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/tauCountFilter_cfi.py
+++ /dev/null
@@ -1,10 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to filter on the number of Taus
-countPatTaus = cms.EDFilter("PATCandViewCountFilter",
-    minNumber = cms.uint32(0),
-    maxNumber = cms.uint32(999999),
-    src = cms.InputTag("cleanPatTaus")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/tauSelector_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/tauSelector_cfi.py
deleted file mode 100644
index 2922b56..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/tauSelector_cfi.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to select Taus
-# See https://twiki.cern.ch/twiki/bin/view/CMS/SWGuidePhysicsCutParser
-# on how to use the cut-string
-#
-selectedPatTaus = cms.EDFilter("PATTauSelector",
-    src = cms.InputTag("patTaus"),
-    cut = cms.string("")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/selectionLayer1/trackSelector_cfi.py b/PhysicsTools/PatAlgos/python/selectionLayer1/trackSelector_cfi.py
deleted file mode 100644
index ea695ec..0000000
--- a/PhysicsTools/PatAlgos/python/selectionLayer1/trackSelector_cfi.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# module to select Taus
-# See https://twiki.cern.ch/twiki/bin/view/CMS/SWGuidePhysicsCutParser
-# on how to use the cut-string
-#
-selectedPatTracks = cms.EDFilter("PATGenericParticleSelector",
-    src = cms.InputTag("allPatTracks"),
-    cut = cms.string("")
-)
-
-
diff --git a/PhysicsTools/PatAlgos/python/tools/circuitry.py b/PhysicsTools/PatAlgos/python/tools/circuitry.py
deleted file mode 100644
index c81b6bd..0000000
--- a/PhysicsTools/PatAlgos/python/tools/circuitry.py
+++ /dev/null
@@ -1,92 +0,0 @@
-def plotSequences(seq,filename):
-    from sys import stderr, argv
-    from os import popen
-    from os.path import basename
-    from re import sub;
-    import FWCore.ParameterSet.Config as cms
-    stderr.write("Writing plot to %s\n" % (filename,))
-    dot = popen("dot -Tpng > %s" % (filename,), "w")
-    dot.write("digraph G { \n rankdir=\"LR\" \n")
-    class visitor(object):
-        def __init__(self,seq,dot):
-            self._dot = dot
-            self._stack = []
-            self._seq = seq.label()
-            self._dot.write( "%s [  shape=rect style=filled fillcolor=%s label=\"%s\" ]" % (self._seq,'orange',self._seq) + "\n" )
-        def seq(self, seq):
-            self._stack.append(self._seq)
-            self._seq = seq.label()
-        def enter(self,v):
-            if isinstance(v, cms.Sequence):
-                self._dot.write( "%s [  shape=rect style=filled fillcolor=%s label=\"%s\" ]" % (v.label(),'orange',v.label()) + "\n" )
-                self.dep(v)
-                self.seq(v)
-            if isinstance(v, (cms.EDProducer, cms.EDFilter, cms.EDAnalyzer)):
-                self._dot.write( "%s [  shape=rect style=filled fillcolor=%s label=\"%s\" ]" % (v.label(),'green',v.label()) + "\n" ) 
-                self.dep(v)
-        def leave(self,v):
-            if isinstance(v, cms.Sequence):
-                self._seq = self._stack.pop()
-        def dep(self,v):
-            self._dot.write("%s -> %s" %(v.label(), self._seq) +"\n")
-    seq.visit(visitor(seq,dot))
-    dot.write("}\n")
-    dot.close()
-
-def plotModuleInputs(seq,filename,printOuter=True,printLinkNames=True):
-    from sys import stderr, argv
-    from os import popen
-    from os.path import basename
-    from re import sub;
-    import FWCore.ParameterSet.Config as cms
-    stderr.write("Writing plot to %s\n" % (filename,))
-    dot = popen("dot -Tpng > %s" % (filename,), "w")
-    #dot = open("%s.dot" % (filename,), "w")
-    dot.write("digraph G { \n rankdir=\"LR\" \n")
-    deps = {}; alls = {}
-    modules = []
-    class visitor(object):
-        def enter(self,v):
-            if isinstance(v, (cms.EDProducer, cms.EDFilter, cms.EDAnalyzer)):
-                modules.append(v)
-        def leave(self,v):
-            pass
-    def greptags(ps,basename=""):
-        ret = []
-        for pn, pv in ps.parameters_().items():
-            type = pv.configTypeName()
-            if type == 'InputTag'    : ret.append( (basename+pn, pv.configValue()) )
-            elif type == 'VInputTag' : ret += [ ("%s%s[%d]"%(basename,pn,i+1),v.configValue()) for i,v in enumerate(pv.value()) ]
-            elif type == 'PSet'      : ret += greptags(pv, basename+pn+'.')
-            elif type == 'VPset'     : 
-                for r1 in [greptags(pvi, basename+pn+'.') for pvi in pv.value()]: ret += r1
-        return ret
-    def escapeParValue(name): return sub(r":.*","", name)
-    seq.visit(visitor())
-    for m in modules:
-        dot.write( "%s [  shape=rect style=filled fillcolor=%s label=\"%s\" ]" % (m.label(),'green',m.label()) + "\n")
-        tags = greptags(m)
-        #stderr.write("Tags for %s: %s\n" % (m.label(), tags))
-        deps[m.label()] = tags;
-        if not alls.has_key(m.label()): alls[m.label()]=True
-        for (tn,tv) in tags:
-            tve = escapeParValue(tv)
-            if not alls.has_key(tve): alls[tve]=True
-    names = deps.keys();
-    if printOuter: names = alls.keys()
-    done = {}
-    for n in names:
-        ne = escapeParValue(n)
-        if not deps.has_key(ne):
-            dot.write( "%s [  shape=rect style=filled fillcolor=%s label=\"%s\" ]" % (ne,'yellow',ne) + "\n")
-        else:
-            for tn,tv in deps[ne]:
-                tve = escapeParValue(tv)
-                if printOuter or deps.has_key(tve):
-                    style = ""
-                    if printLinkNames: style = " [label=\"%s\" ]" %(tn,)
-                    dot.write(  "%s -> %s%s\n"%(tve,ne,style))
-    dot.write("}\n")
-    dot.close()
-
-
diff --git a/PhysicsTools/PatAlgos/python/tools/cmsswVersionTools.py b/PhysicsTools/PatAlgos/python/tools/cmsswVersionTools.py
deleted file mode 100644
index 0c23307..0000000
--- a/PhysicsTools/PatAlgos/python/tools/cmsswVersionTools.py
+++ /dev/null
@@ -1,442 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from FWCore.GuiBrowsers.ConfigToolBase import *
-from PhysicsTools.PatAlgos.tools.helpers import *
-from PhysicsTools.PatAlgos.tools.jetTools import *
-from Configuration.AlCa.autoCond import autoCond
-
-import os
-import socket
-from subprocess import *
-import json
-import das_client
-
-
-## ---------------------------------------------
-## Adjust trigger content in AOD for CMSSW_5_2_X
-## ---------------------------------------------
-
-class Run52xOn51xTrigger( ConfigToolBase ):
-    """ Adjust trigger content in AOD for CMSSW_5_2_X
-    """
-    _label             = 'run52xOn51xTrigger'
-    _defaultParameters = dicttypes.SortedKeysDict()
-
-    def __init__( self ):
-        ConfigToolBase.__init__( self )
-        self.addParameter( self._defaultParameters, 'sequence', 'patDefaultSequence', "Name of sequence to use, default: 'patDefaultSequence'" )
-        self._parameters = copy.deepcopy( self._defaultParameters )
-
-    def getDefaultParameters( self ):
-        return self._defaultParameters
-
-    def __call__( self, process
-                , sequence     = None
-                ):
-        if sequence is None:
-            sequence = self._defaultParameters[ 'sequence' ].value
-        self.setParameter( 'sequence', sequence )
-        return self.apply( process )
-
-    def apply( self, process ):
-        sequence = self._parameters[ 'sequence' ].value
-
-        from L1Trigger.GlobalTrigger.convertObjectMapRecord_cfi import convertObjectMapRecord
-        process.l1L1GtObjectMap = convertObjectMapRecord.clone()
-        getattr( process, sequence ).insert( 0, getattr( process, 'l1L1GtObjectMap' ) )
-
-run52xOn51xTrigger = Run52xOn51xTrigger()
-
-
-## ------------------------------------------------------
-## Automatic pick-up of RelVal input files
-## ------------------------------------------------------
-
-class PickRelValInputFiles( ConfigToolBase ):
-    """  Picks up RelVal input files automatically and
-  returns a vector of strings with the paths to be used in [PoolSource].fileNames
-    PickRelValInputFiles( cmsswVersion, relVal, dataTier, condition, globalTag, maxVersions, skipFiles, numberOfFiles, debug )
-    - useDAS       : switch to perform query in DAS rather than in DBS
-                     optional; default: False
-    - cmsswVersion : CMSSW release to pick up the RelVal files from
-                     optional; default: the current release (determined automatically from environment)
-    - formerVersion: use the last before the last valid CMSSW release to pick up the RelVal files from
-                     applies also, if 'cmsswVersion' is set explicitly
-                     optional; default: False
-    - relVal       : RelVal sample to be used
-                     optional; default: 'RelValTTbar'
-    - dataTier     : data tier to be used
-                     optional; default: 'GEN-SIM-RECO'
-    - condition    : identifier of GlobalTag as defined in Configurations/PyReleaseValidation/python/autoCond.py
-                     possibly overwritten, if 'globalTag' is set explicitly
-                     optional; default: 'startup'
-    - globalTag    : name of GlobalTag as it is used in the data path of the RelVals
-                     optional; default: determined automatically as defined by 'condition' in Configurations/PyReleaseValidation/python/autoCond.py
-      !!!            Determination is done for the release one runs in, not for the release the RelVals have been produced in.
-      !!!            Example of deviation: data RelVals (CMSSW_4_1_X) might not only have the pure name of the GlobalTag 'GR_R_311_V2' in the full path,
-                     but also an extension identifying the data: 'GR_R_311_V2_RelVal_wzMu2010B'
-    - maxVersions  : max. versioning number of RelVal to check
-                     optional; default: 9
-    - skipFiles    : number of files to skip for a found RelVal sample
-                     optional; default: 0
-    - numberOfFiles: number of files to pick up
-                     setting it to negative values, returns all found ('skipFiles' remains active though)
-                     optional; default: -1
-    - debug        : switch to enable enhanced messages in 'stdout'
-                     optional; default: False
-    """
-
-    _label             = 'pickRelValInputFiles'
-    _defaultParameters = dicttypes.SortedKeysDict()
-
-    def getDefaultParameters( self ):
-        return self._defaultParameters
-
-    def __init__( self ):
-        ConfigToolBase.__init__( self )
-        self.addParameter( self._defaultParameters, 'useDAS'       , False                                                               , '' )
-        self.addParameter( self._defaultParameters, 'cmsswVersion' , os.getenv( "CMSSW_VERSION" )                                        , 'auto from environment' )
-        self.addParameter( self._defaultParameters, 'formerVersion', False                                                               , '' )
-        self.addParameter( self._defaultParameters, 'relVal'       , 'RelValTTbar'                                                       , '' )
-        self.addParameter( self._defaultParameters, 'dataTier'     , 'GEN-SIM-RECO'                                                      , '' )
-        self.addParameter( self._defaultParameters, 'condition'    , 'startup'                                                           , '' )
-        self.addParameter( self._defaultParameters, 'globalTag'    , autoCond[ self.getDefaultParameters()[ 'condition' ].value ][ : -5 ], 'auto from \'condition\'' )
-        self.addParameter( self._defaultParameters, 'maxVersions'  , 3                                                                   , '' )
-        self.addParameter( self._defaultParameters, 'skipFiles'    , 0                                                                   , '' )
-        self.addParameter( self._defaultParameters, 'numberOfFiles', -1                                                                  , 'all' )
-        self.addParameter( self._defaultParameters, 'debug'        , False                                                               , '' )
-        self._parameters = copy.deepcopy( self._defaultParameters )
-        self._comment = ""
-
-    def __call__( self
-                , useDAS        = None
-                , cmsswVersion  = None
-                , formerVersion = None
-                , relVal        = None
-                , dataTier      = None
-                , condition     = None
-                , globalTag     = None
-                , maxVersions   = None
-                , skipFiles     = None
-                , numberOfFiles = None
-                , debug         = None
-                ):
-        if useDAS is None:
-            useDAS = self.getDefaultParameters()[ 'useDAS' ].value
-        if cmsswVersion is None:
-            cmsswVersion = self.getDefaultParameters()[ 'cmsswVersion' ].value
-        if formerVersion is None:
-            formerVersion = self.getDefaultParameters()[ 'formerVersion' ].value
-        if relVal is None:
-            relVal = self.getDefaultParameters()[ 'relVal' ].value
-        if dataTier is None:
-            dataTier = self.getDefaultParameters()[ 'dataTier' ].value
-        if condition is None:
-            condition = self.getDefaultParameters()[ 'condition' ].value
-        if globalTag is None:
-            globalTag = autoCond[ condition ][ : -5 ] # auto from 'condition'
-        if maxVersions is None:
-            maxVersions = self.getDefaultParameters()[ 'maxVersions' ].value
-        if skipFiles is None:
-            skipFiles = self.getDefaultParameters()[ 'skipFiles' ].value
-        if numberOfFiles is None:
-            numberOfFiles = self.getDefaultParameters()[ 'numberOfFiles' ].value
-        if debug is None:
-            debug = self.getDefaultParameters()[ 'debug' ].value
-        self.setParameter( 'useDAS'       , useDAS )
-        self.setParameter( 'cmsswVersion' , cmsswVersion )
-        self.setParameter( 'formerVersion', formerVersion )
-        self.setParameter( 'relVal'       , relVal )
-        self.setParameter( 'dataTier'     , dataTier )
-        self.setParameter( 'condition'    , condition )
-        self.setParameter( 'globalTag'    , globalTag )
-        self.setParameter( 'maxVersions'  , maxVersions )
-        self.setParameter( 'skipFiles'    , skipFiles )
-        self.setParameter( 'numberOfFiles', numberOfFiles )
-        self.setParameter( 'debug'        , debug )
-        return self.apply()
-
-    def messageEmptyList( self ):
-        print '%s DEBUG: Empty file list returned'%( self._label )
-        print '    This might be overwritten by providing input files explicitly to the source module in the main configuration file.'
-
-    def apply( self ):
-        useDAS        = self._parameters[ 'useDAS'        ].value
-        cmsswVersion  = self._parameters[ 'cmsswVersion'  ].value
-        formerVersion = self._parameters[ 'formerVersion' ].value
-        relVal        = self._parameters[ 'relVal'        ].value
-        dataTier      = self._parameters[ 'dataTier'      ].value
-        condition     = self._parameters[ 'condition'     ].value # only used for GT determination in initialization, if GT not explicitly given
-        globalTag     = self._parameters[ 'globalTag'     ].value
-        maxVersions   = self._parameters[ 'maxVersions'   ].value
-        skipFiles     = self._parameters[ 'skipFiles'     ].value
-        numberOfFiles = self._parameters[ 'numberOfFiles' ].value
-        debug         = self._parameters[ 'debug'         ].value
-
-        filePaths = []
-
-        # Determine corresponding CMSSW version for RelVals
-        preId      = '_pre'
-        patchId    = '_patch'    # patch releases
-        hltPatchId = '_hltpatch' # HLT patch releases
-        dqmPatchId = '_dqmpatch' # DQM patch releases
-        slhcId     = '_SLHC'     # SLHC releases
-        rootId     = '_root'     # ROOT test releases
-        ibId       = '_X_'       # IBs
-        if patchId in cmsswVersion:
-            cmsswVersion = cmsswVersion.split( patchId )[ 0 ]
-        elif hltPatchId in cmsswVersion:
-            cmsswVersion = cmsswVersion.split( hltPatchId )[ 0 ]
-        elif dqmPatchId in cmsswVersion:
-            cmsswVersion = cmsswVersion.split( dqmPatchId )[ 0 ]
-        elif rootId in cmsswVersion:
-            cmsswVersion = cmsswVersion.split( rootId )[ 0 ]
-        elif slhcId in cmsswVersion:
-            cmsswVersion = cmsswVersion.split( slhcId )[ 0 ]
-        elif ibId in cmsswVersion or formerVersion:
-            outputTuple = Popen( [ 'scram', 'l -c CMSSW' ], stdout = PIPE, stderr = PIPE ).communicate()
-            if len( outputTuple[ 1 ] ) != 0:
-                print '%s INFO : SCRAM error'%( self._label )
-                if debug:
-                    print '    from trying to determine last valid releases before \'%s\''%( cmsswVersion )
-                    print
-                    print outputTuple[ 1 ]
-                    print
-                    self.messageEmptyList()
-                return filePaths
-            versions = { 'last'      :''
-                       , 'lastToLast':''
-                       }
-            for line in outputTuple[ 0 ].splitlines():
-                version = line.split()[ 1 ]
-                if cmsswVersion.split( ibId )[ 0 ] in version or cmsswVersion.rpartition( '_' )[ 0 ] in version:
-                    if not ( patchId in version or hltPatchId in version or dqmPatchId in version or slhcId in version or ibId in version or rootId in version ):
-                        versions[ 'lastToLast' ] = versions[ 'last' ]
-                        versions[ 'last' ]       = version
-                        if version == cmsswVersion:
-                            break
-            # FIXME: ordering of output problematic ('XYZ_pre10' before 'XYZ_pre2', no "formerVersion" for 'XYZ_pre1')
-            if formerVersion:
-                # Don't use pre-releases as "former version" for other releases than CMSSW_X_Y_0
-                if preId in versions[ 'lastToLast' ] and not preId in versions[ 'last' ] and not versions[ 'last' ].endswith( '_0' ):
-                    versions[ 'lastToLast' ] = versions[ 'lastToLast' ].split( preId )[ 0 ] # works only, if 'CMSSW_X_Y_0' esists ;-)
-                # Use pre-release as "former version" for CMSSW_X_Y_0
-                elif versions[ 'last' ].endswith( '_0' ) and not ( preId in versions[ 'lastToLast' ] and versions[ 'lastToLast' ].startswith( versions[ 'last' ] ) ):
-                    versions[ 'lastToLast' ] = ''
-                    for line in outputTuple[ 0 ].splitlines():
-                        version      = line.split()[ 1 ]
-                        versionParts = version.partition( preId )
-                        if versionParts[ 0 ] == versions[ 'last' ] and versionParts[ 1 ] == preId:
-                            versions[ 'lastToLast' ] = version
-                        elif versions[ 'lastToLast' ] != '':
-                            break
-                # Don't use CMSSW_X_Y_0 as "former version" for pre-releases
-                elif preId in versions[ 'last' ] and not preId in versions[ 'lastToLast' ] and versions[ 'lastToLast' ].endswith( '_0' ):
-                    versions[ 'lastToLast' ] = '' # no alternative :-(
-                cmsswVersion = versions[ 'lastToLast' ]
-            else:
-                cmsswVersion = versions[ 'last' ]
-
-        # Debugging output
-        if debug:
-            print '%s DEBUG: Called with...'%( self._label )
-            for key in self._parameters.keys():
-               print '    %s:\t'%( key ),
-               print self._parameters[ key ].value,
-               if self._parameters[ key ].value is self.getDefaultParameters()[ key ].value:
-                   print ' (default)'
-               else:
-                   print
-               if key == 'cmsswVersion' and cmsswVersion != self._parameters[ key ].value:
-                   if formerVersion:
-                       print '    ==> modified to last to last valid release %s (s. \'formerVersion\' parameter)'%( cmsswVersion )
-                   else:
-                       print '    ==> modified to last valid release %s'%( cmsswVersion )
-
-        # Check domain
-        domain = socket.getfqdn().split( '.' )
-        domainSE = ''
-        if len( domain ) == 0:
-            print '%s INFO : Cannot determine domain of this computer'%( self._label )
-            if debug:
-                self.messageEmptyList()
-            return filePaths
-        elif os.uname()[0] == "Darwin":
-            print '%s INFO : Running on MacOSX without direct access to RelVal files.'%( self._label )
-            if debug:
-                self.messageEmptyList()
-            return filePaths
-        elif len( domain ) == 1:
-            print '%s INFO : Running on local host \'%s\' without direct access to RelVal files'%( self._label, domain[ 0 ] )
-            if debug:
-                self.messageEmptyList()
-            return filePaths
-        if not ( ( domain[ -2 ] == 'cern' and domain[ -1 ] == 'ch' ) or ( domain[ -2 ] == 'fnal' and domain[ -1 ] == 'gov' ) ):
-            print '%s INFO : Running on site \'%s.%s\' without direct access to RelVal files'%( self._label, domain[ -2 ], domain[ -1 ] )
-            if debug:
-                self.messageEmptyList()
-            return filePaths
-        if domain[ -2 ] == 'cern':
-            domainSE = 'T2_CH_CERN'
-        elif domain[ -2 ] == 'fnal':
-            domainSE = 'T1_US_FNAL_MSS'
-        if debug:
-            print '%s DEBUG: Running at site \'%s.%s\''%( self._label, domain[ -2 ], domain[ -1 ] )
-            print '%s DEBUG: Looking for SE \'%s\''%( self._label, domainSE )
-
-        # Find files
-        validVersion = 0
-        dataset    = ''
-        datasetAll = '/%s/%s-%s-v*/%s'%( relVal, cmsswVersion, globalTag, dataTier )
-        if useDAS:
-            if debug:
-                print '%s DEBUG: Using DAS query'%( self._label )
-            dasLimit = numberOfFiles
-            if dasLimit <= 0:
-                dasLimit += 1
-            for version in range( maxVersions, 0, -1 ):
-                filePaths    = []
-                filePathsTmp = []
-                fileCount    = 0
-                dataset = '/%s/%s-%s-v%i/%s'%( relVal, cmsswVersion, globalTag, version, dataTier )
-                dasQuery = 'file dataset=%s | grep file.name'%( dataset )
-                if debug:
-                    print '%s DEBUG: Querying dataset \'%s\' with'%( self._label, dataset )
-                    print '    \'%s\''%( dasQuery )
-                # partially stolen from das_client.py for option '--format=plain', needs filter ("grep") in the query
-                dasData     = das_client.get_data( 'https://cmsweb.cern.ch', dasQuery, 0, dasLimit, False )
-                jsondict    = json.loads( dasData )
-                if debug:
-                    print '%s DEBUG: Received DAS data:'%( self._label )
-                    print '    \'%s\''%( dasData )
-                    print '%s DEBUG: Determined JSON dictionary:'%( self._label )
-                    print '    \'%s\''%( jsondict )
-                if jsondict[ 'status' ] != 'ok':
-                    print 'There was a problem while querying DAS with query \'%s\'. Server reply was:\n %s' % (dasQuery, dasData)
-                    exit( 1 )
-                mongo_query = jsondict[ 'mongo_query' ]
-                filters     = mongo_query[ 'filters' ]
-                data        = jsondict[ 'data' ]
-                if debug:
-                    print '%s DEBUG: Query in JSON dictionary:'%( self._label )
-                    print '    \'%s\''%( mongo_query )
-                    print '%s DEBUG: Filters in query:'%( self._label )
-                    print '    \'%s\''%( filters )
-                    print '%s DEBUG: Data in JSON dictionary:'%( self._label )
-                    print '    \'%s\''%( data )
-                for row in data:
-                    filePath = [ r for r in das_client.get_value( row, filters ) ][ 0 ]
-                    if debug:
-                        print '%s DEBUG: Testing file entry \'%s\''%( self._label, filePath )
-                    if len( filePath ) > 0:
-                        if validVersion != version:
-                            dasTest         = das_client.get_data( 'https://cmsweb.cern.ch', 'site dataset=%s | grep site.name'%( dataset ), 0, 999, False )
-                            jsontestdict    = json.loads( dasTest )
-                            mongo_testquery = jsontestdict[ 'mongo_query' ]
-                            testfilters = mongo_testquery[ 'filters' ]
-                            testdata    = jsontestdict[ 'data' ]
-                            if debug:
-                                print '%s DEBUG: Received DAS data (site test):'%( self._label )
-                                print '    \'%s\''%( dasTest )
-                                print '%s DEBUG: Determined JSON dictionary (site test):'%( self._label )
-                                print '    \'%s\''%( jsontestdict )
-                                print '%s DEBUG: Query in JSON dictionary (site test):'%( self._label )
-                                print '    \'%s\''%( mongo_testquery )
-                                print '%s DEBUG: Filters in query (site test):'%( self._label )
-                                print '    \'%s\''%( testfilters )
-                                print '%s DEBUG: Data in JSON dictionary (site test):'%( self._label )
-                                print '    \'%s\''%( testdata )
-                            foundSE = False
-                            for testrow in testdata:
-                                siteName = [ tr for tr in das_client.get_value( testrow, testfilters ) ][ 0 ]
-                                if siteName == domainSE:
-                                    foundSE = True
-                                    break
-                            if not foundSE:
-                                if debug:
-                                    print '%s DEBUG: Possible version \'v%s\' not available on SE \'%s\''%( self._label, version, domainSE )
-                                break
-                            validVersion = version
-                            if debug:
-                                print '%s DEBUG: Valid version set to \'v%i\''%( self._label, validVersion )
-                        if numberOfFiles == 0:
-                            break
-                        # protect from double entries ( 'unique' flag in query does not work here)
-                        if not filePath in filePathsTmp:
-                            filePathsTmp.append( filePath )
-                            if debug:
-                                print '%s DEBUG: File \'%s\' found'%( self._label, filePath )
-                            fileCount += 1
-                            # needed, since and "limit" overrides "idx" in 'get_data' (==> "idx" set to '0' rather than "skipFiles")
-                            if fileCount > skipFiles:
-                                filePaths.append( filePath )
-                        elif debug:
-                            print '%s DEBUG: File \'%s\' found again'%( self._label, filePath )
-                if validVersion > 0:
-                    if numberOfFiles == 0 and debug:
-                        print '%s DEBUG: No files requested'%( self._label )
-                    break
-        else:
-            if debug:
-                print '%s DEBUG: Using DBS query'%( self._label )
-            for version in range( maxVersions, 0, -1 ):
-                filePaths = []
-                fileCount = 0
-                dataset = '/%s/%s-%s-v%i/%s'%( relVal, cmsswVersion, globalTag, version, dataTier )
-                dbsQuery = 'find file where dataset = %s'%( dataset )
-                if debug:
-                    print '%s DEBUG: Querying dataset \'%s\' with'%( self._label, dataset )
-                    print '    \'%s\''%( dbsQuery )
-                foundSE = False
-                for line in os.popen( 'dbs search --query="%s"'%( dbsQuery ) ):
-                    if line.find( '.root' ) != -1:
-                        if validVersion != version:
-                            if not foundSE:
-                                dbsSiteQuery = 'find dataset where dataset = %s and site = %s'%( dataset, domainSE )
-                                if debug:
-                                    print '%s DEBUG: Querying site \'%s\' with'%( self._label, domainSE )
-                                    print '    \'%s\''%( dbsSiteQuery )
-                                for lineSite in os.popen( 'dbs search --query="%s"'%( dbsSiteQuery ) ):
-                                    if lineSite.find( dataset ) != -1:
-                                        foundSE = True
-                                        break
-                            if not foundSE:
-                                if debug:
-                                    print '%s DEBUG: Possible version \'v%s\' not available on SE \'%s\''%( self._label, version, domainSE )
-                                break
-                            validVersion = version
-                            if debug:
-                                print '%s DEBUG: Valid version set to \'v%i\''%( self._label, validVersion )
-                        if numberOfFiles == 0:
-                            break
-                        filePath = line.replace( '\n', '' )
-                        if debug:
-                            print '%s DEBUG: File \'%s\' found'%( self._label, filePath )
-                        fileCount += 1
-                        if fileCount > skipFiles:
-                            filePaths.append( filePath )
-                        if not numberOfFiles < 0:
-                            if numberOfFiles <= len( filePaths ):
-                                break
-                if validVersion > 0:
-                    if numberOfFiles == 0 and debug:
-                        print '%s DEBUG: No files requested'%( self._label )
-                    break
-
-        # Check output and return
-        if validVersion == 0:
-            print '%s INFO : No RelVal file(s) found at all in datasets \'%s*\' on SE \'%s\''%( self._label, datasetAll, domainSE )
-            if debug:
-                self.messageEmptyList()
-        elif len( filePaths ) == 0:
-            print '%s INFO : No RelVal file(s) picked up in dataset \'%s\''%( self._label, dataset )
-            if debug:
-                self.messageEmptyList()
-        elif len( filePaths ) < numberOfFiles:
-            print '%s INFO : Only %i RelVal file(s) instead of %i picked up in dataset \'%s\''%( self._label, len( filePaths ), numberOfFiles, dataset )
-
-        if debug:
-            print '%s DEBUG: returning %i file(s):\n%s'%( self._label, len( filePaths ), filePaths )
-        return filePaths
-
-pickRelValInputFiles = PickRelValInputFiles()
diff --git a/PhysicsTools/PatAlgos/python/tools/coreTools.py b/PhysicsTools/PatAlgos/python/tools/coreTools.py
deleted file mode 100644
index 9c02d89..0000000
--- a/PhysicsTools/PatAlgos/python/tools/coreTools.py
+++ /dev/null
@@ -1,545 +0,0 @@
-from FWCore.GuiBrowsers.ConfigToolBase import *
-
-from PhysicsTools.PatAlgos.tools.helpers import *
-
-class RestrictInputToAOD(ConfigToolBase):
-
-    """ Remove pat object production steps which rely on RECO event
-    content
-    """
-    _label='restrictInputToAOD'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'names',['All'], "list of collection names; supported are 'Photons', 'Electrons',, 'Muons', 'Taus', 'Jets', 'METs', 'All'", allowedValues=['Photons','Electrons', 'Muons', 'Taus', 'Jets', 'METs', 'All'])
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 names     = None) :
-        if  names is None:
-            names=self._defaultParameters['names'].value
-        self.setParameter('names',names)
-        self.apply(process)
-
-    def toolCode(self, process):
-        names=self._parameters['names'].value
-        for obj in range(len(names)):
-            print "---------------------------------------------------------------------"
-            print "WARNING: the following additional information can only be used on "
-            print "         RECO format:"
-            if( names[obj] == 'Photons' or names[obj] == 'All' ):
-                print "          * nothing needs to be done for Photons"
-            if( names[obj] == 'Electrons' or names[obj] == 'All' ):
-                print "          * nothing needs to be done for Electrons"
-            if( names[obj] == 'Muons' or names[obj] == 'All' ):
-                print "          * nothing needs to be done for Muons"
-            if( names[obj] == 'Taus' or names[obj] == 'All' ):
-                print "          * nothing needs to be done for Taus"
-            if( names[obj] == 'Jets' or names[obj] == 'All' ):
-                print "          * nothing needs to be done for Jets"
-            if( names[obj] == 'METs' or names[obj] == 'All' ):
-                print "          * nothing needs to be done for METs"
-        print "---------------------------------------------------------------------"
-
-restrictInputToAOD=RestrictInputToAOD()
-
-
-class RunOnData(ConfigToolBase):
-
-    """ Remove monte carlo matching from a given collection or all PAT
-    candidate collections and adapt the JEC's:
-    """
-    _label='runOnData'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'names',['All'], "collection name; supported are 'Photons', 'Electrons','Muons', 'Taus', 'Jets', 'METs', 'All', 'PFAll', 'PFElectrons','PFTaus','PFMuons'", allowedValues=['Photons', 'Electrons','Muons', 'Taus', 'Jets', 'METs', 'All', 'PFAll', 'PFElectrons','PFTaus','PFMuons'])
-        self.addParameter(self._defaultParameters,'postfix',"", "postfix of default sequence")
-        self.addParameter(self._defaultParameters,'outputModules',['out'], "names of all output modules specified to be adapted (default is ['out'])")
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 names           = None,
-                 postfix         = None,
-                 outputInProcess = None,
-                 outputModules   = None) :
-        ## stop processing if 'outputInProcess' exists and show the new alternative
-        if  not outputInProcess is None:
-            depricatedOptionOutputInProcess(self)
-        if  names is None:
-            names=self._defaultParameters['names'].value
-        if  postfix  is None:
-            postfix=self._defaultParameters['postfix'].value
-        if  outputModules is None:
-            outputModules=self._defaultParameters['outputModules'].value
-        self.setParameter('names',names)
-        self.setParameter('postfix',postfix)
-        self.setParameter('outputModules',outputModules)
-        self.apply(process)
-
-    def toolCode(self, process):
-        names=self._parameters['names'].value
-        postfix=self._parameters['postfix'].value
-        outputModules=self._parameters['outputModules'].value
-
-        print '******************* RunOnData *******************'
-        removeMCMatching(process, names=names, postfix=postfix, outputModules=outputModules)
-        for mod in getattr(process,'patDefaultSequence'+postfix).moduleNames():
-            if mod.startswith('patJetCorrFactors'):
-                prefix = getattr(process, mod).payload.pythonValue().replace("'","")
-                if 'L3Absolute' in getattr(process,mod).levels:
-                    if not 'L2L3Residual' in getattr(process,mod).levels:
-                        getattr(process,mod).levels.insert(getattr(process,mod).levels.index('L3Absolute')+1, 'L2L3Residual')
-                        print 'adding L2L3Residual JEC for:', getattr(process,mod).label_()
-                if hasattr(process, prefix+'CombinedCorrector'+postfix):
-                    if prefix+'L3Absolute' in getattr(process,prefix+'CombinedCorrector'+postfix).correctors:
-                        if not prefix+'L2L3Residual' in getattr(process,prefix+'CombinedCorrector'+postfix).correctors:
-                            idx = getattr(process,prefix+'CombinedCorrector'+postfix).correctors.index(prefix+'L3Absolute')+1
-                            getattr(process,prefix+'CombinedCorrector'+postfix).correctors.insert(idx, prefix+'L2L3Residual')
-                            print 'adding L2L3Residual for TypeI MET correction:', getattr(process,prefix+'CombinedCorrector'+postfix).label_()
-
-runOnData=RunOnData()
-
-
-class RemoveMCMatching(ConfigToolBase):
-
-    """ Remove monte carlo matching from a given collection or all PAT
-    candidate collections:
-    """
-    _label='removeMCMatching'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'names',['All'], "collection name; supported are 'Photons', 'Electrons','Muons', 'Taus', 'Jets', 'METs', 'All', 'PFAll', 'PFElectrons','PFTaus','PFMuons'", allowedValues=['Photons', 'Electrons','Muons', 'Taus', 'Jets', 'METs', 'All', 'PFAll', 'PFElectrons','PFTaus','PFMuons'])
-        self.addParameter(self._defaultParameters,'postfix',"", "postfix of default sequence")
-        self.addParameter(self._defaultParameters,'outputInProcess',True, "indicates whether the output of the pat tuple should be made persistent or not (legacy)")
-        self.addParameter(self._defaultParameters,'outputModules',['out'], "names of all output modules specified to be adapted (default is ['out'])")
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 names           = None,
-                 postfix         = None,
-                 outputInProcess = None,
-                 outputModules   = None) :
-        ## stop processing if 'outputInProcess' exists and show the new alternative
-        if  not outputInProcess is None:
-            depricatedOptionOutputInProcess(self)
-        else:
-            outputInProcess=self._parameters['outputInProcess'].value
-        if  names is None:
-            names=self._defaultParameters['names'].value
-        if postfix  is None:
-            postfix=self._defaultParameters['postfix'].value
-        if  outputModules is None:
-            outputModules=self._defaultParameters['outputModules'].value
-        self.setParameter('names',names)
-        self.setParameter('postfix',postfix)
-        self.setParameter('outputInProcess', outputInProcess)
-        self.setParameter('outputModules',outputModules)
-        self.apply(process)
-
-    def toolCode(self, process):
-        names=self._parameters['names'].value
-        postfix=self._parameters['postfix'].value
-        outputInProcess=self._parameters['outputInProcess'].value
-        outputModules=self._parameters['outputModules'].value
-
-        if not outputInProcess:
-            outputModules=['']
-        
-        print "************** MC dependence removal ************"
-        for obj in range(len(names)):
-            if( names[obj] == 'Photons'   or names[obj] == 'All' ):
-                print "removing MC dependencies for photons"
-                _removeMCMatchingForPATObject(process, 'photonMatch', 'patPhotons', postfix)
-            if( names[obj] == 'Electrons' or names[obj] == 'All' ):
-                print "removing MC dependencies for electrons"
-                _removeMCMatchingForPATObject(process, 'electronMatch', 'patElectrons', postfix)
-            if( names[obj] == 'Muons'     or names[obj] == 'All' ):
-                print "removing MC dependencies for muons"
-                _removeMCMatchingForPATObject(process, 'muonMatch', 'patMuons', postfix)
-            if( names[obj] == 'Taus'      or names[obj] == 'All' ):
-                print "removing MC dependencies for taus"
-                _removeMCMatchingForPATObject(process, 'tauMatch', 'patTaus', postfix)
-                ## remove mc extra modules for taus
-                for mod in ['tauGenJets','tauGenJetsSelectorAllHadrons','tauGenJetMatch']:
-                    if hasattr(process,mod+postfix):
-                        getattr(process,'patDefaultSequence'+postfix).remove(getattr(process,mod+postfix))
-                ## remove mc extra configs for taus
-                tauProducer = getattr(process,'patTaus'+postfix)
-                tauProducer.addGenJetMatch   = False
-                tauProducer.embedGenJetMatch = False
-                tauProducer.genJetMatch      = ''
-            if( names[obj] == 'Jets'      or names[obj] == 'All' ):
-                print "removing MC dependencies for jets"
-                ## there may be multiple jet collection, therefore all jet collections
-                ## in patDefaultSequence+postfix are threated here
-                jetPostfixes = []
-                for mod in getattr(process,'patDefaultSequence'+postfix).moduleNames():
-                    if mod.startswith('patJets'):
-                        jetPostfixes.append(getattr(process, mod).label_().replace("patJets",""))
-                for pfix in jetPostfixes:
-                    ## remove mc extra modules for jets
-                    for mod in ['patJetPartonMatch','patJetGenJetMatch','patJetFlavourId','patJetPartons','patJetPartonAssociation','patJetFlavourAssociation']:
-                        if hasattr(process,mod+pfix):
-                            getattr(process,'patDefaultSequence'+postfix).remove(getattr(process,mod+pfix))
-                    ## remove mc extra configs for jets
-                    jetProducer = getattr(process, jetCollectionString()+pfix)
-                    jetProducer.addGenPartonMatch   = False
-                    jetProducer.embedGenPartonMatch = False
-                    jetProducer.genPartonMatch      = ''
-                    jetProducer.addGenJetMatch      = False
-                    jetProducer.genJetMatch         = ''
-                    jetProducer.getJetMCFlavour     = False
-                    jetProducer.JetPartonMapSource  = ''
-                ## adjust output
-                for outMod in outputModules:
-                    if hasattr(process,outMod):
-                        getattr(process,outMod).outputCommands.append("drop *_selectedPatJets*_genJets_*")
-                    else:
-                        raise KeyError, "process has no OutModule named", outMod
-
-            if( names[obj] == 'METs'      or names[obj] == 'All' ):
-                ## remove mc extra configs for jets
-                metProducer = getattr(process, 'patMETs'+postfix)
-                metProducer.addGenMET           = False
-                metProducer.genMETSource        = ''
-
-removeMCMatching=RemoveMCMatching()
-
-def _removeMCMatchingForPATObject(process, matcherName, producerName, postfix=""):
-    ## remove mcMatcher from the default sequence
-    objectMatcher = getattr(process, matcherName+postfix)
-    if (producerName=='pfPatMuons'or producerName=='pfPatTaus'):
-        #no idea what this should do: there is no other occurance of 'PFPATafterPAT' in CMSSW other than here...
-        getattr(process,"PFPATafterPAT"+postfix).remove(objectMatcher)
-    if (producerName=='patMuons'or producerName=='patTaus'or
-        producerName=='patPhotons' or producerName=='patElectrons'):
-        getattr(process,"patDefaultSequence"+postfix).remove(objectMatcher)
-    ## straighten photonProducer
-    objectProducer = getattr(process, producerName+postfix)
-    objectProducer.addGenMatch      = False
-    objectProducer.embedGenMatch    = False
-    objectProducer.genParticleMatch = ''
-
-
-class RemoveAllPATObjectsBut(ConfigToolBase):
-
-    """ Remove all PAT objects from the default sequence but a specific one
-    """
-    _label='removeAllPATObjectsBut'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'names',self._defaultValue, "list of collection names; supported are 'Photons', 'Electrons', 'Muons', 'Taus', 'Jets', 'METs'", Type=list, allowedValues=['Photons', 'Electrons', 'Muons', 'Taus', 'Jets', 'METs'])
-        self.addParameter(self._defaultParameters,'outputModules',['out'], "names of all output modules specified to be adapted (default is ['out'])")
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 names           = None,
-                 outputInProcess = None,
-                 outputModules   = None) :
-        ## stop processing if 'outputInProcess' exists and show the new alternative
-        if  not outputInProcess is None:
-            depricatedOptionOutputInProcess(self)
-        if  names is None:
-            names=self._defaultParameters['names'].value
-        if  outputModules is None:
-            outputModules=self._defaultParameters['outputModules'].value
-        self.setParameter('names',names)
-        self.setParameter('outputModules',outputModules)
-        self.apply(process)
-
-    def toolCode(self, process):
-        names=self._parameters['names'].value
-        outputModules=self._parameters['outputModules'].value
-
-        removeTheseObjectCollections = ['Photons', 'Electrons', 'Muons', 'Taus', 'Jets', 'METs']
-        for obj in range(len(names)):
-            removeTheseObjectCollections.remove(names[obj])
-        removeSpecificPATObjects(process, removeTheseObjectCollections, outputModules = outputModules)
-
-removeAllPATObjectsBut=RemoveAllPATObjectsBut()
-
-
-class RemoveSpecificPATObjects(ConfigToolBase):
-
-    """ Remove a specific PAT object from the default sequence
-    """
-    _label='removeSpecificPATObjects'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'names',self._defaultValue, "list of collection names; supported are 'Photons', 'Electrons', 'Muons', 'Taus', 'Jets', 'METs'", Type=list, allowedValues=['Photons', 'Electrons', 'Muons', 'Taus', 'Jets', 'METs'])
-        self.addParameter(self._defaultParameters,'outputModules',['out'], "names of all output modules specified to be adapted (default is ['out'])")
-        self.addParameter(self._defaultParameters,'postfix',"", "postfix of default sequence")
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 names           = None,
-                 outputInProcess = None,
-                 postfix         = None,
-                 outputModules   = None) :
-        ## stop processing if 'outputInProcess' exists and show the new alternative
-        if  not outputInProcess is None:
-            depricatedOptionOutputInProcess(self)
-        if  names is None:
-            names=self._defaultParameters['names'].value
-        if  outputModules is None:
-            outputModules=self._defaultParameters['outputModules'].value
-        if postfix  is None:
-            postfix=self._defaultParameters['postfix'].value
-        self.setParameter('names',names)
-        self.setParameter('outputModules',outputModules)
-        self.setParameter('postfix',postfix)
-        self.apply(process)
-
-    def toolCode(self, process):
-        names=self._parameters['names'].value
-        outputModules=self._parameters['outputModules'].value
-        postfix=self._parameters['postfix'].value
-
-        ## remove pre object production steps from the default sequence
-        for obj in range(len(names)):
-            if( names[obj] == 'Photons' ):
-                removeIfInSequence(process, 'patPhotonIsolation', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'photonMatch', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'patPhotons', "patDefaultSequence", postfix)
-            if( names[obj] == 'Electrons' ):
-                removeIfInSequence(process, 'patElectronId', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'patElectronIsolation', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'electronMatch', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'patElectrons', "patDefaultSequence", postfix)
-            if( names[obj] == 'Muons' ):
-                removeIfInSequence(process, 'muonMatch', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'patMuons', "patDefaultSequence", postfix)
-            if( names[obj] == 'Taus' ):
-                removeIfInSequence(process, 'patPFCandidateIsoDepositSelection', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'patPFTauIsolation', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'tauMatch', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'tauGenJets', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'tauGenJetsSelectorAllHadrons', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'tauGenJetMatch', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'patTaus', "patDefaultSequence", postfix)
-            if( names[obj] == 'Jets' ):
-                removeIfInSequence(process, 'patJetCharge', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'patJetCorrections', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'patJetPartonMatch', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'patJetGenJetMatch', "patDefaultSequence", postfix)
-                removeIfInSequence(process, 'patJetFlavourId', "patDefaultSequence", postfix)
-            if( names[obj] == 'METs' ):
-                removeIfInSequence(process, 'patMETCorrections', "patDefaultSequence", postfix)
-
-            ## remove object production steps from the default sequence
-            if( names[obj] == 'METs' ):
-                process.patDefaultSequence.remove( getattr(process, 'pat'+names[obj]) )
-            else:
-                if( names[obj] == 'Jets' ):
-                    applyPostfix(process,"patDefaultSequence",postfix).remove(
-                        getattr(process, jetCollectionString()+postfix) )
-                    applyPostfix(process,"patDefaultSequence",postfix).remove(
-                        getattr(process, jetCollectionString('selected')+postfix) )
-                    applyPostfix(process,"patDefaultSequence",postfix).remove(
-                        getattr(process, jetCollectionString('count')+postfix) )
-                else:
-                    applyPostfix(process,"patDefaultSequence",postfix).remove(
-                        getattr(process, 'pat'+names[obj]+postfix) )
-                    applyPostfix(process,"patDefaultSequence",postfix).remove(
-                        getattr(process, 'selectedPat'+names[obj]+postfix) )
-                    applyPostfix(process,"patDefaultSequence",postfix).remove(
-                        getattr(process, 'countPat'+names[obj]+postfix) )
-            ## in the case of leptons, the lepton counter must be modified as well
-            if( names[obj] == 'Electrons' ):
-                print 'removed from lepton counter: electrons'
-                applyPostfix(process,"countPatLeptons",postfix).countElectrons = False
-            elif( names[obj] == 'Muons' ):
-                print 'removed from lepton counter: muons'
-                applyPostfix(process,"countPatLeptons",postfix).countMuons = False
-            elif( names[obj] == 'Taus' ):
-                print 'removed from lepton counter: taus'
-                applyPostfix(process,"countPatLeptons",postfix).countTaus = False
-            ## remove from summary
-            if( names[obj] == 'METs' ):
-                applyPostfix(process,"patCandidateSummary",postfix).candidates.remove(
-                    cms.InputTag('pat'+names[obj]+postfix) )
-            else:
-                if( names[obj] == 'Jets' ):
-                    applyPostfix(process,"patCandidateSummary",postfix).candidates.remove(
-                        cms.InputTag(jetCollectionString()+postfix) )
-                    applyPostfix(process,"selectedPatCandidateSummary",postfix).candidates.remove(
-                        cms.InputTag(jetCollectionString('selected')+postfix) )
-                    applyPostfix(process,"cleanPatCandidateSummary",postfix).candidates.remove(
-                        cms.InputTag(jetCollectionString('clean')+postfix) )
-                else:
-                    ## check whether module is in sequence or not
-                    result = [ m.label()[:-len(postfix)] for m in listModules( getattr(process,"patDefaultSequence"+postfix))]
-                    result.extend([ m.label()[:-len(postfix)] for m in listSequences( getattr(process,"patDefaultSequence"+postfix))]  )
-                    if applyPostfix(process,"patCandidateSummary",postfix) in result :
-                        applyPostfix(process,"patCandidateSummary",postfix).candidates.remove(
-                            cms.InputTag('pat'+names[obj]+postfix) )
-                    if applyPostfix(process,"selectedPatCandidateSummary",postfix) in result :
-                        applyPostfix(process,"selectedPatCandidateSummary",postfix).candidates.remove(
-                            cms.InputTag('selectedPat'+names[obj]+postfix) )
-                    if applyPostfix(process,"cleanPatCandidateSummary",postfix) in result :
-                        applyPostfix(process,"cleanPatCandidateSummary",postfix).candidates.remove(
-                            cms.InputTag('cleanPat'+names[obj]+postfix) )
-        ## remove cleaning for the moment; in principle only the removed object
-        ## could be taken out of the checkOverlaps PSet
-        if len(outputModules) > 0:
-            print "---------------------------------------------------------------------"
-            print "INFO   : some objects have been removed from the sequence. Switching "
-            print "         off PAT cross collection cleaning, as it might be of limited"
-            print "         sense now. If you still want to keep object collection cross"
-            print "         cleaning within PAT you need to run and configure it by hand"
-            removeCleaning(process,outputModules=outputModules,postfix=postfix)
-
-removeSpecificPATObjects=RemoveSpecificPATObjects()
-
-
-class RemoveCleaning(ConfigToolBase):
-
-    """ remove PAT cleaning from the default sequence:
-    """
-    _label='removeCleaning'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'outputModules',['out'], "names of all output modules specified to be adapted (default is ['out'])")
-        self.addParameter(self._defaultParameters,'postfix',"", "postfix of default sequence")
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 outputInProcess = None,
-                 postfix         = None,
-                 outputModules   = None) :
-        ## stop processing if 'outputInProcess' exists and show the new alternative
-        if  not outputInProcess is None:
-            depricatedOptionOutputInProcess(self)
-        if  outputModules is None:
-            outputModules=self._defaultParameters['outputModules'].value
-        if postfix  is None:
-            postfix=self._defaultParameters['postfix'].value
-
-        self.setParameter('outputModules',outputModules)
-        self.setParameter('postfix',postfix)
-
-        self.apply(process)
-
-    def toolCode(self, process):
-        outputModules=self._parameters['outputModules'].value
-        postfix=self._parameters['postfix'].value
-
-        ## adapt single object counters
-        for m in listModules(applyPostfix(process,"countPatCandidates",postfix)):
-            if hasattr(m, 'src'): m.src = m.src.value().replace('cleanPat','selectedPat')
-
-        ## adapt lepton counter
-        countLept = applyPostfix(process,"countPatLeptons",postfix)
-        countLept.electronSource = countLept.electronSource.value().replace('cleanPat','selectedPat')
-        countLept.muonSource = countLept.muonSource.value().replace('cleanPat','selectedPat')
-        countLept.tauSource = countLept.tauSource.value().replace('cleanPat','selectedPat')
-        for m in getattr(process, "cleanPatCandidates").moduleNames():
-            getattr(process, "patDefaultSequence"+postfix).remove(
-                applyPostfix(process,m,postfix)
-                )
-        if len(outputModules) > 0:
-            print "------------------------------------------------------------"
-            print "INFO   : cleaning has been removed. Switching output from"
-            print "         clean PAT candidates to selected PAT candidates."
-            ## add selected pat objects to the pat output
-            from PhysicsTools.PatAlgos.patEventContent_cff import patEventContentNoCleaning
-            for outMod in outputModules:
-                if hasattr(process,outMod):
-                    getattr(process,outMod).outputCommands = patEventContentNoCleaning
-                else:
-                    raise KeyError, "process has no OutModule named", outMod
-
-removeCleaning=RemoveCleaning()
-
-
-class AddCleaning(ConfigToolBase):
-
-    """ Add PAT cleaning from the default sequence
-    """
-    _label='addCleaning'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'outputModules',['out'], "names of all output modules specified to be adapted (default is ['out'])")
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 outputInProcess = None,
-                 outputModules   = None):
-        ## stop processing if 'outputInProcess' exists and show the new alternative
-        if  not outputInProcess is None:
-            depricatedOptionOutputInProcess(self)
-        if  outputModules is None:
-            outputModules=self._defaultParameters['outputModules'].value
-
-        self.setParameter('outputModules',outputModules)
-        self.apply(process)
-
-    def toolCode(self, process):
-        outputModules=self._parameters['outputModules'].value
-
-        ## adapt single object counters
-        process.patDefaultSequence.replace(process.countPatCandidates, process.cleanPatCandidates * process.countPatCandidates)
-        for m in listModules(process.countPatCandidates):
-            if hasattr(m, 'src'): m.src = m.src.value().replace('selectedPat','cleanPat')
-        ## adapt lepton counter
-        countLept = process.countPatLeptons
-        countLept.electronSource = countLept.electronSource.value().replace('selectedPat','cleanPat')
-        countLept.muonSource = countLept.muonSource.value().replace('selectedPat','cleanPat')
-        countLept.tauSource = countLept.tauSource.value().replace('selectedPat','cleanPat')
-        if len(outputModules) > 0:
-            print "------------------------------------------------------------"
-            print "INFO   : cleaning has been added. Switching output from  "
-            print "         selected PAT candidates to clean PAT candidates."
-            ## add clean layer1 objects to the pat output
-            from PhysicsTools.PatAlgos.patEventContent_cff import patEventContent
-            for outMod in outputModules:
-                if hasattr(process,outMod):
-                    getattr(process,outMod).outputCommands = patEventContent
-                else:
-                    raise KeyError, "process has no OutModule named", outMod
-
-addCleaning=AddCleaning()
-
-def depricatedOptionOutputInProcess(obj):
-    print "-------------------------------------------------------"
-    print " INFO: the option 'outputInProcess' will be deprecated "
-    print "       soon:", obj._label
-    print "       please use the option 'outputModules' now and   "
-    print "       specify the names of all needed OutModules in   "
-    print "       there (default: ['out'])"
-    print "-------------------------------------------------------"
-    #raise KeyError, "unsupported option 'outputInProcess' used in '"+obj._label+"'"
diff --git a/PhysicsTools/PatAlgos/python/tools/electronTools.py b/PhysicsTools/PatAlgos/python/tools/electronTools.py
deleted file mode 100644
index 642b30f..0000000
--- a/PhysicsTools/PatAlgos/python/tools/electronTools.py
+++ /dev/null
@@ -1,156 +0,0 @@
-from FWCore.GuiBrowsers.ConfigToolBase import *
-
-class AddElectronUserIsolation(ConfigToolBase):
-
-    """ add userIsolation to patElectron
-    """
-    _label='addElectronUserIsolation'    
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'isolationTypes',['All'],'List of predefined userIsolation types to be added; possible values are [\'Tracker\',\'Ecal\',\'Hcal\'] or just [\'All\']', allowedValues=['Tracker','Ecal','Hcal','All'])
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ''
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,isolationTypes=None) :
-        if  isolationTypes is None:
-            isolationTypes=self._defaultParameters['isolationTypes'].value 
-        self.setParameter('isolationTypes',isolationTypes)
-        self.apply(process) 
-        
-    def toolCode(self, process):                
-        isolationTypes=self._parameters['isolationTypes'].value
-
-        # includes to fix fastsim problems
-        from RecoEgamma.EgammaIsolationAlgos.eleIsoDeposits_cff import eleIsoDepositTk, eleIsoDepositEcalFromHits, eleIsoDepositHcalFromTowers
-        from RecoEgamma.EgammaIsolationAlgos.eleIsoFromDeposits_cff import eleIsoFromDepsTk, eleIsoFromDepsEcalFromHitsByCrystal, eleIsoFromDepsHcalFromTowers
-        
-        eleIsoDepositEcalFromHits.ExtractorPSet.barrelEcalHits = cms.InputTag("reducedEcalRecHitsEB")
-        eleIsoDepositEcalFromHits.ExtractorPSet.endcapEcalHits = cms.InputTag("reducedEcalRecHitsEE")
-        
-        # key to define the parameter sets
-        isolationKey=0
-        # add pre-requisits to the electron
-        for obj in range(len(isolationTypes)):
-            if ( isolationTypes[obj] == 'Tracker' or isolationTypes[obj] == 'All'):
-                print "adding predefined userIsolation to pat::Electron for Tracker"
-                print " -> to access this information call pat::Electron::userIsolation(pat::TrackIso) in your analysis code <-"
-                isolationKey=isolationKey+1
-                from PhysicsTools.PatAlgos.recoLayer0.electronIsolation_cff import patElectronTrackIsolation
-                process.patElectronTrackIsolation
-                process.patDefaultSequence.replace( process.patElectrons, process.patElectronTrackIsolation*process.patElectrons )
-                
-            if ( isolationTypes[obj] == 'Ecal'    or isolationTypes[obj] == 'All'):
-                print "adding predefined userIsolation to pat::Electron for Ecal"
-                print " -> to access this information call pat::Electron::userIsolation(pat::EcalIso ) in your analysis code <-"
-                isolationKey=isolationKey+10
-                from PhysicsTools.PatAlgos.recoLayer0.electronIsolation_cff import patElectronEcalIsolation
-                process.patElectronEcalIsolation            
-                process.patDefaultSequence.replace( process.patElectrons, process.patElectronEcalIsolation*process.patElectrons )
-                
-            if ( isolationTypes[obj] == 'Hcal'    or isolationTypes[obj] == 'All'):
-                print "adding predefined userIsolation to pat::Electron for Hcal"
-                print " -> to access this information call pat::Electron::userIsolation(pat::HcalIso ) in your analysis code <-"
-                isolationKey=isolationKey+100
-                from PhysicsTools.PatAlgos.recoLayer0.electronIsolation_cff import patElectronHcalIsolation            
-                process.patElectronHcalIsolation = patElectronHcalIsolation
-                process.patDefaultSequence.replace( process.patElectrons, process.patElectronHcalIsolation*process.patElectrons )  
-                
-        # do the corresponding replacements in the pat electron
-        if ( isolationKey ==   1 ):
-            # tracker
-            process.patElectrons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("eleIsoDepositTk"),
-            )
-            process.patElectrons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsTk"),
-                ),
-            )
-        if ( isolationKey ==  10 ):
-            # ecal
-            process.patElectrons.isoDeposits = cms.PSet(
-                ecal    = cms.InputTag("eleIsoDepositEcalFromHits"),
-            )
-            process.patElectrons.userIsolation = cms.PSet(
-                ecal = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsEcalFromHitsByCrystal"),
-                ),
-            )
-        if ( isolationKey == 100 ):
-            # hcal
-            process.patElectrons.isoDeposits = cms.PSet(
-                hcal    = cms.InputTag("eleIsoDepositHcalFromTowers"),
-            )
-            process.patElectrons.userIsolation = cms.PSet(
-                hcal = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsHcalFromTowers"),
-                ),
-            )
-        if ( isolationKey ==  11 ):
-            # ecal + tracker
-            process.patElectrons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("eleIsoDepositTk"),
-                ecal    = cms.InputTag("eleIsoDepositEcalFromHits"),
-            )
-            process.patElectrons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsTk"),
-                ),
-                ecal = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsEcalFromHitsByCrystal"),
-                ),
-            )
-        if ( isolationKey == 101 ):
-            # hcal + tracker
-            process.patElectrons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("eleIsoDepositTk"),
-                hcal    = cms.InputTag("eleIsoDepositHcalFromTowers"),
-            )
-            process.patElectrons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsTk"),
-                ),
-                hcal = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsHcalFromTowers"),
-                ),
-            )
-        if ( isolationKey == 110 ):
-            # hcal + ecal
-            process.patElectrons.isoDeposits = cms.PSet(
-                ecal    = cms.InputTag("eleIsoDepositEcalFromHits"),
-                hcal    = cms.InputTag("eleIsoDepositHcalFromTowers"),
-            )
-            process.patElectrons.userIsolation = cms.PSet(
-                ecal = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsEcalFromHitsByCrystal"),
-                ),
-                hcal = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsHcalFromTowers"),
-                ),
-            )
-        if ( isolationKey == 111 ):
-            # hcal + ecal + tracker 
-            process.patElectrons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("eleIsoDepositTk"),
-                ecal    = cms.InputTag("eleIsoDepositEcalFromHits"),
-                hcal    = cms.InputTag("eleIsoDepositHcalFromTowers"),
-            )
-            process.patElectrons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsTk"),
-                ),
-                ecal = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsEcalFromHitsByCrystal"),
-                ),
-                hcal = cms.PSet(
-                src = cms.InputTag("eleIsoFromDepsHcalFromTowers"),
-                ),
-            )
-
-
-addElectronUserIsolation=AddElectronUserIsolation()
diff --git a/PhysicsTools/PatAlgos/python/tools/heavyIonTools.py b/PhysicsTools/PatAlgos/python/tools/heavyIonTools.py
deleted file mode 100644
index 1f9aa78..0000000
--- a/PhysicsTools/PatAlgos/python/tools/heavyIonTools.py
+++ /dev/null
@@ -1,198 +0,0 @@
-from FWCore.GuiBrowsers.ConfigToolBase import *
-from PhysicsTools.PatAlgos.tools.helpers import *
-
-
-class ConfigureHeavyIons(ConfigToolBase):
-
-    """ Configure all defaults for heavy ions
-    """
-    _label='configureHeavyIons'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)        
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process):
-                
-        self.apply(process) 
-        
-    def toolCode(self, process):        
-        productionDefaults(process)
-        selectionDefaults(process)
-           
-configureHeavyIons=ConfigureHeavyIons()
-
-
-class ProductionDefaults(ConfigToolBase):
-
-    """ Configure all relevant layer1 candidates for heavy ions
-    """
-    _label='productionDefaults'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)        
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-    
-    def __call__(self,process):
-                
-        self.apply(process) 
-        
-    def toolCode(self, process):        
-        ## adapt jet defaults
-        patJets = getattr(process, jetCollectionString())
-        patJets.jetSource  = cms.InputTag("iterativeConePu5CaloJets")
-
-        jetCors  = getattr(process, 'patJetCorrFactors')
-        jetCors.jetSource = cms.InputTag("iterativeConePu5CaloJets")
-        jetCors.corrLevels = cms.PSet(L2Relative = cms.string("L2Relative_IC5Calo"),
-                                      L3Absolute = cms.string("L3Absolute_IC5Calo"),
-                                      L1Offset   = cms.string('none'),
-                                      L4EMF      = cms.string('none'),
-                                      L5Flavor   = cms.string('none'),
-                                      L6UE       = cms.string('none'),
-                                      L7Parton   = cms.string('none') 
-                                      )
-
-        partonMatch = getattr(process, 'patJetPartonMatch')
-        partonMatch.src = cms.InputTag("iterativeConePu5CaloJets")
-        partonMatch.matched = cms.InputTag("hiPartons")
-
-        jetMatch = getattr(process, 'patJetGenJetMatch')
-        jetMatch.src     = cms.InputTag("iterativeConePu5CaloJets")
-        jetMatch.matched = cms.InputTag("heavyIonCleanedGenJets")
-        
-        patJets.addBTagInfo         = False
-        patJets.addTagInfos         = False
-        patJets.addDiscriminators   = False
-        patJets.addAssociatedTracks = False
-        patJets.addJetCharge        = False
-        patJets.addJetID            = False
-        patJets.getJetMCFlavour     = False
-        patJets.addGenPartonMatch   = True
-        patJets.addGenJetMatch      = True
-        patJets.embedGenJetMatch    = True
-        patJets.embedGenPartonMatch   = True
-
-        ## adapt muon defaults
-        muonMatch = getattr(process, 'muonMatch')
-        muonMatch.matched = cms.InputTag("hiGenParticles")
-        patMuons  = getattr(process, 'patMuons')
-        patMuons.embedGenMatch = cms.bool(True)
-        process.patMuons.embedCaloMETMuonCorrs = cms.bool(False)
-        process.patMuons.embedTcMETMuonCorrs   = cms.bool(False)
-        process.patMuons.embedPFCandidate   = cms.bool(False)
-        process.patMuons.useParticleFlow    = cms.bool(False)
-        process.patMuons.addEfficiencies    = cms.bool(False)
-        process.patMuons.addResolutions     = cms.bool(False)
-        process.patMuons.pvSrc = cms.InputTag("hiSelectedVertex")
-        
-        ## adapt photon defaults
-        photonMatch = getattr(process, 'photonMatch')
-        photonMatch.matched = cms.InputTag("hiGenParticles")
-        patPhotons  = getattr(process, 'patPhotons')
-        patPhotons.addPhotonID   = cms.bool(True)
-        patPhotons.addGenMatch   = cms.bool(True)
-        patPhotons.embedGenMatch = cms.bool(True)
-        patPhotons.userData.userFloats.src  = cms.VInputTag(
-            cms.InputTag( "isoCC1"),cms.InputTag( "isoCC2"),cms.InputTag( "isoCC3"),cms.InputTag( "isoCC4"),cms.InputTag("isoCC5"),
-            cms.InputTag( "isoCR1"),cms.InputTag( "isoCR2"),cms.InputTag( "isoCR3"),cms.InputTag( "isoCR4"),cms.InputTag("isoCR5"),
-            cms.InputTag( "isoT11"),cms.InputTag( "isoT12"),cms.InputTag( "isoT13"),cms.InputTag( "isoT14"),  
-            cms.InputTag( "isoT21"),cms.InputTag( "isoT22"),cms.InputTag( "isoT23"),cms.InputTag( "isoT24"),  
-            cms.InputTag( "isoT31"),cms.InputTag( "isoT32"),cms.InputTag( "isoT33"),cms.InputTag( "isoT34"),  
-            cms.InputTag( "isoT41"),cms.InputTag( "isoT42"),cms.InputTag( "isoT43"),cms.InputTag( "isoT44"),  
-            cms.InputTag("isoDR11"),cms.InputTag("isoDR12"),cms.InputTag("isoDR13"),cms.InputTag("isoDR14"),  
-            cms.InputTag("isoDR21"),cms.InputTag("isoDR22"),cms.InputTag("isoDR23"),cms.InputTag("isoDR24"),  
-            cms.InputTag("isoDR31"),cms.InputTag("isoDR32"),cms.InputTag("isoDR33"),cms.InputTag("isoDR34"),  
-            cms.InputTag("isoDR41"),cms.InputTag("isoDR42"),cms.InputTag("isoDR43"),cms.InputTag("isoDR44")
-            )
-        patPhotons.photonIDSource = cms.InputTag("PhotonIDProd","PhotonCutBasedIDLoose")
-        del patPhotons.photonIDSources
-        
-productionDefaults=ProductionDefaults()
-
-
-class SelectionDefaults(ConfigToolBase):
-
-    """ Configure all relevant selected layer1 candidates for heavy ions
-    """
-    _label='selectionDefaults'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)        
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process):
-                
-        self.apply(process) 
-        
-    def toolCode(self, process):        
-        selectedJets = getattr(process, jetCollectionString('selected'))
-        selectedJets.cut = cms.string('pt > 20.')
-        selectedMuons = getattr(process, 'selectedPatMuons')
-        selectedMuons.cut = cms.string('pt > 0. & abs(eta) < 12.')
-        selectedPhotons = getattr(process, 'selectedPatPhotons')
-        selectedPhotons.cut = cms.string('pt > 0. & abs(eta) < 12.')
-        
-selectionDefaults=SelectionDefaults()
-
-
-class DisbaleMonteCarloDeps(ConfigToolBase):
-
-    """ Cut off all MC dependencies
-    """
-    _label='disableMonteCarloDeps'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)        
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process):
-                
-        self.apply(process) 
-        
-    def toolCode(self, process):
-        ## switch MC to false in heavyIon Producer
-        process.heavyIon.doMC = False
-        
-        ## remove MC matching from heavyIonJets
-        process.makeHeavyIonJets.remove(process.genPartons)
-        process.makeHeavyIonJets.remove(process.heavyIonCleanedGenJets)
-        process.makeHeavyIonJets.remove(process.hiPartons)
-        process.makeHeavyIonJets.remove(process.patJetGenJetMatch)
-        process.makeHeavyIonJets.remove(process.patJetPartonMatch)
-        
-        process.patJets.addGenPartonMatch   = False
-        process.patJets.embedGenPartonMatch = False
-        process.patJets.genPartonMatch      = ''
-        process.patJets.addGenJetMatch      = False
-        process.patJets.genJetMatch	      = ''
-        process.patJets.getJetMCFlavour     = False
-        process.patJets.JetPartonMapSource  = ''
-
-        ## remove MC matching from heavyIonMuons        
-        process.makeHeavyIonMuons.remove(process.muonMatch)
-        
-        process.patMuons.addGenMatch        = False
-        process.patMuons.embedGenMatch      = False
-        
-disableMonteCarloDeps=DisbaleMonteCarloDeps()       
diff --git a/PhysicsTools/PatAlgos/python/tools/helpers.py b/PhysicsTools/PatAlgos/python/tools/helpers.py
deleted file mode 100644
index 81e38f1..0000000
--- a/PhysicsTools/PatAlgos/python/tools/helpers.py
+++ /dev/null
@@ -1,345 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-## Helpers to perform some technically boring tasks like looking for all modules with a given parameter
-## and replacing that to a given value
-
-def applyPostfix(process, label, postfix):
-    ''' If a module is in patDefaultSequence use the cloned module.
-    Will crash if patDefaultSequence has not been cloned with 'postfix' beforehand'''
-    result = None
-    defaultLabels = __labelsInSequence(process, "patDefaultSequence", postfix)
-    if hasattr(process, "patPF2PATSequence"):
-        defaultLabels = __labelsInSequence(process, "patPF2PATSequence", postfix)
-    if label in defaultLabels and hasattr(process, label+postfix):
-        result = getattr(process, label+postfix)
-    elif hasattr(process, label):
-        print "WARNING: called applyPostfix for module/sequence %s which is not in patDefaultSequence%s!"%(label,postfix)
-        result = getattr(process, label)
-    return result
-
-def removeIfInSequence(process, target,  sequenceLabel, postfix=""):
-    labels = __labelsInSequence(process, sequenceLabel, postfix)
-    if target+postfix in labels:
-        getattr(process, sequenceLabel+postfix).remove(
-            getattr(process, target+postfix)
-            )
-
-def __labelsInSequence(process, sequenceLabel, postfix=""):
-    result = [ m.label()[:-len(postfix)] for m in listModules( getattr(process,sequenceLabel+postfix))]
-    result.extend([ m.label()[:-len(postfix)] for m in listSequences( getattr(process,sequenceLabel+postfix))]  )
-    if postfix == "":
-        result = [ m.label() for m in listModules( getattr(process,sequenceLabel+postfix))]
-        result.extend([ m.label() for m in listSequences( getattr(process,sequenceLabel+postfix))]  )
-    return result
-
-class MassSearchReplaceParamVisitor(object):
-    """Visitor that travels within a cms.Sequence, looks for a parameter and replaces its value"""
-    def __init__(self,paramName,paramSearch,paramValue,verbose=False):
-        self._paramName   = paramName
-        self._paramValue  = paramValue
-        self._paramSearch = paramSearch
-        self._verbose = verbose
-    def enter(self,visitee):
-        if (hasattr(visitee,self._paramName)):
-            if getattr(visitee,self._paramName) == self._paramSearch:
-                if self._verbose:print "Replaced %s.%s: %s => %s" % (visitee,self._paramName,getattr(visitee,self._paramName),self._paramValue)
-                setattr(visitee,self._paramName,self._paramValue)
-    def leave(self,visitee):
-        pass
-
-class MassSearchReplaceAnyInputTagVisitor(object):
-    """Visitor that travels within a cms.Sequence, looks for a parameter and replace its value
-       It will climb down within PSets, VPSets and VInputTags to find its target"""
-    def __init__(self,paramSearch,paramReplace,verbose=False,moduleLabelOnly=False):
-        self._paramSearch  = self.standardizeInputTagFmt(paramSearch)
-        self._paramReplace = self.standardizeInputTagFmt(paramReplace)
-        self._moduleName   = ''
-        self._verbose=verbose
-        self._moduleLabelOnly=moduleLabelOnly
-    def doIt(self,pset,base):
-        if isinstance(pset, cms._Parameterizable):
-            for name in pset.parameterNames_():
-                # if I use pset.parameters_().items() I get copies of the parameter values
-                # so I can't modify the nested pset
-                value = getattr(pset,name)
-                type = value.pythonTypeName()
-                if type == 'cms.PSet':
-                    self.doIt(value,base+"."+name)
-                elif type == 'cms.VPSet':
-                    for (i,ps) in enumerate(value): self.doIt(ps, "%s.%s[%d]"%(base,name,i) )
-                elif type == 'cms.VInputTag':
-                    for (i,n) in enumerate(value):
-                         # VInputTag can be declared as a list of strings, so ensure that n is formatted correctly
-                         n = self.standardizeInputTagFmt(n)
-                         if (n == self._paramSearch):
-                            if self._verbose:print "Replace %s.%s[%d] %s ==> %s " % (base, name, i, self._paramSearch, self._paramReplace)
-                            value[i] = self._paramReplace
-                         elif self._moduleLabelOnly and n.moduleLabel == self._paramSearch.moduleLabel:
-                            nrep = n; nrep.moduleLabel = self._paramReplace.moduleLabel
-                            if self._verbose:print "Replace %s.%s[%d] %s ==> %s " % (base, name, i, n, nrep)
-                            value[i] = nrep
-                elif type.endswith('.InputTag'):
-                    if value == self._paramSearch:
-                        if self._verbose:print "Replace %s.%s %s ==> %s " % (base, name, self._paramSearch, self._paramReplace)
-                        from copy import deepcopy
-                        if 'untracked' in type:
-                            setattr(pset, name, cms.untracked.InputTag(self._paramReplace.getModuleLabel(),
-                                                                       self._paramReplace.getProductInstanceLabel(),
-                                                                       self._paramReplace.getProcessName()))
-                        else:
-                            setattr(pset, name, deepcopy(self._paramReplace) )
-                    elif self._moduleLabelOnly and value.moduleLabel == self._paramSearch.moduleLabel:
-                        from copy import deepcopy
-                        repl = deepcopy(getattr(pset, name))
-                        repl.moduleLabel = self._paramReplace.moduleLabel
-                        setattr(pset, name, repl)
-                        if self._verbose:print "Replace %s.%s %s ==> %s " % (base, name, value, repl)
-
-
-    @staticmethod
-    def standardizeInputTagFmt(inputTag):
-       ''' helper function to ensure that the InputTag is defined as cms.InputTag(str) and not as a plain str '''
-       if not isinstance(inputTag, cms.InputTag):
-          return cms.InputTag(inputTag)
-       return inputTag
-
-    def enter(self,visitee):
-        label = ''
-        try:    label = visitee.label_()
-        except AttributeError: label = '<Module not in a Process>'
-        self.doIt(visitee, label)
-    def leave(self,visitee):
-        pass
-
-#FIXME name is not generic enough now
-class GatherAllModulesVisitor(object):
-    """Visitor that travels within a cms.Sequence, and returns a list of objects of type gatheredInance(e.g. modules) that have it"""
-    def __init__(self, gatheredInstance=cms._Module):
-        self._modules = []
-        self._gatheredInstance= gatheredInstance
-    def enter(self,visitee):
-        if isinstance(visitee,self._gatheredInstance):
-            self._modules.append(visitee)
-    def leave(self,visitee):
-        pass
-    def modules(self):
-        return self._modules
-
-class CloneSequenceVisitor(object):
-    """Visitor that travels within a cms.Sequence, and returns a cloned version of the Sequence.
-    All modules and sequences are cloned and a postfix is added"""
-    def __init__(self, process, label, postfix):
-        self._process = process
-        self._postfix = postfix
-        self._sequenceStack = [label]
-        self._moduleLabels = []
-        self._sequenceLabels = []
-        self._waitForSequenceToClose = None # modules will only be cloned or added if this is None
-
-    def enter(self,visitee):
-        if not self._waitForSequenceToClose is None:
-            return #we are in a already cloned sequence
-        if isinstance(visitee,cms._Module):
-            label = visitee.label()
-            newModule = None
-            if label in self._moduleLabels:
-                newModule = getattr(self._process, label+self._postfix)
-            else:
-                self._moduleLabels.append(label)
-
-                newModule = visitee.clone()
-                setattr(self._process, label+self._postfix, newModule)
-            self.__appendToTopSequence(newModule)
-
-        if isinstance(visitee,cms.Sequence):
-            if visitee.label() in self._sequenceLabels: # is the sequence allready cloned?
-                self._waitForSequenceToClose = visitee.label()
-                self._sequenceStack.append(  getattr(self._process, visitee.label()+self._postfix) )
-            else:
-                self._sequenceStack.append(visitee.label())#save desired label as placeholder until we have a module to create the sequence
-
-    def leave(self,visitee):
-        if isinstance(visitee,cms.Sequence):
-            if self._waitForSequenceToClose == visitee.label():
-                self._waitForSequenceToClose = None
-            if not isinstance(self._sequenceStack[-1], cms.Sequence):
-                raise StandardError, "empty Sequence encountered during cloneing. sequnece stack: %s"%self._sequenceStack
-            self.__appendToTopSequence( self._sequenceStack.pop() )
-
-    def clonedSequence(self):
-        if not len(self._sequenceStack) == 1:
-            raise StandardError, "someting went wrong, the sequence stack looks like: %s"%self._sequenceStack
-        for label in self._moduleLabels:
-            massSearchReplaceAnyInputTag(self._sequenceStack[-1], label, label+self._postfix, moduleLabelOnly=True, verbose=False)
-        self._moduleLabels = [] #prevent the InputTag replacement next time this is called.
-        return self._sequenceStack[-1]
-
-    def __appendToTopSequence(self, visitee):#this is darn ugly because empty cms.Sequences are not supported
-        if isinstance(self._sequenceStack[-1], basestring):#we have the name of an empty sequence on the stack. create it!
-            oldSequenceLabel = self._sequenceStack.pop()
-            newSequenceLabel = oldSequenceLabel + self._postfix
-            self._sequenceStack.append(cms.Sequence(visitee))
-            if hasattr(self._process, newSequenceLabel):
-                raise StandardError("Cloning the sequence "+self._sequenceStack[-1].label()+" would overwrite existing object." )
-            setattr(self._process, newSequenceLabel, self._sequenceStack[-1])
-            self._sequenceLabels.append(oldSequenceLabel)
-        else:
-            self._sequenceStack[-1] += visitee
-
-class MassSearchParamVisitor(object):
-    """Visitor that travels within a cms.Sequence, looks for a parameter and returns a list of modules that have it"""
-    def __init__(self,paramName,paramSearch):
-        self._paramName   = paramName
-        self._paramSearch = paramSearch
-        self._modules = []
-    def enter(self,visitee):
-        if (hasattr(visitee,self._paramName)):
-            if getattr(visitee,self._paramName) == self._paramSearch:
-                self._modules.append(visitee)
-    def leave(self,visitee):
-        pass
-    def modules(self):
-        return self._modules
-
-
-def massSearchReplaceParam(sequence,paramName,paramOldValue,paramValue,verbose=False):
-    sequence.visit(MassSearchReplaceParamVisitor(paramName,paramOldValue,paramValue,verbose))
-
-def listModules(sequence):
-    visitor = GatherAllModulesVisitor(gatheredInstance=cms._Module)
-    sequence.visit(visitor)
-    return visitor.modules()
-
-def listSequences(sequence):
-    visitor = GatherAllModulesVisitor(gatheredInstance=cms.Sequence)
-    sequence.visit(visitor)
-    return visitor.modules()
-
-def massSearchReplaceAnyInputTag(sequence, oldInputTag, newInputTag,verbose=False,moduleLabelOnly=False) :
-    """Replace InputTag oldInputTag with newInputTag, at any level of nesting within PSets, VPSets, VInputTags..."""
-    sequence.visit(MassSearchReplaceAnyInputTagVisitor(oldInputTag,newInputTag,verbose=verbose,moduleLabelOnly=moduleLabelOnly))
-
-def jetCollectionString(prefix='', algo='', type=''):
-    """
-    ------------------------------------------------------------------
-    return the string of the jet collection module depending on the
-    input vaules. The default return value will be 'patAK5CaloJets'.
-
-    algo   : indicating the algorithm type of the jet [expected are
-             'AK5', 'IC5', 'SC7', ...]
-    type   : indicating the type of constituents of the jet [expec-
-             ted are 'Calo', 'PFlow', 'JPT', ...]
-    prefix : prefix indicating the type of pat collection module (ex-
-             pected are '', 'selected', 'clean').
-    ------------------------------------------------------------------
-    """
-    if(prefix==''):
-        jetCollectionString ='pat'
-    else:
-        jetCollectionString =prefix
-        jetCollectionString+='Pat'
-    jetCollectionString+='Jets'
-    jetCollectionString+=algo
-    jetCollectionString+=type
-    return jetCollectionString
-
-def contains(sequence, moduleName):
-    """
-    ------------------------------------------------------------------
-    return True if a module with name 'module' is contained in the
-    sequence with name 'sequence' and False otherwise. This version
-    is not so nice as it also returns True for any substr of the name
-    of a contained module.
-
-    sequence : sequence [e.g. process.patDefaultSequence]
-    module   : module name as a string
-    ------------------------------------------------------------------
-    """
-    return not sequence.__str__().find(moduleName)==-1
-
-
-
-def cloneProcessingSnippet(process, sequence, postfix):
-   """
-   ------------------------------------------------------------------
-   copy a sequence plus the modules and sequences therein
-   both are renamed by getting a postfix
-   input tags are automatically adjusted
-   ------------------------------------------------------------------
-   """
-   result = sequence
-   if not postfix == "":
-       visitor = CloneSequenceVisitor(process,sequence.label(),postfix)
-       sequence.visit(visitor)
-       result = visitor.clonedSequence()
-   return result
-
-if __name__=="__main__":
-   import unittest
-   class TestModuleCommand(unittest.TestCase):
-       def setUp(self):
-           """Nothing to do """
-           pass
-       def testCloning(self):
-           p = cms.Process("test")
-           p.a = cms.EDProducer("a", src=cms.InputTag("gen"))
-           p.b = cms.EDProducer("b", src=cms.InputTag("a"))
-           p.c = cms.EDProducer("c", src=cms.InputTag("b","instance"))
-           p.s = cms.Sequence(p.a*p.b*p.c *p.a)
-           cloneProcessingSnippet(p, p.s, "New")
-           self.assertEqual(p.dumpPython(),'import FWCore.ParameterSet.Config as cms\n\nprocess = cms.Process("test")\n\nprocess.a = cms.EDProducer("a",\n    src = cms.InputTag("gen")\n)\n\n\nprocess.c = cms.EDProducer("c",\n    src = cms.InputTag("b","instance")\n)\n\n\nprocess.cNew = cms.EDProducer("c",\n    src = cms.InputTag("bNew","instance")\n)\n\n\nprocess.bNew = cms.EDProducer("b",\n    src = cms.InputTag("aNew")\n)\n\n\nprocess.aNew = cms.EDProducer("a",\n    src = cms.InputTag("gen")\n)\n\n\nprocess.b = cms.EDProducer("b",\n    src = cms.InputTag("a")\n)\n\n\nprocess.s = cms.Sequence(process.a*process.b*process.c*process.a)\n\n\nprocess.sNew = cms.Sequence(process.aNew+process.bNew+process.cNew)\n\n\n')
-       def testContains(self):
-           p = cms.Process("test")
-           p.a = cms.EDProducer("a", src=cms.InputTag("gen"))
-           p.b = cms.EDProducer("ab", src=cms.InputTag("a"))
-           p.c = cms.EDProducer("ac", src=cms.InputTag("b"))
-           p.s1 = cms.Sequence(p.a*p.b*p.c)
-           p.s2 = cms.Sequence(p.b*p.c)
-           self.assert_( contains(p.s1, "a") )
-           self.assert_( not contains(p.s2, "a") )
-       def testJetCollectionString(self):
-           self.assertEqual(jetCollectionString(algo = 'Foo', type = 'Bar'), 'patFooBarJets')
-           self.assertEqual(jetCollectionString(prefix = 'prefix', algo = 'Foo', type = 'Bar'), 'prefixPatFooBarJets')
-       def testListModules(self):
-           p = cms.Process("test")
-           p.a = cms.EDProducer("a", src=cms.InputTag("gen"))
-           p.b = cms.EDProducer("ab", src=cms.InputTag("a"))
-           p.c = cms.EDProducer("ac", src=cms.InputTag("b"))
-           p.s = cms.Sequence(p.a*p.b*p.c)
-           self.assertEqual([p.a,p.b,p.c], listModules(p.s))
-       def testMassSearchReplaceParam(self):
-           p = cms.Process("test")
-           p.a = cms.EDProducer("a", src=cms.InputTag("gen"))
-           p.b = cms.EDProducer("ab", src=cms.InputTag("a"))
-           p.c = cms.EDProducer("ac", src=cms.InputTag("b"),
-                                nested = cms.PSet(src = cms.InputTag("c"))
-                               )
-           p.s = cms.Sequence(p.a*p.b*p.c)
-           massSearchReplaceParam(p.s,"src",cms.InputTag("b"),"a")
-           self.assertEqual(cms.InputTag("a"),p.c.src)
-           self.assertNotEqual(cms.InputTag("a"),p.c.nested.src)
-       def testMassSearchReplaceAnyInputTag(self):
-           p = cms.Process("test")
-           p.a = cms.EDProducer("a", src=cms.InputTag("gen"))
-           p.b = cms.EDProducer("ab", src=cms.InputTag("a"))
-           p.c = cms.EDProducer("ac", src=cms.InputTag("b"),
-                                nested = cms.PSet(src = cms.InputTag("b"), src2 = cms.InputTag("c")),
-                                nestedv = cms.VPSet(cms.PSet(src = cms.InputTag("b")), cms.PSet(src = cms.InputTag("d"))),
-                                vec = cms.VInputTag(cms.InputTag("a"), cms.InputTag("b"), cms.InputTag("c"), cms.InputTag("d"))
-                               )
-           p.s = cms.Sequence(p.a*p.b*p.c)
-           massSearchReplaceAnyInputTag(p.s, cms.InputTag("b"), cms.InputTag("new"))
-           self.assertNotEqual(cms.InputTag("new"), p.b.src)
-           self.assertEqual(cms.InputTag("new"), p.c.src)
-           self.assertEqual(cms.InputTag("new"), p.c.nested.src)
-           self.assertEqual(cms.InputTag("new"), p.c.nested.src)
-           self.assertNotEqual(cms.InputTag("new"), p.c.nested.src2)
-           self.assertEqual(cms.InputTag("new"), p.c.nestedv[0].src)
-           self.assertNotEqual(cms.InputTag("new"), p.c.nestedv[1].src)
-           self.assertNotEqual(cms.InputTag("new"), p.c.vec[0])
-           self.assertEqual(cms.InputTag("new"), p.c.vec[1])
-           self.assertNotEqual(cms.InputTag("new"), p.c.vec[2])
-           self.assertNotEqual(cms.InputTag("new"), p.c.vec[3])
-
-
-   unittest.main()
diff --git a/PhysicsTools/PatAlgos/python/tools/jetTools.py b/PhysicsTools/PatAlgos/python/tools/jetTools.py
deleted file mode 100644
index 1d8008a..0000000
--- a/PhysicsTools/PatAlgos/python/tools/jetTools.py
+++ /dev/null
@@ -1,1417 +0,0 @@
-from FWCore.GuiBrowsers.ConfigToolBase import *
-
-from PhysicsTools.PatAlgos.tools.helpers import *
-
-
-_defaultBTagInfos =['impactParameterTagInfos'
-                   ,'secondaryVertexTagInfos'
-                   #,'secondaryVertexNegativeTagInfos'
-                   #,'softMuonTagInfos'
-                   #,'softPFMuonsTagInfos'
-                   #,'softPFElectronsTagInfos'
-                   #,'inclusiveSecondaryVertexFinderTagInfos'
-                   #,'inclusiveSecondaryVertexFinderFilteredTagInfos'
-                   ]
-_allowedBTagInfos =['impactParameterTagInfos'
-                   ,'secondaryVertexTagInfos'
-                   ,'secondaryVertexNegativeTagInfos'
-                   ,'softMuonTagInfos'
-                   ,'softPFMuonsTagInfos'
-                   ,'softPFElectronsTagInfos'
-                   ,'inclusiveSecondaryVertexFinderTagInfos'
-                   ,'inclusiveSecondaryVertexFinderFilteredTagInfos'
-                   ]
-_defaultBTagDiscriminators =['jetBProbabilityBJetTags'
-                            ,'jetProbabilityBJetTags'
-                            ,'trackCountingHighPurBJetTags'
-                            ,'trackCountingHighEffBJetTags'
-                            #,'negativeOnlyJetBProbabilityJetTags'
-                            #,'negativeOnlyJetProbabilityJetTags'
-                            #,'negativeTrackCountingHighEffJetTags'
-                            #,'negativeTrackCountingHighPurJetTags'
-                            #,'positiveOnlyJetBProbabilityJetTags'
-                            #,'positiveOnlyJetProbabilityJetTags'
-                            ,'simpleSecondaryVertexHighEffBJetTags'
-                            ,'simpleSecondaryVertexHighPurBJetTags'
-                            #,'simpleSecondaryVertexNegativeHighEffBJetTags'
-                            #,'simpleSecondaryVertexNegativeHighPurBJetTags'
-                            ,'combinedSecondaryVertexBJetTags'
-                            #,'combinedSecondaryVertexPositiveBJetTags'
-                            #,'combinedSecondaryVertexV1BJetTags'
-                            #,'combinedSecondaryVertexV1PositiveBJetTags'
-                            #,'combinedSecondaryVertexMVABJetTags'
-                            #,'combinedSecondaryVertexNegativeBJetTags'
-                            #,'combinedSecondaryVertexV1NegativeBJetTags'
-                            #,'softPFMuonBJetTags'
-                            #,'softPFMuonByPtBJetTags'
-                            #,'softPFMuonByIP3dBJetTags'
-                            #,'softPFMuonByIP2dBJetTags'
-                            #,'positiveSoftPFMuonBJetTags'
-                            #,'positiveSoftPFMuonByPtBJetTags'
-                            #,'positiveSoftPFMuonByIP3dBJetTags'
-                            #,'positiveSoftPFMuonByIP2dBJetTags'
-                            #,'negativeSoftPFMuonBJetTags'
-                            #,'negativeSoftPFMuonByPtBJetTags'
-                            #,'negativeSoftPFMuonByIP3dBJetTags'
-                            #,'negativeSoftPFMuonByIP2dBJetTags'
-                            #,'softPFElectronBJetTags'
-                            #,'softPFElectronByPtBJetTags'
-                            #,'softPFElectronByIP3dBJetTags'
-                            #,'softPFElectronByIP2dBJetTags'
-                            #,'positiveSoftPFElectronBJetTags'
-                            #,'positiveSoftPFElectronByPtBJetTags'
-                            #,'positiveSoftPFElectronByIP3dBJetTags'
-                            #,'positiveSoftPFElectronByIP2dBJetTags'
-                            #,'negativeSoftPFElectronBJetTags'
-                            #,'negativeSoftPFElectronByPtBJetTags'
-                            #,'negativeSoftPFElectronByIP3dBJetTags'
-                            #,'negativeSoftPFElectronByIP2dBJetTags'
-                            #,'simpleInclusiveSecondaryVertexHighEffBJetTags'
-                            #,'simpleInclusiveSecondaryVertexHighPurBJetTags'
-                            #,'doubleSecondaryVertexHighEffBJetTags'
-                            #,'combinedInclusiveSecondaryVertexBJetTags'
-                            #,'combinedInclusiveSecondaryVertexPositiveBJetTags'
-                            #,'combinedMVABJetTags'
-                            #,'positiveCombinedMVABJetTags'
-                            #,'negativeCombinedMVABJetTags'
-                            #,'combinedSecondaryVertexSoftPFLeptonV1BJetTags'
-                            #,'positiveCombinedSecondaryVertexSoftPFLeptonV1BJetTags'
-                            #,'negativeCombinedSecondaryVertexSoftPFLeptonV1BJetTags'
-                            ]
-_allowedBTagDiscriminators =['jetBProbabilityBJetTags'
-                            ,'jetProbabilityBJetTags'
-                            ,'trackCountingHighPurBJetTags'
-                            ,'trackCountingHighEffBJetTags'
-                            ,'negativeOnlyJetBProbabilityJetTags'
-                            ,'negativeOnlyJetProbabilityJetTags'
-                            ,'negativeTrackCountingHighEffJetTags'
-                            ,'negativeTrackCountingHighPurJetTags'
-                            ,'positiveOnlyJetBProbabilityJetTags'
-                            ,'positiveOnlyJetProbabilityJetTags'
-                            ,'simpleSecondaryVertexHighEffBJetTags'
-                            ,'simpleSecondaryVertexHighPurBJetTags'
-                            ,'simpleSecondaryVertexNegativeHighEffBJetTags'
-                            ,'simpleSecondaryVertexNegativeHighPurBJetTags'
-                            ,'combinedSecondaryVertexBJetTags'
-                            ,'combinedSecondaryVertexPositiveBJetTags'
-                            ,'combinedSecondaryVertexV1BJetTags'
-                            ,'combinedSecondaryVertexV1PositiveBJetTags'
-                            ,'combinedSecondaryVertexMVABJetTags'
-                            ,'combinedSecondaryVertexNegativeBJetTags'
-                            ,'combinedSecondaryVertexV1NegativeBJetTags'
-                            ,'softPFMuonBJetTags'
-                            ,'softPFMuonByPtBJetTags'
-                            ,'softPFMuonByIP3dBJetTags'
-                            ,'softPFMuonByIP2dBJetTags'
-                            ,'positiveSoftPFMuonBJetTags'
-                            ,'positiveSoftPFMuonByPtBJetTags'
-                            ,'positiveSoftPFMuonByIP3dBJetTags'
-                            ,'positiveSoftPFMuonByIP2dBJetTags'
-                            ,'negativeSoftPFMuonBJetTags'
-                            ,'negativeSoftPFMuonByPtBJetTags'
-                            ,'negativeSoftPFMuonByIP3dBJetTags'
-                            ,'negativeSoftPFMuonByIP2dBJetTags'
-                            ,'softPFElectronBJetTags'
-                            ,'softPFElectronByPtBJetTags'
-                            ,'softPFElectronByIP3dBJetTags'
-                            ,'softPFElectronByIP2dBJetTags'
-                            ,'positiveSoftPFElectronBJetTags'
-                            ,'positiveSoftPFElectronByPtBJetTags'
-                            ,'positiveSoftPFElectronByIP3dBJetTags'
-                            ,'positiveSoftPFElectronByIP2dBJetTags'
-                            ,'negativeSoftPFElectronBJetTags'
-                            ,'negativeSoftPFElectronByPtBJetTags'
-                            ,'negativeSoftPFElectronByIP3dBJetTags'
-                            ,'negativeSoftPFElectronByIP2dBJetTags'
-                            ,'simpleInclusiveSecondaryVertexHighEffBJetTags'
-                            ,'simpleInclusiveSecondaryVertexHighPurBJetTags'
-                            ,'doubleSecondaryVertexHighEffBJetTags'
-                            ,'combinedInclusiveSecondaryVertexBJetTags'
-                            ,'combinedInclusiveSecondaryVertexPositiveBJetTags'
-                            ,'combinedMVABJetTags'
-                            ,'positiveCombinedMVABJetTags'
-                            ,'negativeCombinedMVABJetTags'
-                            ,'combinedSecondaryVertexSoftPFLeptonV1BJetTags'
-                            ,'positiveCombinedSecondaryVertexSoftPFLeptonV1BJetTags'
-                            ,'negativeCombinedSecondaryVertexSoftPFLeptonV1BJetTags'
-                            ]
-
-
-class RunBTagging(ConfigToolBase):
-
-    """ Define sequence to run b tagging on AOD input for a given jet
-    collection including a JetTracksAssociatorAtVertex module with
-    name 'jetTracksAssociatorAtVertex' + 'label'
-
-    Return value is a pair of (sequence, labels) where 'sequence' is
-    the cms.Sequence, and 'labels' is a vector with the following
-    entries:
-     * labels['jta']      = the name of the JetTrackAssociator module
-     * labels['tagInfos'] = a list of names of the TagInfo modules
-     * labels['jetTags '] = a list of names of the JetTag modules
-    """
-
-    _label='runBTagging'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'jetCollection',self._defaultValue, 'input jet collection',Type=cms.InputTag)
-        self.addParameter(self._defaultParameters,'label',self._defaultValue, 'postfix label to identify new sequence/modules', Type=str)
-        self.addParameter(self._defaultParameters,'postfix',"", "postfix of default sequence (do not confuse with 'label')")
-        self.addParameter(self._defaultParameters,'btagInfo',_defaultBTagInfos,"input btag info",allowedValues=_allowedBTagInfos,Type=list)
-        self.addParameter(self._defaultParameters,'btagdiscriminators',_defaultBTagDiscriminators,"input btag discriminators",allowedValues=_allowedBTagDiscriminators,Type=list)
-
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-
-    def __call__(self,process,
-                 jetCollection      = None,
-                 label              = None,
-                 postfix            = None,
-                 btagInfo           = None,
-                 btagdiscriminators = None) :
-
-
-
-        if  jetCollection is None:
-            jetCollection=self._defaultParameters['jetCollection'].value
-        if  label is None:
-            label=self._defaultParameters['label'].value
-        if  postfix  is None:
-            postfix=self._defaultParameters['postfix'].value
-        if  btagInfo  is None:
-            btagInfo=self._defaultParameters['btagInfo'].value
-        if  btagdiscriminators is None:
-            btagdiscriminators=self._defaultParameters['btagdiscriminators'].value
-
-
-
-        self.setParameter('jetCollection',jetCollection)
-        self.setParameter('label',label)
-        self.setParameter('postfix',postfix)
-        self.setParameter('btagInfo',btagInfo)
-        self.setParameter('btagdiscriminators',btagdiscriminators)
-
-
-        return self.apply(process)
-
-    def apply(self, process):
-        jetCollection=self._parameters['jetCollection'].value
-        label=self._parameters['label'].value
-        postfix=self._parameters['postfix'].value
-        btagInfo=self._parameters['btagInfo'].value
-        btagdiscriminators=self._parameters['btagdiscriminators'].value
-
-
-        if hasattr(process, "addAction"):
-            process.disableRecording()
-
-        try:
-            comment=inspect.stack(2)[2][4][0].rstrip("\n")
-            if comment.startswith("#"):
-                self.setComment(comment.lstrip("#"))
-        except:
-            pass
-
-        #############################
-        ### TOOL CODE STARTS HERE ###
-        #############################
-        if (label == ''):
-        ## label is not allowed to be empty
-            raise ValueError, "label for re-running b tagging is not allowed to be empty"
-
-        ## import track associator & b tag configuration
-        ###process.load("RecoJets.JetAssociationProducers.ak5JTA_cff")
-        from RecoJets.JetAssociationProducers.ak5JTA_cff import ak5JetTracksAssociatorAtVertex
-        process.load("RecoBTag.Configuration.RecoBTag_cff")
-        import RecoBTag.Configuration.RecoBTag_cff as btag
-
-        ## define jetTracksAssociator; for switchJetCollection
-        ## the label is 'AOD' as empty labels will lead to crashes
-        ## of crab. In this case the postfix label is skiped,
-        ## otherwise a postfix label is added as for the other
-        ## labels
-        jtaLabel = 'jetTracksAssociatorAtVertex'+postfix
-
-        if (not label == 'AOD'):
-            jtaLabel  += label
-        ## define tag info labels (compare with jetProducer_cfi.py)
-        ipTILabel      = 'impactParameterTagInfos'                        + label + postfix
-        svTILabel      = 'secondaryVertexTagInfos'                        + label + postfix
-        ivfTILabel     = 'inclusiveSecondaryVertexFinderTagInfos'         + label + postfix
-        ivfFiltTILabel = 'inclusiveSecondaryVertexFinderFilteredTagInfos' + label + postfix
-        nvTILabel      = 'secondaryVertexNegativeTagInfos'                + label + postfix
-        smTILabel      = 'softMuonTagInfos'                               + label + postfix
-        spfmTILabel    = 'softPFMuonsTagInfos'                            + label + postfix
-        spfeTILabel    = 'softPFElectronsTagInfos'                        + label + postfix
-
-        ## make VInputTag from strings
-        def vit(*args) : return cms.VInputTag( *[ cms.InputTag(x) for x in args ] )
-
-        ## produce btags
-        btagInfoRun = []
-        print
-        print "The btaginfo below will be written to the jet collection in the PATtuple (default is all, see PatAlgos/PhysicsTools/python/tools/jetTools.py)"
-        for tagInfo in btagInfo:
-            print tagInfo
-            if hasattr( btag, tagInfo ):
-                if tagInfo=='impactParameterTagInfos':
-                    if not hasattr( process, ipTILabel ):
-                        tagInfoMod=getattr(btag,tagInfo).clone(jetTracks = cms.InputTag(jtaLabel))
-                        setattr( process, ipTILabel, tagInfoMod )
-                    else:
-                        getattr( process, ipTILabel ).jetTracks = cms.InputTag(jtaLabel)
-                if tagInfo=='secondaryVertexTagInfos':
-                    if not hasattr( process, svTILabel ):
-                        tagInfoMod=getattr(btag,tagInfo).clone(trackIPTagInfos = cms.InputTag(ipTILabel))
-                        setattr( process, svTILabel, tagInfoMod )
-                    else:
-                        getattr( process, svTILabel ).trackIPTagInfos = cms.InputTag(ipTILabel)
-                if tagInfo=='softMuonTagInfos':
-                    if not hasattr( process, smTILabel ):
-                        tagInfoMod=getattr(btag,tagInfo).clone(jets = jetCollection)
-                        setattr( process, smTILabel, tagInfoMod )
-                    else:
-                        getattr( process, smTILabel ).jets = jetCollection
-                if tagInfo=='softPFMuonsTagInfos':
-                    if not hasattr( process, spfmTILabel ):
-                        tagInfoMod=getattr(btag,tagInfo).clone(jets = jetCollection)
-                        setattr( process, spfmTILabel, tagInfoMod )
-                    else:
-                        getattr( process, spfmTILabel ).jets = jetCollection
-                if tagInfo=='softPFElectronsTagInfos':
-                    if not hasattr( process, spfeTILabel ):
-                        tagInfoMod=getattr(btag,tagInfo).clone(jets = jetCollection)
-                        setattr( process, spfeTILabel, tagInfoMod )
-                    else:
-                        getattr( process, spfeTILabel ).jets = jetCollection
-                if tagInfo=='secondaryVertexNegativeTagInfos':
-                    if not hasattr( process, nvTILabel ):
-                        tagInfoMod=getattr(btag,tagInfo).clone(trackIPTagInfos = cms.InputTag(ipTILabel))
-                        setattr( process, nvTILabel, tagInfoMod )
-                    else:
-                        getattr( process, nvTILabel ).trackIPTagInfos = cms.InputTag(ipTILabel)
-                if tagInfo=='inclusiveSecondaryVertexFinderTagInfos':
-                    if not hasattr( process, ivfTILabel ):
-                        tagInfoMod=getattr(btag,tagInfo).clone(trackIPTagInfos = cms.InputTag(ipTILabel))
-                        setattr( process, ivfTILabel, tagInfoMod )
-                    else:
-                        getattr( process, ivfTILabel ).trackIPTagInfos = cms.InputTag(ipTILabel)
-                if tagInfo=='inclusiveSecondaryVertexFinderFilteredTagInfos':
-                    if not hasattr( process, ivfFiltTILabel ):
-                        tagInfoMod=getattr(btag,tagInfo).clone(trackIPTagInfos = cms.InputTag(ipTILabel))
-                        setattr( process, ivfFiltTILabel, tagInfoMod )
-                    else:
-                        getattr( process, ivfFiltTILabel ).trackIPTagInfos = cms.InputTag(ipTILabel)
-                btagInfoRun.append( tagInfo )
-            else:
-                print '  --> ignored, since not available via RecoBTag/Configuration/python/RecoBTag_cff.py!'
-
-        btagdiscriminatorsRun = []
-        print
-        print "The bdiscriminators below will be written to the jet collection in the PATtuple (default is all, see PatAlgos/PhysicsTools/python/tools/jetTools.py)"
-        for tag in btagdiscriminators:
-            print tag
-            if hasattr( btag, tag ):
-                if tag == 'jetBProbabilityBJetTags' or tag == 'jetProbabilityBJetTags' or tag == 'trackCountingHighPurBJetTags' or tag == 'trackCountingHighEffBJetTags' or tag == 'negativeOnlyJetBProbabilityJetTags' or tag == 'negativeOnlyJetProbabilityJetTags' or tag == 'negativeTrackCountingHighEffJetTags' or  tag =='negativeTrackCountingHighPurJetTags' or tag == 'positiveOnlyJetBProbabilityJetTags' or tag == 'positiveOnlyJetProbabilityJetTags':
-                    if hasattr( process, ipTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(ipTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(ipTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(ipTILabel) )
-
-                if tag == 'simpleSecondaryVertexHighEffBJetTags' or tag == 'simpleSecondaryVertexHighPurBJetTags':
-                    if hasattr( process, svTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(svTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(svTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(svTILabel) )
-
-                if tag == 'combinedSecondaryVertexBJetTags' or tag == 'combinedSecondaryVertexPositiveBJetTags' or tag == 'combinedSecondaryVertexV1BJetTags' or tag == 'combinedSecondaryVertexV1PositiveBJetTags' or tag == 'combinedSecondaryVertexMVABJetTags':
-                    if hasattr( process, ipTILabel ) and hasattr( process, svTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(ipTILabel,svTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(ipTILabel,svTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(ipTILabel,svTILabel) )
-
-                if tag == 'combinedSecondaryVertexNegativeBJetTags' or tag == 'combinedSecondaryVertexV1NegativeBJetTags':
-                    if hasattr( process, ipTILabel ) and hasattr( process, nvTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(ipTILabel,nvTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(ipTILabel,nvTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(ipTILabel,nvTILabel) )
-
-                if tag == 'softPFMuonBJetTags' or tag == 'softPFMuonByPtBJetTags' or tag == 'softPFMuonByIP3dBJetTags' or tag == 'softPFMuonByIP2dBJetTags' or tag == 'positiveSoftPFMuonBJetTags' or tag == 'positiveSoftPFMuonByPtBJetTags' or tag == 'positiveSoftPFMuonByIP3dBJetTags' or tag == 'positiveSoftPFMuonByIP2dBJetTags' or tag == 'negativeSoftPFMuonBJetTags' or tag == 'negativeSoftPFMuonByPtBJetTags' or tag == 'negativeSoftPFMuonByIP3dBJetTags' or tag == 'negativeSoftPFMuonByIP2dBJetTags':
-                    if hasattr( process, spfmTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(spfmTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(spfmTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(spfmTILabel) )
-
-                if tag == 'softPFElectronBJetTags' or tag == 'softPFElectronByPtBJetTags' or tag == 'softPFElectronByIP3dBJetTags' or tag == 'softPFElectronByIP2dBJetTags' or tag == 'positiveSoftPFElectronBJetTags' or tag == 'positiveSoftPFElectronByPtBJetTags' or tag == 'positiveSoftPFElectronByIP3dBJetTags' or tag == 'positiveSoftPFElectronByIP2dBJetTags' or tag == 'negativeSoftPFElectronBJetTags' or tag == 'negativeSoftPFElectronByPtBJetTags' or tag == 'negativeSoftPFElectronByIP3dBJetTags' or tag == 'negativeSoftPFElectronByIP2dBJetTags':
-                    if hasattr( process, spfeTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(spfeTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(spfeTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(spfeTILabel) )
-
-                if tag == 'simpleSecondaryVertexNegativeHighEffBJetTags' or tag == 'simpleSecondaryVertexNegativeHighPurBJetTags':
-                    if hasattr( process, nvTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(nvTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(nvTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(nvTILabel) )
-
-                if tag == 'simpleInclusiveSecondaryVertexHighEffBJetTags' or tag == 'simpleInclusiveSecondaryVertexHighPurBJetTags' or tag == 'doubleSecondaryVertexHighEffBJetTags':
-                    if hasattr( process, ivfFiltTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(ivfFiltTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(ivfFiltTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(ivfFiltTILabel) )
-
-                if tag == 'combinedInclusiveSecondaryVertexBJetTags' or tag == 'combinedInclusiveSecondaryVertexPositiveBJetTags':
-                    if hasattr( process, ipTILabel ) and hasattr( process, ivfTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(ipTILabel,ivfTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(ipTILabel,ivfTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(ipTILabel,ivfTILabel) )
-
-                if tag == 'combinedMVABJetTags' or tag == 'positiveCombinedMVABJetTags' or tag == 'negativeCombinedMVABJetTags':
-                    if hasattr( process, ipTILabel ) and hasattr( process, ivfTILabel ) and hasattr( process, spfmTILabel ) and hasattr( process, spfeTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(ipTILabel, ivfTILabel,spfmTILabel,spfeTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(ipTILabel, ivfTILabel,spfmTILabel,spfeTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(ipTILabel, ivfTILabel,spfmTILabel,spfeTILabel) )
-
-                if tag == 'combinedSecondaryVertexSoftPFLeptonV1BJetTags' or tag == 'positiveCombinedSecondaryVertexSoftPFLeptonV1BJetTags' or tag == 'negativeCombinedSecondaryVertexSoftPFLeptonV1BJetTags':
-                    if hasattr( process, ipTILabel ) and hasattr( process, svTILabel ) and hasattr( process, spfmTILabel ) and hasattr( process, spfeTILabel ):
-                        if not hasattr(process, tag+label+postfix):
-                            tagMod=getattr(btag,tag).clone(tagInfos = vit(ipTILabel,svTILabel,spfmTILabel,spfeTILabel))
-                            setattr(process, tag+label+postfix, tagMod)
-                        else:
-                            getattr(process, tag+label+postfix).tagInfos = vit(ipTILabel,svTILabel,spfmTILabel,spfeTILabel)
-                        btagdiscriminatorsRun.append( tag )
-                    else:
-                        print '  --> ignored, since input %s not available!'%( vit(ipTILabel,svTILabel,spfmTILabel,spfeTILabel) )
-            else:
-                print '  --> ignored, since not available via RecoBTag/Configuration/python/RecoBTag_cff.py!'
-
-
-        ## define vector of (output) labels
-        labels = { 'jta'      : jtaLabel,
-                 'tagInfos' : [(y + label + postfix) for y in btagInfoRun],
-                 'jetTags'  : [ (x + label+postfix) for x in btagdiscriminatorsRun]
-                   }
-
-        ## add a combined b-tag sequence to the process
-        seq = cms.Sequence()
-        for x in labels['tagInfos']:
-            seq += getattr(process, x)
-        for x in labels['jetTags']:
-            seq += getattr(process, x)
-        if not hasattr( process, 'btagging'+label+postfix ):
-            setattr( process, 'btagging'+label+postfix, seq )
-        else:
-            oldSeq = getattr( process, 'btagging'+label+postfix )
-            oldLabel = oldSeq.label()
-            for obj in listSequences( oldSeq ):
-                removeIfInSequence( process, obj.label(), oldLabel )
-            for obj in listModules( oldSeq ):
-                removeIfInSequence( process, obj.label(), oldLabel )
-            listModules(oldSeq)
-            for obj in listModules( seq ):
-                oldSeq += obj
-            seq = None
-
-        ## return the combined sequence and the labels defined above
-        if ivfTILabel in getattr( process, 'btagging'+label+postfix ).moduleNames():
-            if not hasattr( process, 'inclusiveVertexing' ):
-                process.load( 'RecoVertex.AdaptiveVertexFinder.inclusiveVertexing_cff' )
-            if hasattr( process, 'inclusiveVertexing' ):
-                getattr( process, 'btagging'+label+postfix ).replace( getattr( process, ivfTILabel ), ( process.inclusiveVertexing * getattr( process, ivfTILabel ) ) )
-        if ivfFiltTILabel in getattr( process, 'btagging'+label+postfix ).moduleNames():
-            if not hasattr( process, 'inclusiveVertexing' ):
-                process.load( 'RecoVertex.AdaptiveVertexFinder.inclusiveVertexing_cff' )
-            if not hasattr( process, 'inclusiveMergedVerticesFiltered' ):
-                process.load( 'RecoBTag.SecondaryVertex.secondaryVertex_cff' )
-            if not hasattr( process, 'bToCharmDecayVertexMerged' ):
-                process.load( 'RecoBTag.SecondaryVertex.bToCharmDecayVertexMerger_cfi' )
-            if hasattr( process, 'inclusiveVertexing' ) and hasattr( process, 'inclusiveMergedVerticesFiltered' ) and hasattr( process, 'bToCharmDecayVertexMerged' ):
-                getattr( process, 'btagging'+label+postfix ).replace( getattr( process, ivfFiltTILabel ), ( process.inclusiveVertexing * process.inclusiveMergedVerticesFiltered * process.bToCharmDecayVertexMerged * getattr( process, ivfFiltTILabel ) ) )
-
-        if hasattr(process, "addAction"):
-            process.enableRecording()
-            action=self.__copy__()
-            process.addAction(action)
-        return (seq, labels)
-
-runBTagging=RunBTagging()
-
-
-class AddJetCollection(ConfigToolBase):
-
-    """ Add a new collection of jets. Takes the configuration from the
-    already configured standard jet collection as starting point;
-    replaces before calling addJetCollection will also affect the
-    new jet collections
-    """
-    _label='addJetCollection'
-    _defaultParameters=dicttypes.SortedKeysDict()
-
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'jetCollection',self._defaultValue,'Input jet collection', cms.InputTag)
-        self.addParameter(self._defaultParameters,'algoLabel',self._defaultValue, "label to indicate the jet algorithm (e.g.'AK5')",str)
-        self.addParameter(self._defaultParameters,'typeLabel',self._defaultValue, "label to indicate the type of constituents (e.g. 'Calo', 'Pflow', 'Jpt', ...)",str)
-        self.addParameter(self._defaultParameters,'btagInfo',_defaultBTagInfos,"input btag info",allowedValues=_allowedBTagInfos,Type=list)
-        self.addParameter(self._defaultParameters,'btagdiscriminators',_defaultBTagDiscriminators,"input btag discriminators",allowedValues=_allowedBTagDiscriminators,Type=list)
-        self.addParameter(self._defaultParameters,'doJTA',True, "run b tagging sequence for new jet collection and add it to the new pat jet collection")
-        self.addParameter(self._defaultParameters,'doBTagging',True, 'run JetTracksAssociation and JetCharge and add it to the new pat jet collection (will autom. be true if doBTagging is set to true)')
-        self.addParameter(self._defaultParameters,'jetCorrLabel',None, "payload and list of new jet correction labels, such as (\'AK5Calo\',[\'L2Relative\', \'L3Absolute\'])", tuple,acceptNoneValue=True )
-        self.addParameter(self._defaultParameters,'doType1MET',True, "if jetCorrLabel is not 'None', set this to 'True' to redo the Type1 MET correction for the new jet colllection; at the moment it must be 'False' for non CaloJets otherwise the JetMET POG module crashes. ")
-        self.addParameter(self._defaultParameters,'doL1Cleaning',True, "copy also the producer modules for cleanLayer1 will be set to 'True' automatically when doL1Counters is 'True'")
-        self.addParameter(self._defaultParameters,'doL1Counters',False, "copy also the filter modules that accept/reject the event looking at the number of jets")
-        self.addParameter(self._defaultParameters,'genJetCollection',cms.InputTag("ak5GenJets"), "GenJet collection to match to")
-        self.addParameter(self._defaultParameters,'doJetID',True, "add jetId variables to the added jet collection?")
-        self.addParameter(self._defaultParameters,'jetIdLabel',"ak5", " specify the label prefix of the xxxJetID object; in general it is the jet collection tag like ak5, kt4 sc5, aso. For more information have a look to SWGuidePATTools#add_JetCollection")
-        self.addParameter(self._defaultParameters,'standardAlgo',"AK5", "standard algorithm label of the collection from which the clones for the new jet collection will be taken from (note that this jet collection has to be available in the event before hand)")
-        self.addParameter(self._defaultParameters,'standardType',"Calo", "standard constituent type label of the collection from which the clones for the new jet collection will be taken from (note that this jet collection has to be available in the event before hand)")
-        self.addParameter(self._defaultParameters,'outputModules', ['out'], "output module labels, empty list of label indicates no output, default: ['out']")
-
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-
-                 jetCollection      = None,
-                 algoLabel          = None,
-                 typeLabel          = None,
-                 doJTA              = None,
-                 doBTagging         = None,
-                 jetCorrLabel       = None,
-                 doType1MET         = None,
-                 doL1Cleaning       = None,
-                 doL1Counters       = None,
-                 genJetCollection   = None,
-                 doJetID            = None,
-                 jetIdLabel         = None,
-                 outputModule       = None,
-                 outputModules      = None,
-                 btagInfo           = None,
-                 btagdiscriminators = None
-                                      ):
-
-        ## stop processing if 'outputModule' exists and show the new alternative
-        if  not outputModule is None:
-            depricatedOptionOutputModule(self)
-        if jetCollection  is None:
-            jetCollection=self._defaultParameters['jetCollection'].value
-        if algoLabel is None:
-            algoLabel=self._defaultParameters['algoLabel'].value
-        if typeLabel is None:
-            typeLabel=self._defaultParameters['typeLabel'].value
-        if doJTA is None:
-            doJTA=self._defaultParameters['doJTA'].value
-        if doBTagging is None:
-            doBTagging=self._defaultParameters['doBTagging'].value
-        if jetCorrLabel  is None:
-            jetCorrLabel=self._defaultParameters['jetCorrLabel'].value
-        if doType1MET  is None:
-            doType1MET=self._defaultParameters['doType1MET'].value
-        if doL1Cleaning is None:
-            doL1Cleaning=self._defaultParameters['doL1Cleaning'].value
-        if doL1Counters  is None:
-            doL1Counters=self._defaultParameters['doL1Counters'].value
-        if genJetCollection  is None:
-            genJetCollection=self._defaultParameters['genJetCollection'].value
-        if doJetID  is None:
-            doJetID=self._defaultParameters['doJetID'].value
-        if jetIdLabel  is None:
-            jetIdLabel=self._defaultParameters['jetIdLabel'].value
-        if outputModules is None:
-            outputModules=self._defaultParameters['outputModules'].value
-        if  btagInfo is None:
-            btagInfo=self._defaultParameters['btagInfo'].value
-        if  btagdiscriminators is None:
-            btagdiscriminators=self._defaultParameters['btagdiscriminators'].value
-
-        self.setParameter('jetCollection',jetCollection)
-        self.setParameter('algoLabel',algoLabel)
-        self.setParameter('typeLabel',typeLabel)
-        self.setParameter('doJTA',doJTA)
-        self.setParameter('doBTagging',doBTagging)
-        self.setParameter('jetCorrLabel',jetCorrLabel)
-        self.setParameter('doType1MET',doType1MET)
-        self.setParameter('doL1Cleaning',doL1Cleaning)
-        self.setParameter('doL1Counters',doL1Counters)
-        self.setParameter('genJetCollection',genJetCollection)
-        self.setParameter('doJetID',doJetID)
-        self.setParameter('jetIdLabel',jetIdLabel)
-        self.setParameter('outputModules',outputModules)
-        self.setParameter('btagInfo',btagInfo)
-        self.setParameter('btagdiscriminators',btagdiscriminators)
-
-        self.apply(process)
-
-    def toolCode(self, process):
-
-        jetCollection=self._parameters['jetCollection'].value
-        algoLabel=self._parameters['algoLabel'].value
-        typeLabel=self._parameters['typeLabel'].value
-        doJTA=self._parameters['doJTA'].value
-        doBTagging=self._parameters['doBTagging'].value
-        jetCorrLabel=self._parameters['jetCorrLabel'].value
-        doType1MET =self._parameters['doType1MET'].value
-        doL1Cleaning=self._parameters['doL1Cleaning'].value
-        doL1Counters=self._parameters['doL1Counters'].value
-        genJetCollection=self._parameters['genJetCollection'].value
-        doJetID=self._parameters['doJetID'].value
-        jetIdLabel=self._parameters['jetIdLabel'].value
-        outputModules=self._parameters['outputModules'].value
-        btagInfo=self._parameters['btagInfo'].value
-        btagdiscriminators=self._parameters['btagdiscriminators'].value
-
-
-        ## create old module label from standardAlgo
-        ## and standardType and return
-        def oldLabel(prefix=''):
-            return jetCollectionString(prefix, '', '')
-
-        ## create new module label from old module
-        ## label and return
-        def newLabel(oldLabel):
-            newLabel=oldLabel
-            oldLabel=oldLabel+algoLabel+typeLabel
-            return oldLabel
-
-        ## clone module and add it to the patDefaultSequence
-        def addClone(hook, **replaceStatements):
-            ## create a clone of the hook with corresponding
-            ## parameter replacements
-            newModule = getattr(process, hook).clone(**replaceStatements)
-            ## add the module to the sequence
-            addModuleToSequence(hook, newModule)
-
-        ## add module to the patDefaultSequence
-        def addModuleToSequence(hook, newModule):
-            hookModule = getattr(process, hook)
-            ## add the new module with standardAlgo &
-            ## standardType replaced in module label
-            setattr( process, newLabel(hook), newModule)
-            ## add new module to default sequence
-            ## just behind the hookModule
-            process.patDefaultSequence.replace( hookModule, hookModule*newModule )
-
-        ## add a clone of patJets
-        addClone(oldLabel(), jetSource = jetCollection)
-        ## add a clone of selectedPatJets
-        addClone(oldLabel('selected'), src=cms.InputTag(newLabel(oldLabel())))
-        ## add a clone of cleanPatJets
-        if( doL1Cleaning ):
-            addClone(oldLabel('clean'), src=cms.InputTag(newLabel(oldLabel('selected'))))
-        ## add a clone of countPatJets
-        if( doL1Counters ):
-            if( doL1Cleaning ):
-                addClone(oldLabel('count'), src=cms.InputTag(newLabel(oldLabel('clean'))))
-            else:
-                addClone(oldLabel('count'), src=cms.InputTag(newLabel(oldLabel('selected'))))
-
-        ## get attributes of new module
-        l1Jets = getattr(process, newLabel(oldLabel()))
-
-        ## add a clone of gen jet matching
-        addClone('patJetPartonMatch', src = jetCollection)
-        addClone('patJetGenJetMatch', src = jetCollection, matched = genJetCollection)
-
-        ## add a clone of parton and flavour associations
-        addClone('patJetPartonAssociation', jets = jetCollection)
-        addClone('patJetFlavourAssociation', srcByReference = cms.InputTag(newLabel('patJetPartonAssociation')))
-
-        ## fix label for input tag
-        def fixInputTag(x): x.setModuleLabel(newLabel(x.moduleLabel))
-        ## fix label for vector of input tags
-        def fixVInputTag(x): x[0].setModuleLabel(newLabel(x[0].moduleLabel))
-
-        ## provide allLayer1Jet inputs with individual labels
-        fixInputTag(l1Jets.genJetMatch)
-        fixInputTag(l1Jets.genPartonMatch)
-        fixInputTag(l1Jets.JetPartonMapSource)
-
-        ## make VInputTag from strings
-        def vit(*args) : return cms.VInputTag( *[ cms.InputTag(x) for x in args ] )
-
-        if (doJTA or doBTagging):
-            ## add clone of jet track association
-            ###process.load("RecoJets.JetAssociationProducers.ak5JTA_cff")
-            from RecoJets.JetAssociationProducers.ak5JTA_cff import ak5JetTracksAssociatorAtVertex
-            ## add jet track association module to processes
-            jtaLabel = 'jetTracksAssociatorAtVertex'+algoLabel+typeLabel
-            setattr( process, jtaLabel, ak5JetTracksAssociatorAtVertex.clone(jets = jetCollection) )
-            process.patDefaultSequence.replace(process.patJetCharge, getattr(process,jtaLabel)+process.patJetCharge)
-            l1Jets.trackAssociationSource = cms.InputTag(jtaLabel)
-            addClone('patJetCharge', src=cms.InputTag(jtaLabel)),
-            fixInputTag(l1Jets.jetChargeSource)
-        else:
-            ## switch embedding of track association and jet
-            ## charge estimate to 'False'
-            l1Jets.addAssociatedTracks = False
-            l1Jets.addJetCharge = False
-
-        if (doBTagging):
-            ## define postfixLabel
-            postfixLabel=algoLabel+typeLabel
-            ## add b tagging sequence
-            (btagSeq, btagLabels) = runBTagging(process, jetCollection, postfixLabel,"", btagInfo,btagdiscriminators)
-            ## add b tagging sequence before running the allLayer1Jets modules
-            ## nedded only after first call to runBTagging(), existing sequence modified in place otherwise
-            if not btagSeq == None:
-                process.patDefaultSequence.replace(getattr(process,jtaLabel), getattr(process,jtaLabel)+btagSeq)
-            ## replace corresponding tags for pat jet production
-            l1Jets.trackAssociationSource = cms.InputTag(btagLabels['jta'])
-            l1Jets.tagInfoSources = cms.VInputTag( *[ cms.InputTag(x) for x in btagLabels['tagInfos'] ] )
-            l1Jets.discriminatorSources = cms.VInputTag( *[ cms.InputTag(x) for x in btagLabels['jetTags']  ] )
-        else:
-            ## switch general b tagging info switch off
-            l1Jets.addBTagInfo = False
-            ## adjust output
-            if len(outputModules) > 0:
-                for outMod in outputModules:
-                    if hasattr(process,outMod):
-                        getattr(process,outMod).outputCommands.append("drop *_"+newLabel(oldLabel('selected'))+"_tagInfos_*")
-                    else:
-                        raise KeyError, "process has no OutModule named", outMod
-
-        if (doJetID):
-            l1Jets.addJetID = cms.bool(True)
-            jetIdLabelNew = jetIdLabel + 'JetID'
-            l1Jets.jetIDMap = cms.InputTag( jetIdLabelNew )
-        else :
-            l1Jets.addJetID = cms.bool(False)
-
-        if (jetCorrLabel != None):
-            ## add clone of jet energy corrections;
-            ## catch a couple of exceptions first
-            if (jetCorrLabel == False ):
-                raise ValueError, "In addJetCollection 'jetCorrLabel' must be set to 'None', not 'False'"
-            if (jetCorrLabel == "None"):
-                raise ValueError, "In addJetCollection 'jetCorrLabel' must be set to 'None' (without quotes)"
-            ## check for the correct format
-            if type(jetCorrLabel) != type(('AK5Calo',['L2Relative'])):
-                raise ValueError, "In addJetCollection 'jetCorrLabel' must be 'None', or of type ('payload',['correction1', 'correction2'])"
-
-            ## add clone of jetCorrFactors
-            addClone('patJetCorrFactors', src = jetCollection)
-            switchJetCorrLevels(process, jetCorrLabel = jetCorrLabel, postfix=algoLabel+typeLabel)
-            getattr(process, newLabel('patJets')).jetCorrFactorsSource = cms.VInputTag(  cms.InputTag(newLabel('patJetCorrFactors')) )
-
-            ## find out type of jet collection, switch type1MET corrections off for JPTJets
-            jetCollType = ''
-            if   ( 'CaloJets' in jetCollection.getModuleLabel() ):
-                jetCollType = 'Calo'
-            elif ( 'PFJets' in jetCollection.getModuleLabel() or jetCollection.getModuleLabel().startswith('pfNo') or jetCollection.getModuleLabel() == 'particleFlow'):
-                jetCollType = 'PF'
-            else:
-                print '============================================='
-                print 'Type1MET corrections are switched off for    '
-                print 'JPT Jets. Users are recommened to use tcMET  '
-                print 'together with JPT jets.                      '
-                print '============================================='
-                doType1MET=False
-
-            ## add a clone of the type1MET correction for the new jet collection
-            if (doType1MET):
-                ## create jet correctors for MET corrections
-                from JetMETCorrections.Configuration.JetCorrectionServicesAllAlgos_cff import ak5PFL1Fastjet, ak5PFL1Offset, ak5PFL2Relative, ak5PFL3Absolute, ak5PFResidual
-                setattr(process, jetCorrLabel[0]+'L1FastJet'   , ak5PFL1Fastjet.clone ( algorithm=jetCorrLabel[0]
-                                                                                      , srcRho=cms.InputTag(newLabel('kt6PFJets'),'rho') ) )
-                setattr(process, jetCorrLabel[0]+'L1Offset'    , ak5PFL1Offset.clone  ( algorithm=jetCorrLabel[0] ) )
-                setattr(process, jetCorrLabel[0]+'L2Relative'  , ak5PFL2Relative.clone( algorithm=jetCorrLabel[0] ) )
-                setattr(process, jetCorrLabel[0]+'L3Absolute'  , ak5PFL3Absolute.clone( algorithm=jetCorrLabel[0] ) )
-                setattr(process, jetCorrLabel[0]+'L2L3Residual', ak5PFResidual.clone  ( algorithm=jetCorrLabel[0] ) )
-                ## combinded corrections
-                setattr(process, jetCorrLabel[0]+'CombinedCorrector', cms.ESProducer( 'JetCorrectionESChain'
-                                                                                  , correctors = cms.vstring() ) )
-
-                for corrLbl in jetCorrLabel[1]:
-                    if corrLbl != 'L1FastJet' and corrLbl != 'L1Offset' and corrLbl != 'L2Relative' and corrLbl != 'L3Absolute' and corrLbl != 'L2L3Residual':
-                        print '========================================='
-                        print ' Type1MET corrections are currently only  '
-                        print ' supported for the following corrections: '
-                        print '   - L1FastJet'
-                        print '   - L1Offset'
-                        print '   - L2Relative'
-                        print '   - L3Absolute'
-                        print '   - L2L3Residual'
-                        print ' But given was:'
-                        print '   -', corrLbl
-                        print '============================================='
-                        raise ValueError, 'unsupported JEC for TypeI MET correction: '+corrLbl
-                    else:
-                        getattr(process, jetCorrLabel[0]+'CombinedCorrector').correctors.append(jetCorrLabel[0]+corrLbl)
-
-                ## configuration of MET corrections
-                if jetCollType == 'Calo':
-                    from JetMETCorrections.Type1MET.caloMETCorrections_cff import caloJetMETcorr,caloType1CorrectedMet,caloType1p2CorrectedMet,produceCaloMETCorrections
-
-                    setattr(process,jetCorrLabel[0]+'JetMETcorr',   caloJetMETcorr.clone(srcMET       = "corMetGlobalMuons"))
-                    setattr(process,jetCorrLabel[0]+'Type1CorMet',  caloType1CorrectedMet.clone(src   = "corMetGlobalMuons"))
-                    setattr(process,jetCorrLabel[0]+'Type1p2CorMet',caloType1p2CorrectedMet.clone(src = "corMetGlobalMuons"))
-
-                    getattr(process,jetCorrLabel[0]+'JetMETcorr'   ).src          = cms.InputTag(jetCollection.getModuleLabel())
-                    if ('L1FastJet' in jetCorrLabel[1] or 'L1Fastjet' in jetCorrLabel[1]):
-                        getattr(process,jetCorrLabel[0]+'JetMETcorr'   ).offsetCorrLabel = cms.string(jetCorrLabel[0]+'L1FastJet')
-                    elif ('L1Offset' in jetCorrLabel[1]):
-                        getattr(process,jetCorrLabel[0]+'JetMETcorr'   ).offsetCorrLabel = cms.string(jetCorrLabel[0]+'L1Offset')
-                    else:
-                        getattr(process,jetCorrLabel[0]+'JetMETcorr'   ).offsetCorrLabel = cms.string('')
-                    getattr(process,jetCorrLabel[0]+'JetMETcorr'   ).jetCorrLabel = cms.string(jetCorrLabel[0]+'CombinedCorrector')
-
-                    getattr(process,jetCorrLabel[0]+'Type1CorMet'  ).srcType1Corrections = cms.VInputTag(
-                        cms.InputTag(jetCorrLabel[0]+'JetMETcorr', 'type1')
-                        )
-
-                    getattr(process,jetCorrLabel[0]+'Type1p2CorMet').srcType1Corrections = cms.VInputTag(
-                        cms.InputTag(jetCorrLabel[0]+'JetMETcorr', 'type1')
-                        )
-                    getattr(process,jetCorrLabel[0]+'Type1p2CorMet').srcUnclEnergySums = cms.VInputTag(
-                        cms.InputTag(jetCorrLabel[0]+'JetMETcorr', 'type2'),
-                        cms.InputTag(jetCorrLabel[0]+'JetMETcorr', 'offset'),
-                        cms.InputTag('muonCaloMETcorr')
-                        )
-
-                    ## add MET corrections to sequence
-                    setattr(process,'patMETs'+jetCorrLabel[0],getattr(process,'patMETs').clone(metSource = cms.InputTag(jetCorrLabel[0]+'Type1CorMet'),addMuonCorrections = False))
-
-                    setattr(process,'produce'+jetCorrLabel[0]+'METCorrections',produceCaloMETCorrections.copy())
-                    getattr(process,'produce'+jetCorrLabel[0]+'METCorrections').replace(getattr(process,'caloJetMETcorr'),         getattr(process,jetCorrLabel[0]+'JetMETcorr'))
-                    getattr(process,'produce'+jetCorrLabel[0]+'METCorrections').replace(getattr(process,'caloType1CorrectedMet'),  getattr(process,jetCorrLabel[0]+'Type1CorMet'))
-                    getattr(process,'produce'+jetCorrLabel[0]+'METCorrections').replace(getattr(process,'caloType1p2CorrectedMet'),getattr(process,jetCorrLabel[0]+'Type1p2CorMet'))
-
-                    process.patDefaultSequence.replace( getattr(process,'patMETs'+jetCorrLabel[0]),
-                                                        getattr(process,'produce'+jetCorrLabel[0]+'METCorrections')
-                                                        *getattr(process,'patMETs'+jetCorrLabel[0]))
-
-                elif jetCollType == 'PF':
-                    from JetMETCorrections.Type1MET.pfMETCorrections_cff import pfCandsNotInJet,pfJetMETcorr,pfCandMETcorr,pfType1CorrectedMet,pfType1p2CorrectedMet,producePFMETCorrections
-                    setattr(process,jetCorrLabel[0]+'CandsNotInJet',pfCandsNotInJet.clone(topCollection = jetCollection))
-                    setattr(process,jetCorrLabel[0]+'JetMETcorr',   pfJetMETcorr.clone(src              = jetCollection))
-                    setattr(process,jetCorrLabel[0]+'CandMETcorr',  pfCandMETcorr.clone(src             = cms.InputTag(jetCorrLabel[0]+'CandsNotInJet')))
-                    setattr(process,jetCorrLabel[0]+'Type1CorMet',  pfType1CorrectedMet.clone())
-                    setattr(process,jetCorrLabel[0]+'Type1p2CorMet',pfType1p2CorrectedMet.clone())
-
-                    if ('L1FastJet' in jetCorrLabel[1] or 'L1Fastjet' in jetCorrLabel[1]):
-                        getattr(process,jetCorrLabel[0]+'JetMETcorr'   ).offsetCorrLabel = cms.string(jetCorrLabel[0]+'L1FastJet')
-                    elif ('L1Offset' in jetCorrLabel[1]):
-                        getattr(process,jetCorrLabel[0]+'JetMETcorr'   ).offsetCorrLabel = cms.string(jetCorrLabel[0]+'L1Offset')
-                    else:
-                        getattr(process,jetCorrLabel[0]+'JetMETcorr'   ).offsetCorrLabel = cms.string('')
-                    getattr(process,jetCorrLabel[0]+'JetMETcorr').jetCorrLabel    = cms.string(jetCorrLabel[0]+'CombinedCorrector')
-
-                    getattr(process,jetCorrLabel[0]+'Type1CorMet').applyType0Corrections = cms.bool(False)
-                    getattr(process,jetCorrLabel[0]+'Type1CorMet').srcType1Corrections = cms.VInputTag(
-                        cms.InputTag(jetCorrLabel[0]+'JetMETcorr', 'type1')
-                        )
-                    getattr(process,jetCorrLabel[0]+'Type1p2CorMet').srcType1Corrections = cms.VInputTag(
-                        cms.InputTag(jetCorrLabel[0]+'JetMETcorr', 'type1')
-                        )
-                    getattr(process,jetCorrLabel[0]+'Type1p2CorMet').applyType0Corrections = cms.bool(False)
-                    getattr(process,jetCorrLabel[0]+'Type1p2CorMet').srcUnclEnergySums = cms.VInputTag(
-                        cms.InputTag(jetCorrLabel[0]+'JetMETcorr', 'type2'),
-                        cms.InputTag(jetCorrLabel[0]+'JetMETcorr', 'offset'),
-                        cms.InputTag(jetCorrLabel[0]+'CandMETcorr')
-                        )
-
-                    ## add MET corrections to sequence
-                    setattr(process,'patMETs'+jetCorrLabel[0],getattr(process,'patMETs').clone(metSource = cms.InputTag(jetCorrLabel[0]+'Type1CorMet'),addMuonCorrections = False))
-
-                    setattr(process,'produce'+jetCorrLabel[0]+'METCorrections',producePFMETCorrections.copy())
-                    getattr(process,'produce'+jetCorrLabel[0]+'METCorrections').replace(getattr(process,'pfCandsNotInJet'),      getattr(process,jetCorrLabel[0]+'CandsNotInJet'))
-                    getattr(process,'produce'+jetCorrLabel[0]+'METCorrections').replace(getattr(process,'pfJetMETcorr'),         getattr(process,jetCorrLabel[0]+'JetMETcorr'))
-                    getattr(process,'produce'+jetCorrLabel[0]+'METCorrections').replace(getattr(process,'pfCandMETcorr'),        getattr(process,jetCorrLabel[0]+'CandMETcorr'))
-                    getattr(process,'produce'+jetCorrLabel[0]+'METCorrections').replace(getattr(process,'pfType1CorrectedMet'),  getattr(process,jetCorrLabel[0]+'Type1CorMet'))
-                    getattr(process,'produce'+jetCorrLabel[0]+'METCorrections').replace(getattr(process,'pfType1p2CorrectedMet'),getattr(process,jetCorrLabel[0]+'Type1p2CorMet'))
-
-                    process.patDefaultSequence.replace( getattr(process,'patMETs'+jetCorrLabel[0]),
-                                                        getattr(process,'produce'+jetCorrLabel[0]+'METCorrections')
-                                                        *getattr(process,'patMETs'+jetCorrLabel[0]))
-
-        else:
-            ## switch jetCorrFactors off
-            l1Jets.addJetCorrFactors = False
-
-addJetCollection=AddJetCollection()
-
-
-class SwitchJetCollection(ConfigToolBase):
-
-    """ Switch the collection of jets in PAT from the default value to a
-    new jet collection
-    """
-    _label='switchJetCollection'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'jetCollection',self._defaultValue,'Input jet collection', cms.InputTag)
-        self.addParameter(self._defaultParameters,'btagInfo',_defaultBTagInfos,"input btag info",allowedValues=_allowedBTagInfos,Type=list)
-        self.addParameter(self._defaultParameters,'btagdiscriminators',_defaultBTagDiscriminators,"input btag discriminators",allowedValues=_allowedBTagDiscriminators,Type=list)
-	self.addParameter(self._defaultParameters,'doJTA',True, "run b tagging sequence for new jet collection and add it to the new pat jet collection")
-        self.addParameter(self._defaultParameters,'doBTagging',True, 'run JetTracksAssociation and JetCharge and add it to the new pat jet collection (will autom. be true if doBTagging is set to true)')
-        self.addParameter(self._defaultParameters,'jetCorrLabel',None, "payload and list of new jet correction labels, such as (\'AK5Calo\',[\'L2Relative\', \'L3Absolute\'])", tuple,acceptNoneValue=True )
-        self.addParameter(self._defaultParameters,'doType1MET',True, "if jetCorrLabel is not 'None', set this to 'True' to redo the Type1 MET correction for the new jet colleection; at the moment it must be 'False' for non CaloJets otherwise the JetMET POG module crashes. ")
-        self.addParameter(self._defaultParameters,'genJetCollection',cms.InputTag("ak5GenJets"), "GenJet collection to match to")
-        self.addParameter(self._defaultParameters,'doJetID',True, "add jetId variables to the added jet collection")
-        self.addParameter(self._defaultParameters,'jetIdLabel',"ak5", " specify the label prefix of the xxxJetID object; in general it is the jet collection tag like ak5, kt4 sc5, aso. For more information have a look to SWGuidePATTools#add_JetCollection")
-        self.addParameter(self._defaultParameters,'postfix',"", "postfix of default sequence")
-        self.addParameter(self._defaultParameters, 'outputModules', ['out'], "Output module labels, empty list of label indicates no output, default: ['out']")
-
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 jetCollection      = None,
-                 doJTA              = None,
-                 doBTagging         = None,
-                 jetCorrLabel       = None,
-                 doType1MET         = None,
-                 genJetCollection   = None,
-                 doJetID            = None,
-                 jetIdLabel         = None,
-                 postfix            = None,
-                 outputModule       = None,
-                 outputModules      = None,
-                 btagInfo           = None,
-                 btagdiscriminators = None
-					):
-
-
-
-
-        ## stop processing if 'outputModule' exists and show the new alternative
-        if  not outputModule is None:
-            depricatedOptionOutputModule(self)
-        if jetCollection  is None:
-            jetCollection=self._defaultParameters['jetCollection'].value
-        if doJTA is None:
-            doJTA=self._defaultParameters['doJTA'].value
-        if doBTagging is None:
-            doBTagging=self._defaultParameters['doBTagging'].value
-        if jetCorrLabel  is None:
-            jetCorrLabel=self._defaultParameters['jetCorrLabel'].value
-        if doType1MET  is None:
-            doType1MET=self._defaultParameters['doType1MET'].value
-        if genJetCollection  is None:
-            genJetCollection=self._defaultParameters['genJetCollection'].value
-        if doJetID  is None:
-            doJetID=self._defaultParameters['doJetID'].value
-        if jetIdLabel  is None:
-            jetIdLabel=self._defaultParameters['jetIdLabel'].value
-        if outputModules is None:
-            outputModules=self._defaultParameters['outputModules'].value
-        if postfix  is None:
-            postfix=self._defaultParameters['postfix'].value
-        if  btagInfo is None:
-             btagInfo=self._defaultParameters['btagInfo'].value
-        if  btagdiscriminators is None:
-             btagdiscriminators=self._defaultParameters['btagdiscriminators'].value
-
-
-
-
-        self.setParameter('jetCollection',jetCollection)
-        self.setParameter('doJTA',doJTA)
-        self.setParameter('doBTagging',doBTagging)
-        self.setParameter('jetCorrLabel',jetCorrLabel)
-        self.setParameter('doType1MET',doType1MET)
-        self.setParameter('genJetCollection',genJetCollection)
-        self.setParameter('doJetID',doJetID)
-        self.setParameter('jetIdLabel',jetIdLabel)
-        self.setParameter('outputModules',outputModules)
-        self.setParameter('postfix',postfix)
-        self.setParameter('btagInfo',btagInfo)
-        self.setParameter('btagdiscriminators',btagdiscriminators)
-
-        self.apply(process)
-
-    def toolCode(self, process):
-        jetCollection=self._parameters['jetCollection'].value
-        doJTA=self._parameters['doJTA'].value
-        doBTagging=self._parameters['doBTagging'].value
-        jetCorrLabel=self._parameters['jetCorrLabel'].value
-        doType1MET =self._parameters['doType1MET'].value
-        genJetCollection=self._parameters['genJetCollection'].value
-        doJetID=self._parameters['doJetID'].value
-        jetIdLabel=self._parameters['jetIdLabel'].value
-        outputModules=self._parameters['outputModules'].value
-        postfix=self._parameters['postfix'].value
-        btagInfo=self._parameters['btagInfo'].value
-        btagdiscriminators=self._parameters['btagdiscriminators'].value
-
-        ## save label of old input jet collection
-        oldLabel = applyPostfix(process, "patJets", postfix).jetSource;
-
-        ## replace input jet collection for generator matches if the
-        ## genJetCollection is no empty
-        if (process.patJets.addGenPartonMatch):
-            applyPostfix(process, "patJetPartonMatch", postfix).src = jetCollection
-        if (process.patJets.addGenJetMatch):
-            applyPostfix(process, "patJetGenJetMatch", postfix).src = jetCollection
-            applyPostfix(process, "patJetGenJetMatch", postfix).matched = genJetCollection
-        if (process.patJets.getJetMCFlavour):
-            applyPostfix(process, "patJetPartonAssociation", postfix).jets = jetCollection
-
-        ## replace input jet collection for pat jet production
-	applyPostfix(process, "patJets", postfix).jetSource = jetCollection
-
-        ## make VInputTag from strings
-        def vit(*args) : return cms.VInputTag( *[ cms.InputTag(x) for x in args ] )
-
-        if (doJTA or doBTagging):
-            ## replace jet track association
-            ###process.load("RecoJets.JetAssociationProducers.ak5JTA_cff")
-            from RecoJets.JetAssociationProducers.ak5JTA_cff import ak5JetTracksAssociatorAtVertex
-            if not hasattr(process, "jetTracksAssociatorAtVertex"+postfix):
-                setattr(process, "jetTracksAssociatorAtVertex"+postfix, ak5JetTracksAssociatorAtVertex.clone(jets = jetCollection))
-            else:
-                getattr(process, "jetTracksAssociatorAtVertex"+postfix).jets = jetCollection
-            getattr(process, "patDefaultSequence"+postfix).replace(
-                applyPostfix(process, "patJetCharge", postfix),
-                getattr(process, "jetTracksAssociatorAtVertex" + postfix) #module with postfix that is not n patDefaultSequence
-                + applyPostfix(process, "patJetCharge", postfix)
-                )
-
-            applyPostfix(process, "patJetCharge", postfix).src = 'jetTracksAssociatorAtVertex'+postfix
-            applyPostfix(process, "patJets", postfix).trackAssociationSource = 'jetTracksAssociatorAtVertex'+postfix
-        else:
-            ## remove the jet track association from the std
-            ## sequence
-            removeIfInSequence(process,  "patJetCharge",  "patDefaultSequence", postfix)
-            ## switch embedding of track association and jet
-            ## charge estimate to 'False'
-            applyPostfix(process, "patJets", postfix).addAssociatedTracks = False
-            applyPostfix(process, "patJets", postfix).addJetCharge = False
-
-        if (doBTagging):
-            ## replace b tagging sequence; add postfix label 'AOD' as crab will
-            ## crash when confronted with empy labels
-            (btagSeq, btagLabels) = runBTagging(process, jetCollection,"AOD",postfix,btagInfo,btagdiscriminators)
-	    ## add b tagging sequence before running the allLayer1Jets modules
-            ## nedded only after first call to runBTagging(), existing sequence modified in place otherwise
-            if not btagSeq == None:
-                getattr(process, "patDefaultSequence"+postfix).replace(
-                    getattr( process,"jetTracksAssociatorAtVertex"+postfix),
-                    getattr( process,"jetTracksAssociatorAtVertex"+postfix) + btagSeq
-                    )
-
-            ## replace corresponding tags for pat jet production
-            applyPostfix(process, "patJets", postfix).trackAssociationSource = btagLabels['jta']
-            applyPostfix(process, "patJets", postfix).tagInfoSources = cms.VInputTag( *[ cms.InputTag(x) for x in btagLabels['tagInfos'] ] )
-            applyPostfix(process, "patJets", postfix).discriminatorSources = cms.VInputTag( *[ cms.InputTag(x) for x in btagLabels['jetTags']  ] )
-        else:
-            ## remove b tagging from the std sequence
-            removeIfInSequence(process,  "secondaryVertexNegativeTagInfos",  "patDefaultSequence", postfix)
-            removeIfInSequence(process,  "simpleSecondaryVertexNegativeBJetTags",  "patDefaultSequence", postfix)
-            ## switch embedding of b tagging for pat
-            ## jet production to 'False'
-            applyPostfix(process, "patJets", postfix).addBTagInfo = False
-            ## adjust output
-            if len(outputModules) > 0:
-                for outMod in outputModules:
-                    if hasattr(process,outMod):
-                        getattr(process,outMod).outputCommands.append("drop *_selectedPatJets_tagInfos_*")
-                    else:
-                        raise KeyError, "process has no OutModule named", outMod
-
-        if (doJetID):
-            jetIdLabelNew = jetIdLabel + 'JetID'
-            applyPostfix(process, "patJets", postfix).jetIDMap = cms.InputTag( jetIdLabelNew )
-        else:
-            applyPostfix(process, "patJets", postfix).addJetID = cms.bool(False)
-
-        if (jetCorrLabel!=None):
-            ## replace jet energy corrections; catch
-            ## a couple of exceptions first
-            if (jetCorrLabel == False ):
-                raise ValueError, "In switchJetCollection 'jetCorrLabel' must be set to 'None', not 'False'"
-            if (jetCorrLabel == "None"):
-                raise ValueError, "In switchJetCollection 'jetCorrLabel' must be set to 'None' (without quotes)"
-            ## check for the correct format
-            if type(jetCorrLabel) != type(('AK5Calo',['L2Relative'])):
-                raise ValueError, "In addJetCollection 'jetCorrLabel' must be 'None', or of type ('payload',['correction1', 'correction2'])"
-
-            ## switch JEC parameters to the new jet collection
-            applyPostfix(process, "patJetCorrFactors", postfix).src = jetCollection
-            switchJetCorrLevels(process, jetCorrLabel = jetCorrLabel, postfix=postfix)
-            getattr( process, "patJets" + postfix).jetCorrFactorsSource = cms.VInputTag( cms.InputTag("patJetCorrFactors" + postfix ) )
-
-            ## find out type of jet collection, switch type1MET corrections off for JPTJets
-            jetCollType = ''
-            if   ( 'CaloJets' in jetCollection.getModuleLabel() ):
-                jetCollType = 'Calo'
-            elif ( 'PFJets' in jetCollection.getModuleLabel() or jetCollection.getModuleLabel().startswith('pfNo') or jetCollection.getModuleLabel() == 'particleFlow'):
-                jetCollType = 'PF'
-            else:
-                print '============================================='
-                print 'Type1MET corrections are switched off for    '
-                print 'JPT Jets. Users are recommened to use tcMET  '
-                print 'together with JPT jets.                      '
-                print '============================================='
-                doType1MET=False
-
-            ## add a clone of the type1MET correction for the new jet collection
-            if (doType1MET):
-                ## create jet correctors for MET corrections
-                from JetMETCorrections.Configuration.JetCorrectionServicesAllAlgos_cff import ak5PFL1Fastjet, ak5PFL1Offset, ak5PFL2Relative, ak5PFL3Absolute, ak5PFResidual
-                setattr(process, jetCorrLabel[0]+'L1FastJet'   , ak5PFL1Fastjet.clone ( algorithm=jetCorrLabel[0]
-                                                                                      , srcRho=cms.InputTag('kt6PFJets','rho') ) )
-                setattr(process, jetCorrLabel[0]+'L1Offset'    , ak5PFL1Offset.clone  ( algorithm=jetCorrLabel[0] ) )
-                setattr(process, jetCorrLabel[0]+'L2Relative'  , ak5PFL2Relative.clone( algorithm=jetCorrLabel[0] ) )
-                setattr(process, jetCorrLabel[0]+'L3Absolute'  , ak5PFL3Absolute.clone( algorithm=jetCorrLabel[0] ) )
-                setattr(process, jetCorrLabel[0]+'L2L3Residual', ak5PFResidual.clone  ( algorithm=jetCorrLabel[0] ) )
-                ## combinded corrections
-                setattr(process, jetCorrLabel[0]+'CombinedCorrector', cms.ESProducer( 'JetCorrectionESChain'
-                                                                                  , correctors = cms.vstring() ) )
-                for corrLbl in jetCorrLabel[1]:
-                    if corrLbl != 'L1FastJet' and corrLbl != 'L1Offset' and corrLbl != 'L2Relative' and corrLbl != 'L3Absolute' and corrLbl != 'L2L3Residual':
-                        print '========================================='
-                        print ' Type1MET corrections are currently only  '
-                        print ' supported for the following corrections: '
-                        print '   - L1FastJet'
-                        print '   - L1Offset'
-                        print '   - L2Relative'
-                        print '   - L3Absolute'
-                        print '   - L2L3Residual'
-                        print ' But given was:'
-                        print '   -', corrLbl
-                        print '============================================='
-                        raise ValueError, 'unsupported JEC for TypeI MET correction: '+corrLbl
-                    else:
-                        getattr(process, jetCorrLabel[0]+'CombinedCorrector').correctors.append(jetCorrLabel[0]+corrLbl)
-
-                ## configuration of MET corrections
-                if jetCollType == 'Calo':
-                    getattr(process, "patMETCorrections"+postfix).remove(getattr(process,"producePFMETCorrections"+postfix))
-                    getattr(process,'caloJetMETcorr'+postfix).src          = cms.InputTag(jetCollection.getModuleLabel())
-
-                    if ('L1FastJet' in jetCorrLabel[1] or 'L1Fastjet' in jetCorrLabel[1]):
-                        getattr(process,'caloJetMETcorr'+postfix   ).offsetCorrLabel = cms.string(jetCorrLabel[0]+'L1FastJet')
-                    elif ('L1Offset' in jetCorrLabel[1]):
-                        getattr(process,'caloJetMETcorr'+postfix   ).offsetCorrLabel = cms.string(jetCorrLabel[0]+'L1Offset')
-                    else:
-                        getattr(process,'caloJetMETcorr'+postfix   ).offsetCorrLabel = cms.string('')
-                    getattr(process,'caloJetMETcorr'+postfix   ).jetCorrLabel = cms.string(jetCorrLabel[0]+'CombinedCorrector')
-
-                    getattr(process,'caloType1CorrectedMet'+postfix  ).srcType1Corrections = cms.VInputTag(
-                        cms.InputTag('caloJetMETcorr'+postfix, 'type1')
-                        )
-
-                    getattr(process,'caloType1p2CorrectedMet'+postfix).srcType1Corrections = cms.VInputTag(
-                        cms.InputTag('caloJetMETcorr'+postfix, 'type1')
-                        )
-                    getattr(process,'caloType1p2CorrectedMet'+postfix).srcUnclEnergySums = cms.VInputTag(
-                        cms.InputTag('caloJetMETcorr'+postfix, 'type2'),
-                        cms.InputTag('caloJetMETcorr'+postfix, 'offset'),
-                        cms.InputTag('muonCaloMETcorr')
-                        )
-
-                    ## add MET corrections to sequence
-                    getattr(process, 'patMETs'+ postfix).metSource = cms.InputTag('caloType1CorrectedMet'+postfix)
-                    getattr(process,'produceCaloMETCorrections'+postfix)
-                    getattr(process,"patDefaultSequence"+postfix).replace( getattr(process,'patMETs'+postfix),
-                                                                           getattr(process,'produceCaloMETCorrections'+postfix)
-                                                                           *getattr(process,'patMETs'+postfix) )
-                elif jetCollType == 'PF':
-                    getattr(process, "patMETCorrections"+postfix).remove(getattr(process,"produceCaloMETCorrections"+postfix))
-
-                    if ('L1FastJet' in jetCorrLabel[1] or 'L1Fastjet' in jetCorrLabel[1]):
-                        getattr(process,'pfJetMETcorr' +postfix).offsetCorrLabel = cms.string(jetCorrLabel[0]+'L1FastJet')
-                    elif ('L1Offset' in jetCorrLabel[1]):
-                        getattr(process,'pfJetMETcorr' +postfix).offsetCorrLabel = cms.string(jetCorrLabel[0]+'L1Offset')
-                    else:
-                        getattr(process,'pfJetMETcorr'+postfix).offsetCorrLabel = cms.string('')
-                    getattr(process,'pfJetMETcorr'+postfix).jetCorrLabel    = cms.string(jetCorrLabel[0]+'CombinedCorrector')
-
-                    getattr(process,'pfType1CorrectedMet'+postfix).applyType0Corrections = cms.bool(False)
-                    getattr(process,'pfType1CorrectedMet'+postfix).srcCHSSums = cms.VInputTag(
-                        cms.InputTag("pfchsMETcorr"+postfix,"type0")
-                        )
-                    getattr(process,'pfType1CorrectedMet'+postfix).srcType1Corrections = cms.VInputTag(
-                        cms.InputTag('pfJetMETcorr'+postfix, 'type1')
-                        )
-
-                    getattr(process,'pfType1p2CorrectedMet'+postfix).applyType0Corrections = cms.bool(False)
-                    getattr(process,'pfType1p2CorrectedMet'+postfix).srcCHSSums = cms.VInputTag(
-                        cms.InputTag("pfchsMETcorr"+postfix,"type0")
-                        )
-                    getattr(process,'pfType1p2CorrectedMet'+postfix).srcType1Corrections = cms.VInputTag(
-                        cms.InputTag('pfJetMETcorr'+postfix, 'type1')
-                        )
-                    getattr(process,'pfType1p2CorrectedMet'+postfix).srcUnclEnergySums = cms.VInputTag(
-                        cms.InputTag('pfJetMETcorr' +postfix, 'type2'),
-                        cms.InputTag('pfJetMETcorr' +postfix, 'offset'),
-                        cms.InputTag('pfCandMETcorr'+postfix)
-                        )
-
-                    ## add MET corrections to sequence
-                    getattr(process, 'patMETs'+ postfix).metSource = cms.InputTag('pfType1CorrectedMet'+postfix)
-                    getattr(process, 'patMETs'+ postfix).addMuonCorrections = False
-
-        else:
-            ## remove the jetCorrFactors from the std sequence
-            process.patJetMETCorrections.remove(process.patJetCorrFactors)
-            ## switch embedding of jetCorrFactors off
-            ## for pat jet production
-            applyPostfix(process, "patJets", postfix).addJetCorrFactors = False
-            applyPostfix(process, "patJets", postfix).jetCorrFactorsSource=[]
-
-        ## adjust output when switching to PFJets
-        if ( 'PFJets' in jetCollection.getModuleLabel() or jetCollection.getModuleLabel().startswith("pfNo") or jetCollection.getModuleLabel() == 'particleFlow' ):
-            ## in this case we can omit caloTowers and should keep pfCandidates
-            if len(outputModules) > 0:
-                for outMod in outputModules:
-                    if hasattr(process,outMod):
-                        getattr(process, outMod).outputCommands.append("keep *_selectedPatJets_pfCandidates_*")
-                        getattr(process, outMod).outputCommands.append("drop *_selectedPatJets_caloTowers_*")
-                    else:
-                        raise KeyError, "process has no OutModule named", outMod
-
-switchJetCollection=SwitchJetCollection()
-
-
-class AddJetID(ConfigToolBase):
-
-    """ Compute jet id for process
-    """
-    _label='addJetID'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'jetSrc',self._defaultValue, "", Type=cms.InputTag)
-        self.addParameter(self._defaultParameters,'jetIdTag',self._defaultValue, "Tag to append to jet id map", Type=str)
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 jetSrc     = None,
-                 jetIdTag    = None) :
-        if  jetSrc is None:
-            jetSrc=self._defaultParameters['jetSrc'].value
-        if  jetIdTag is None:
-            jetIdTag=self._defaultParameters['jetIdTag'].value
-        self.setParameter('jetSrc',jetSrc)
-        self.setParameter('jetIdTag',jetIdTag)
-        self.apply(process)
-
-    def toolCode(self, process):
-        jetSrc=self._parameters['jetSrc'].value
-        jetIdTag=self._parameters['jetIdTag'].value
-
-        jetIdLabel = jetIdTag + 'JetID'
-        print "Making new jet ID label with label " + jetIdTag
-
-        ## replace jet id sequence
-        process.load("RecoJets.JetProducers.ak5JetID_cfi")
-        setattr( process, jetIdLabel, process.ak5JetID.clone(src = jetSrc))
-        process.makePatJets.replace( process.patJets, getattr(process,jetIdLabel) + process.patJets )
-
-addJetID=AddJetID()
-
-
-class SetTagInfos(ConfigToolBase):
-
-    """ Replace tag infos for collection jetSrc
-    """
-    _label='setTagInfos'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'coll',"patJets","jet collection to set tag infos for")
-        self.addParameter(self._defaultParameters,'tagInfos',cms.vstring( ), "tag infos to set")
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 coll         = None,
-                 tagInfos     = None) :
-        if  coll is None:
-            coll=self._defaultParameters['coll'].value
-        if  tagInfos is None:
-            tagInfos=self._defaultParameters['tagInfos'].value
-        self.setParameter('coll',coll)
-        self.setParameter('tagInfos',tagInfos)
-        self.apply(process)
-
-    def toolCode(self, process):
-        coll=self._parameters['coll'].value
-        tagInfos=self._parameters['tagInfos'].value
-
-        found = False
-        newTags = cms.VInputTag()
-        iNewTags = 0
-        for k in tagInfos :
-            for j in getattr( process, coll ).tagInfoSources :
-                vv = j.value();
-                if ( vv.find(k) != -1 ):
-                    found = True
-                    newTags.append( j )
-
-        if not found:
-            raise RuntimeError,"""
-            Cannot replace tag infos in jet collection""" % (coll)
-        else :
-            getattr(process,coll).tagInfoSources = newTags
-
-setTagInfos=SetTagInfos()
-
-class SwitchJetCorrLevels(ConfigToolBase):
-
-    """ Switch from jet energy correction levels and do all necessary adjustments
-    """
-    _label='switchJetCorrLevels'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'jetCorrLabel',None, "payload and list of new jet correction labels, such as (\'AK5Calo\',[\'L2Relative\', \'L3Absolute\'])", tuple,acceptNoneValue=True )
-        self.addParameter(self._defaultParameters,'postfix',"", "postfix of default sequence")
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 jetCorrLabel = None,
-                 postfix      = None) :
-        if jetCorrLabel is None:
-            jetCorrLabel=self._defaultParameters['jetCorrLabel'].value
-        if postfix is None:
-            postfix=self._defaultParameters['postfix'].value
-
-        self.setParameter('jetCorrLabel',jetCorrLabel)
-        self.setParameter('postfix',postfix)
-
-        self.apply(process)
-
-    def toolCode(self, process):
-        jetCorrLabel=self._parameters['jetCorrLabel'].value
-        postfix=self._parameters['postfix'].value
-
-        if (jetCorrLabel!=None):
-            ## replace jet energy corrections; catch
-            ## a couple of exceptions first
-            if (jetCorrLabel == False ):
-                raise ValueError, "In switchJetCollection 'jetCorrLabel' must be set to 'None', not 'False'"
-            if (jetCorrLabel == "None"):
-                raise ValueError, "In switchJetCollection 'jetCorrLabel' must be set to 'None' (without quotes)"
-            ## check for the correct format
-            if type(jetCorrLabel) != type(('AK5Calo',['L2Relative'])):
-                raise ValueError, "In addJetCollection 'jetCorrLabel' must be 'None', or of type ('payload',['correction1', 'correction2'])"
-
-            jetCorrFactorsModule = getattr(process, "patJetCorrFactors"+postfix)
-            jetCorrFactorsModule.payload = jetCorrLabel[0]
-            jetCorrFactorsModule.levels  = jetCorrLabel[1]
-
-            ## check whether L1Offset or L1FastJet is part of levels
-            error = False
-            for x  in jetCorrLabel[1]:
-                if x == 'L1Offset':
-                    if not error:
-                        jetCorrFactorsModule.useNPV = True
-                        jetCorrFactorsModule.primaryVertices = 'offlinePrimaryVertices'
-                        ## we set this to True now as a L1 correction type should appear only once
-                        ## otherwise levels is miss configured
-                        error = True
-                    else:
-                        print 'ERROR : you miss configured the levels parameter. A L1 correction'
-                        print '        type should appear not more than once in there.'
-                        print jetCorrLabel[1]
-
-                if x == 'L1FastJet':
-                    if not error:
-                        ## re-run jet algo to compute rho and jetArea for the L1Fastjet corrections
-                        jetType=''
-                        ## find out which jetType is used (PF or Calo)
-                        if jetCorrLabel[0].count('PF') > 0:
-                            jetType='PF'
-                        elif jetCorrLabel[0].count('Calo') > 0:
-                            jetType='Calo'
-                        else:
-                            raise TypeError, "L1FastJet corrections are currently only supported for PF and Calo jets in PAT"
-                        ## configure module
-                        jetCorrFactorsModule.useRho = True
-                        jetCorrFactorsModule.rho = cms.InputTag('kt6PFJets', 'rho')
-                        ## we set this to True now as a L1 correction type should appear only once
-                        ## otherwise levels is miss configured
-                        error = True
-                    else:
-                        print 'ERROR : you miss configured the levels parameter. A L1 correction'
-                        print '        type should appear not more than once in there.'
-                        print jetCorrLabel[1]
-
-switchJetCorrLevels=SwitchJetCorrLevels()
-
-def depricatedOptionOutputModule(obj):
-    print "-------------------------------------------------------"
-    print " Error: the option 'outputModule' is not supported"
-    print "        anymore by:"
-    print "                   ", obj._label
-    print "        please use 'outputModules' now and specify the"
-    print "        names of all needed OutModules in there"
-    print "        (default: ['out'])"
-    print "-------------------------------------------------------"
-    raise KeyError, "unsupported option 'outputModule' used in '"+obj._label+"'"
diff --git a/PhysicsTools/PatAlgos/python/tools/metTools.py b/PhysicsTools/PatAlgos/python/tools/metTools.py
deleted file mode 100644
index ee0fb04..0000000
--- a/PhysicsTools/PatAlgos/python/tools/metTools.py
+++ /dev/null
@@ -1,96 +0,0 @@
-from FWCore.GuiBrowsers.ConfigToolBase import *
-
-
-class AddTcMET(ConfigToolBase):
-
-    """ Add track corrected MET collection to patEventContent
-    """
-    _label='addTcMET'    
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'postfixLabel','TC', '')
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ''
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,postfixLabel=None) :
-        if  postfixLabel is None:
-            postfixLabel=self._defaultParameters['postfixLabel'].value 
-        self.setParameter('postfixLabel',postfixLabel)
-        self.apply(process) 
-        
-    def toolCode(self, process):                
-        postfixLabel=self._parameters['postfixLabel'].value
-
-
-        ## add module as process to the default sequence
-        def addAlso (label,value):
-            existing = getattr(process, label)
-            setattr( process, label+postfixLabel, value)
-            process.patDefaultSequence.replace( existing, existing*value )        
-
-        ## clone and add a module as process to the
-        ## default sequence
-        def addClone(label,**replaceStatements):
-            new = getattr(process, label).clone(**replaceStatements)
-            addAlso(label, new)
-
-        ## addClone('corMetType1Icone5Muons', uncorMETInputTag = cms.InputTag("tcMet"))
-        addClone('patMETs', metSource = cms.InputTag("tcMet"))
-
-        ## add new met collections output to the pat summary
-        process.patCandidateSummary.candidates += [ cms.InputTag('patMETs'+postfixLabel) ]
-       
-
-addTcMET=AddTcMET()
-
-class AddPfMET(ConfigToolBase):
-    
-    """ Add pflow MET collection to patEventContent
-    """
-    _label='addPfMET'    
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'postfixLabel','PF', '')
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ''
-        
-    def getDefaultParameters(self):
-        return self._defaultParameters
-        
-    def __call__(self,process,postfixLabel=None):
-        if  postfixLabel is None:
-            postfixLabel=self._defaultParameters['postfixLabel'].value 
-        self.setParameter('postfixLabel',postfixLabel)
-        self.apply(process) 
-
-    def toolCode(self, process): 
-        postfixLabel=self._parameters['postfixLabel'].value
-
-
-        ## add module as process to the default sequence
-        def addAlso (label,value):
-            existing = getattr(process, label)
-            setattr( process, label+postfixLabel, value)
-            process.patDefaultSequence.replace( existing, existing*value )        
-            
-        ## clone and add a module as process to the
-        ## default sequence
-        def addClone(label,**replaceStatements):
-            new = getattr(process, label).clone(**replaceStatements)
-            addAlso(label, new)
-
-        ## addClone('corMetType1Icone5Muons', uncorMETInputTag = cms.InputTag("tcMet"))
-        addClone('patMETs', metSource = cms.InputTag("pfType1CorrectedMet"), addMuonCorrections = False)
-
-        ## add new met collections output to the pat summary
-        process.patCandidateSummary.candidates += [ cms.InputTag('patMETs'+postfixLabel) ]
-
-       
-addPfMET=AddPfMET()
diff --git a/PhysicsTools/PatAlgos/python/tools/muonTools.py b/PhysicsTools/PatAlgos/python/tools/muonTools.py
deleted file mode 100644
index 2d91e46..0000000
--- a/PhysicsTools/PatAlgos/python/tools/muonTools.py
+++ /dev/null
@@ -1,151 +0,0 @@
-from FWCore.GuiBrowsers.ConfigToolBase import *
-
-
-class AddMuonUserIsolation(ConfigToolBase):
-
-    """ add userIsolation to patMuon
-    """
-    _label='addMuonUserIsolation'    
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'isolationTypes',['All'],'List of predefined userIsolation types to be added; possible values are [\'Tracker\',\'Ecal\',\'Hcal\'] or just [\'All\']', allowedValues=['Tracker','Ecal','Hcal','All'])
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ''
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,isolationTypes=None) :
-        if  isolationTypes is None:
-            isolationTypes=self._defaultParameters['isolationTypes'].value 
-        self.setParameter('isolationTypes',isolationTypes)
-        self.apply(process) 
-        
-    def toolCode(self, process):                
-        isolationTypes=self._parameters['isolationTypes'].value
-
-        # key to define the parameter sets
-        isolationKey=0
-        # add pre-requisits to the muon
-        for obj in range(len(isolationTypes)):
-            if ( isolationTypes[obj] == 'Tracker' or isolationTypes[obj] == 'All'):
-                print "adding predefined userIsolation to pat::Muon for Tracker"
-                print " -> to access this information call pat::Muon::userIsolation(pat::TrackIso) in your analysis code <-"
-                isolationKey=isolationKey+1
-                
-            if ( isolationTypes[obj] == 'Ecal'    or isolationTypes[obj] == 'All'):
-                print "adding predefined userIsolation to pat::Muon for Ecal"
-                print " -> to access this information call pat::Muon::userIsolation(pat::EcalIso ) in your analysis code <-"
-                isolationKey=isolationKey+10
-                
-            if ( isolationTypes[obj] == 'Hcal'    or isolationTypes[obj] == 'All'):
-                print "adding predefined userIsolation to pat::Muon for Hcal"
-                print " -> to access this information call pat::Muon::userIsolation(pat::HcalIso ) in your analysis code <-"
-                isolationKey=isolationKey+100
-
-        # do the corresponding replacements in the pat muon
-        if ( isolationKey ==   1 ):
-            # tracker
-            process.patMuons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("muIsoDepositTk"),
-            )
-            process.patMuons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("muIsoDepositTk"),
-                deltaR = cms.double(0.3)
-                ),
-            )
-        if ( isolationKey ==  10 ):
-            # ecal
-            process.patMuons.isoDeposits = cms.PSet(
-                ecal    = cms.InputTag("muIsoDepositCalByAssociatorTowers","ecal"),
-            )
-            process.patMuons.userIsolation = cms.PSet(
-                ecal = cms.PSet(
-                src = cms.InputTag("muIsoDepositCalByAssociatorTowers","ecal"),
-                deltaR = cms.double(0.3)
-                ),
-            )
-        if ( isolationKey == 100 ):
-            # hcal
-            process.patMuons.isoDeposits = cms.PSet(
-                hcal    = cms.InputTag("muIsoDepositCalByAssociatorTowers","hcal"),
-            )
-            process.patMuons.userIsolation = cms.PSet(
-                hcal = cms.PSet(
-                src = cms.InputTag("muIsoDepositCalByAssociatorTowers","hcal"),
-                deltaR = cms.double(0.3)
-                ),
-            )
-        if ( isolationKey ==  11 ):
-            # ecal + tracker
-            process.patMuons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("muIsoDepositTk"),
-                ecal    = cms.InputTag("muIsoDepositCalByAssociatorTowers","ecal"),
-            )
-            process.patMuons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("muIsoDepositTk"),
-                deltaR = cms.double(0.3)
-                ),
-                ecal = cms.PSet(
-                src = cms.InputTag("muIsoDepositCalByAssociatorTowers","ecal"),
-                deltaR = cms.double(0.3)
-                ),
-            )
-        if ( isolationKey == 101 ):
-            # hcal + tracker
-            process.patMuons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("muIsoDepositTk"),
-                hcal    = cms.InputTag("muIsoDepositCalByAssociatorTowers","hcal"),
-            )
-            process.patMuons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("muIsoDepositTk"),
-                deltaR = cms.double(0.3)
-                ),
-                hcal = cms.PSet(
-                src = cms.InputTag("muIsoDepositCalByAssociatorTowers","hcal"),
-                deltaR = cms.double(0.3)
-                ),
-            )
-        if ( isolationKey == 110 ):
-            # hcal + ecal
-            process.patMuons.isoDeposits = cms.PSet(
-                ecal    = cms.InputTag("muIsoDepositCalByAssociatorTowers","ecal"),
-                hcal    = cms.InputTag("muIsoDepositCalByAssociatorTowers","hcal"),
-            )
-            process.patMuons.userIsolation = cms.PSet(
-                ecal = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsEcalFromHits"),
-                ),
-                hcal = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsHcalFromTowers"),
-                ),
-            )
-        if ( isolationKey == 111 ):
-            # hcal + ecal + tracker
-            process.patMuons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("muIsoDepositTk"),
-                ecal    = cms.InputTag("muIsoDepositCalByAssociatorTowers","ecal"),
-                hcal    = cms.InputTag("muIsoDepositCalByAssociatorTowers","hcal"),
-            )
-            process.patMuons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("muIsoDepositTk"),
-                deltaR = cms.double(0.3)
-                ),
-                ecal = cms.PSet(
-                src = cms.InputTag("muIsoDepositCalByAssociatorTowers","ecal"),
-                deltaR = cms.double(0.3)
-                ),
-                hcal = cms.PSet(
-                src = cms.InputTag("muIsoDepositCalByAssociatorTowers","hcal"),
-                deltaR = cms.double(0.3)
-                ),
-            )
-
-
-addMuonUserIsolation=AddMuonUserIsolation()
diff --git a/PhysicsTools/PatAlgos/python/tools/pfTools.py b/PhysicsTools/PatAlgos/python/tools/pfTools.py
deleted file mode 100644
index 39084c1..0000000
--- a/PhysicsTools/PatAlgos/python/tools/pfTools.py
+++ /dev/null
@@ -1,638 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.tools.coreTools import *
-from PhysicsTools.PatAlgos.tools.jetTools import *
-from PhysicsTools.PatAlgos.tools.tauTools import *
-
-from PhysicsTools.PatAlgos.tools.helpers import listModules, applyPostfix
-
-from copy import deepcopy
-
-#def applyPostfix(process, label, postfix):
-#    ''' If a module is in patDefaultSequence use the cloned module.
-#    Will crash if patDefaultSequence has not been cloned with 'postfix' beforehand'''
-#    result = None
-#    defaultLabels = [ m.label()[:-len(postfix)] for m in listModules( getattr(process,"patDefaultSequence"+postfix))]
-#    if label in defaultLabels:
-#        result = getattr(process, label+postfix)
-#    else:
-#        print "WARNING: called applyPostfix for module %s which is not in patDefaultSequence!"%label
-#        result = getattr(process, label)
-#    return result
-
-#def removeFromSequence(process, seq, postfix, baseSeq='patDefaultSequence'):
-#    defaultLabels = [ m.label()[:-len(postfix)] for m in listModules( getattr(process,baseSeq+postfix))]
-#    for module in listModules( seq ):
-#        if module.label() in defaultLabels:
-#            getattr(process,baseSeq+postfix).remove(getattr(process, module.label()+postfix))
-
-def warningIsolation():
-    print "WARNING: particle based isolation must be studied"
-
-from CommonTools.ParticleFlow.Tools.pfIsolation import setupPFElectronIso, setupPFMuonIso
-
-def useGsfElectrons(process, postfix, dR = "04"):
-    print "using Gsf Electrons in PF2PAT"
-    print "WARNING: this will destory the feature of top projection which solves the ambiguity between leptons and jets because"
-    print "WARNING: there will be overlap between non-PF electrons and jets even though top projection is ON!"
-    print "********************* "
-    module = applyPostfix(process,"patElectrons",postfix)
-    module.useParticleFlow = False
-    print "Building particle-based isolation for GsfElectrons in PF2PAT(PFBRECO)"
-    print "********************* "
-    adaptPFIsoElectrons( process, module, postfix+"PFIso", dR )
-    getattr(process,'patDefaultSequence'+postfix).replace( getattr(process,"patElectrons"+postfix),
-                                                   setupPFElectronIso(process, 'gsfElectrons', "PFIso", postfix, runPF2PAT=True) +
-                                                   getattr(process,"patElectrons"+postfix) )
-
-def adaptPFIsoElectrons(process,module, postfix = "PFIso", dR = "04"):
-    #FIXME: adaptPFElectrons can use this function.
-    module.isoDeposits = cms.PSet(
-        pfChargedHadrons = cms.InputTag("elPFIsoDepositCharged" + postfix),
-        pfChargedAll = cms.InputTag("elPFIsoDepositChargedAll" + postfix),
-        pfPUChargedHadrons = cms.InputTag("elPFIsoDepositPU" + postfix),
-        pfNeutralHadrons = cms.InputTag("elPFIsoDepositNeutral" + postfix),
-        pfPhotons = cms.InputTag("elPFIsoDepositGamma" + postfix)
-        )
-    module.isolationValues = cms.PSet(
-        pfChargedHadrons = cms.InputTag("elPFIsoValueCharged"+dR+"PFId"+ postfix),
-        pfChargedAll = cms.InputTag("elPFIsoValueChargedAll"+dR+"PFId"+ postfix),
-        pfPUChargedHadrons = cms.InputTag("elPFIsoValuePU"+dR+"PFId" + postfix),
-        pfNeutralHadrons = cms.InputTag("elPFIsoValueNeutral"+dR+"PFId" + postfix),
-        pfPhotons = cms.InputTag("elPFIsoValueGamma"+dR+"PFId" + postfix)
-        )
-    module.isolationValuesNoPFId = cms.PSet(
-        pfChargedHadrons = cms.InputTag("elPFIsoValueCharged"+dR+"NoPFId"+ postfix),
-        pfChargedAll = cms.InputTag("elPFIsoValueChargedAll"+dR+"NoPFId"+ postfix),
-        pfPUChargedHadrons = cms.InputTag("elPFIsoValuePU"+dR+"NoPFId" + postfix),
-        pfNeutralHadrons = cms.InputTag("elPFIsoValueNeutral"+dR+"NoPFId" + postfix),
-        pfPhotons = cms.InputTag("elPFIsoValueGamma"+dR+"NoPFId" + postfix)
-        )
-
-def adaptPFIsoMuons(process,module, postfix = "PFIso", dR = "04"):
-    #FIXME: adaptPFMuons can use this function.
-    module.isoDeposits = cms.PSet(
-        pfChargedHadrons = cms.InputTag("muPFIsoDepositCharged" + postfix),
-        pfChargedAll = cms.InputTag("muPFIsoDepositChargedAll" + postfix),
-        pfPUChargedHadrons = cms.InputTag("muPFIsoDepositPU" + postfix),
-        pfNeutralHadrons = cms.InputTag("muPFIsoDepositNeutral" + postfix),
-        pfPhotons = cms.InputTag("muPFIsoDepositGamma" + postfix)
-        )
-    module.isolationValues = cms.PSet(
-        pfChargedHadrons = cms.InputTag("muPFIsoValueCharged" + dR + postfix),
-        pfChargedAll = cms.InputTag("muPFIsoValueChargedAll" + dR + postfix),
-        pfPUChargedHadrons = cms.InputTag("muPFIsoValuePU" + dR + postfix),
-        pfNeutralHadrons = cms.InputTag("muPFIsoValueNeutral" + dR + postfix),
-        pfPhotons = cms.InputTag("muPFIsoValueGamma" + dR + postfix)
-        )
-
-def usePFIso(process, postfix = "PFIso"):
-    print "Building particle-based isolation "
-    print "***************** "
-    process.eleIsoSequence = setupPFElectronIso(process, 'gsfElectrons', postfix)
-    process.muIsoSequence = setupPFMuonIso(process, 'muons', postfix)
-    adaptPFIsoMuons( process, applyPostfix(process,"patMuons",""), postfix)
-    adaptPFIsoElectrons( process, applyPostfix(process,"patElectrons",""), postfix)
-    getattr(process,'patDefaultSequence').replace( getattr(process,"patCandidates"),
-                                                   process.pfParticleSelectionSequence +
-                                                   process.eleIsoSequence +
-                                                   process.muIsoSequence +
-                                                   getattr(process,"patCandidates") )
-
-def adaptPFMuons(process,module,postfix="" ):
-    print "Adapting PF Muons "
-    print "***************** "
-    warningIsolation()
-    print
-    module.useParticleFlow = True
-    module.pfMuonSource    = cms.InputTag("pfIsolatedMuons" + postfix)
-    module.userIsolation   = cms.PSet()
-    module.isoDeposits = cms.PSet(
-        pfChargedHadrons = cms.InputTag("muPFIsoDepositCharged" + postfix),
-        pfChargedAll = cms.InputTag("muPFIsoDepositChargedAll" + postfix),
-        pfPUChargedHadrons = cms.InputTag("muPFIsoDepositPU" + postfix),
-        pfNeutralHadrons = cms.InputTag("muPFIsoDepositNeutral" + postfix),
-        pfPhotons = cms.InputTag("muPFIsoDepositGamma" + postfix)
-        )
-    module.isolationValues = cms.PSet(
-        pfChargedHadrons = cms.InputTag("muPFIsoValueCharged04"+ postfix),
-        pfChargedAll = cms.InputTag("muPFIsoValueChargedAll04"+ postfix),
-        pfPUChargedHadrons = cms.InputTag("muPFIsoValuePU04" + postfix),
-        pfNeutralHadrons = cms.InputTag("muPFIsoValueNeutral04" + postfix),
-        pfPhotons = cms.InputTag("muPFIsoValueGamma04" + postfix)
-        )
-    # matching the pfMuons, not the standard muons.
-    applyPostfix(process,"muonMatch",postfix).src = module.pfMuonSource
-
-    print " muon source:", module.pfMuonSource
-    print " isolation  :",
-    print module.isolationValues
-    print " isodeposits: "
-    print module.isoDeposits
-    print
-
-
-def adaptPFElectrons(process,module, postfix):
-    # module.useParticleFlow = True
-    print "Adapting PF Electrons "
-    print "********************* "
-    warningIsolation()
-    print
-    module.useParticleFlow = True
-    module.pfElectronSource = cms.InputTag("pfIsolatedElectrons" + postfix)
-    module.userIsolation   = cms.PSet()
-    module.isoDeposits = cms.PSet(
-        pfChargedHadrons = cms.InputTag("elPFIsoDepositCharged" + postfix),
-        pfChargedAll = cms.InputTag("elPFIsoDepositChargedAll" + postfix),
-        pfPUChargedHadrons = cms.InputTag("elPFIsoDepositPU" + postfix),
-        pfNeutralHadrons = cms.InputTag("elPFIsoDepositNeutral" + postfix),
-        pfPhotons = cms.InputTag("elPFIsoDepositGamma" + postfix)
-        )
-    module.isolationValues = cms.PSet(
-        pfChargedHadrons = cms.InputTag("elPFIsoValueCharged04PFId"+ postfix),
-        pfChargedAll = cms.InputTag("elPFIsoValueChargedAll04PFId"+ postfix),
-        pfPUChargedHadrons = cms.InputTag("elPFIsoValuePU04PFId" + postfix),
-        pfNeutralHadrons = cms.InputTag("elPFIsoValueNeutral04PFId" + postfix),
-        pfPhotons = cms.InputTag("elPFIsoValueGamma04PFId" + postfix)
-        )
-
-    # COLIN: since we take the egamma momentum for pat Electrons, we must
-    # match the egamma electron to the gen electrons, and not the PFElectron.
-    # -> do not uncomment the line below.
-    # process.electronMatch.src = module.pfElectronSource
-    # COLIN: how do we depend on this matching choice?
-
-    print " PF electron source:", module.pfElectronSource
-    print " isolation  :"
-    print module.isolationValues
-    print " isodeposits: "
-    print module.isoDeposits
-    print
-
-    print "removing traditional isolation"
-
-    removeIfInSequence(process,  "patElectronIsolation",  "patDefaultSequence", postfix)
-
-def adaptPFPhotons(process,module):
-    raise RuntimeError, "Photons are not supported yet"
-
-from RecoTauTag.RecoTau.TauDiscriminatorTools import adaptTauDiscriminator, producerIsTauTypeMapper
-
-def reconfigurePF2PATTaus(process,
-      tauType='shrinkingConePFTau',
-      pf2patSelection=["DiscriminationByIsolation", "DiscriminationByLeadingPionPtCut"],
-      selectionDependsOn=["DiscriminationByLeadingTrackFinding"],
-      producerFromType=lambda producer: producer+"Producer",
-      postfix = ""):
-   print "patTaus will be produced from taus of type: %s that pass %s" \
-	 % (tauType, pf2patSelection)
-
-   #get baseSequence
-   baseSequence = getattr(process,"pfTausBaseSequence"+postfix)
-   #clean baseSequence from old modules
-   for oldBaseModuleName in baseSequence.moduleNames():
-       oldBaseModule = getattr(process,oldBaseModuleName)
-       baseSequence.remove(oldBaseModule)
-
-   # Get the prototype of tau producer to make, i.e. fixedConePFTauProducer
-   producerName = producerFromType(tauType)
-   # Set as the source for the pf2pat taus (pfTaus) selector
-   applyPostfix(process,"pfTaus", postfix).src = producerName+postfix
-   # Start our pf2pat taus base sequence
-   oldTauSansRefs = getattr(process,'pfTausProducerSansRefs'+postfix)
-   oldTau = getattr(process,'pfTausProducer'+postfix)
-   ## copy tau and setup it properly
-   newTauSansRefs = None
-   newTau = getattr(process,producerName).clone()
-   ## adapted to new structure in RecoTauProducers PLEASE CHECK!!!
-   if tauType=='shrinkingConePFTau':
-       newTauSansRefs = getattr(process,producerName+"SansRefs").clone()
-       newTauSansRefs.modifiers[1] = cms.PSet(
-           pfTauTagInfoSrc = cms.InputTag("pfTauTagInfoProducer"+postfix),
-           name = cms.string('pfTauTTIworkaround'+postfix),
-           plugin = cms.string('RecoTauTagInfoWorkaroundModifer')
-           )
-       newTau.modifiers[1] = newTauSansRefs.modifiers[1]
-       newTauSansRefs.piZeroSrc = "pfJetsLegacyTaNCPiZeros"+postfix
-       newTau.piZeroSrc = newTauSansRefs.piZeroSrc
-       newTauSansRefs.builders[0].pfCandSrc = oldTauSansRefs.builders[0].pfCandSrc
-       newTauSansRefs.jetRegionSrc = oldTauSansRefs.jetRegionSrc
-       newTauSansRefs.jetSrc = oldTauSansRefs.jetSrc
-   elif tauType=='fixedConePFTau':
-       newTau.piZeroSrc = "pfJetsLegacyTaNCPiZeros"+postfix
-   elif tauType=='hpsPFTau':
-       newTau = process.combinatoricRecoTaus.clone()
-       newTau.piZeroSrc="pfJetsLegacyHPSPiZeros"+postfix
-       newTau.modifiers[3] = cms.PSet(
-           pfTauTagInfoSrc = cms.InputTag("pfTauTagInfoProducer"+postfix),
-           name = cms.string('pfTauTTIworkaround'+postfix),
-           plugin = cms.string('RecoTauTagInfoWorkaroundModifer')
-           )
-       from PhysicsTools.PatAlgos.tools.helpers import cloneProcessingSnippet
-       cloneProcessingSnippet(process, process.produceHPSPFTaus, postfix)
-       massSearchReplaceParam(getattr(process,"produceHPSPFTaus"+postfix),
-                              "PFTauProducer",
-                              cms.InputTag("combinatoricRecoTaus"),
-                              cms.InputTag("pfTausBase"+postfix) )
-       massSearchReplaceParam(getattr(process,"produceHPSPFTaus"+postfix),
-                              "src",
-                              cms.InputTag("combinatoricRecoTaus"),
-                              cms.InputTag("pfTausBase"+postfix) )
-
-   newTau.builders[0].pfCandSrc = oldTau.builders[0].pfCandSrc
-   newTau.jetRegionSrc = oldTau.jetRegionSrc
-   newTau.jetSrc = oldTau.jetSrc
-
-   # replace old tau producer by new one put it into baseSequence
-   setattr(process,"pfTausBase"+postfix,newTau)
-   if tauType=='shrinkingConePFTau':
-       setattr(process,"pfTausBaseSansRefs"+postfix,newTauSansRefs)
-       getattr(process,"pfTausBase"+postfix).src = "pfTausBaseSansRefs"+postfix
-       baseSequence += getattr(process,"pfTausBaseSansRefs"+postfix)
-   baseSequence += getattr(process,"pfTausBase"+postfix)
-   if tauType=='hpsPFTau':
-       baseSequence += getattr(process,"produceHPSPFTaus"+postfix)
-   #make custom mapper to take postfix into account (could have gone with lambda of lambda but... )
-   def producerIsTauTypeMapperWithPostfix(tauProducer):
-       return lambda x: producerIsTauTypeMapper(tauProducer)+x.group(1)+postfix
-
-   def recoTauTypeMapperWithGroup(tauProducer):
-       return "%s(.*)"%recoTauTypeMapper(tauProducer)
-
-   # Get our prediscriminants
-   for predisc in selectionDependsOn:
-      # Get the prototype
-      originalName = tauType+predisc # i.e. fixedConePFTauProducerDiscriminationByLeadingTrackFinding
-      clonedName = "pfTausBase"+predisc+postfix
-      clonedDisc = getattr(process, originalName).clone()
-      # Register in our process
-      setattr(process, clonedName, clonedDisc)
-      baseSequence += getattr(process, clonedName)
-
-      tauCollectionToSelect = None
-      if tauType != 'hpsPFTau' :
-          tauCollectionToSelect = "pfTausBase"+postfix
-          #cms.InputTag(clonedDisc.PFTauProducer.value()+postfix)
-      else:
-          tauCollectionToSelect = "hpsPFTauProducer"+postfix
-      # Adapt this discriminator for the cloned prediscriminators
-      adaptTauDiscriminator(clonedDisc, newTauProducer="pfTausBase",
-                            oldTauTypeMapper=recoTauTypeMapperWithGroup,
-                            newTauTypeMapper=producerIsTauTypeMapperWithPostfix,
-                            preservePFTauProducer=True)
-      clonedDisc.PFTauProducer = tauCollectionToSelect
-
-   # Reconfigure the pf2pat PFTau selector discrimination sources
-   applyPostfix(process,"pfTaus", postfix).discriminators = cms.VPSet()
-   for selection in pf2patSelection:
-      # Get our discriminator that will be used to select pfTaus
-      originalName = tauType+selection
-      clonedName = "pfTausBase"+selection+postfix
-      clonedDisc = getattr(process, originalName).clone()
-      # Register in our process
-      setattr(process, clonedName, clonedDisc)
-
-      tauCollectionToSelect = None
-
-      if tauType != 'hpsPFTau' :
-          tauCollectionToSelect = cms.InputTag("pfTausBase"+postfix)
-          #cms.InputTag(clonedDisc.PFTauProducer.value()+postfix)
-      else:
-          tauCollectionToSelect = cms.InputTag("hpsPFTauProducer"+postfix)
-      #Adapt our cloned discriminator to the new prediscriminants
-      adaptTauDiscriminator(clonedDisc, newTauProducer="pfTausBase",
-                            oldTauTypeMapper=recoTauTypeMapperWithGroup,
-                            newTauTypeMapper=producerIsTauTypeMapperWithPostfix,
-                            preservePFTauProducer=True)
-      clonedDisc.PFTauProducer = tauCollectionToSelect
-      baseSequence += clonedDisc
-      # Add this selection to our pfTau selectors
-      applyPostfix(process,"pfTaus", postfix).discriminators.append(cms.PSet(
-         discriminator=cms.InputTag(clonedName), selectionCut=cms.double(0.5)))
-      # Set the input of the final selector.
-      if tauType != 'hpsPFTau':
-          applyPostfix(process,"pfTaus", postfix).src = "pfTausBase"+postfix
-      else:
-          # If we are using HPS taus, we need to take the output of the clenaed
-          # collection
-          applyPostfix(process,"pfTaus", postfix).src = "hpsPFTauProducer"+postfix
-
-
-
-def adaptPFTaus(process,tauType = 'shrinkingConePFTau', postfix = ""):
-    # Set up the collection used as a preselection to use this tau type
-    if tauType != 'hpsPFTau' :
-        reconfigurePF2PATTaus(process, tauType, postfix=postfix)
-    else:
-        reconfigurePF2PATTaus(process, tauType,
-                              ["DiscriminationByLooseCombinedIsolationDBSumPtCorr"],
-                              ["DiscriminationByDecayModeFinding"],
-                              postfix=postfix)
-    # new default use unselected taus (selected only for jet cleaning)
-    if tauType != 'hpsPFTau' :
-        applyPostfix(process,"patTaus", postfix).tauSource = cms.InputTag("pfTausBase"+postfix)
-    else:
-        applyPostfix(process,"patTaus", postfix).tauSource = cms.InputTag("hpsPFTauProducer"+postfix)
-    # to use preselected collection (old default) uncomment line below
-    #applyPostfix(process,"patTaus", postfix).tauSource = cms.InputTag("pfTaus"+postfix)
-
-
-    redoPFTauDiscriminators(process,
-                            cms.InputTag(tauType+'Producer'),
-                            applyPostfix(process,"patTaus", postfix).tauSource,
-                            tauType, postfix=postfix)
-
-    switchToPFTauByType(process, pfTauType=tauType,
-                        pfTauLabelNew=applyPostfix(process,"patTaus", postfix).tauSource,
-                        pfTauLabelOld=cms.InputTag(tauType+'Producer'),
-                        postfix=postfix)
-
-    applyPostfix(process,"makePatTaus", postfix).remove(
-        applyPostfix(process,"patPFCandidateIsoDepositSelection", postfix)
-        )
-
-#helper function for PAT on PF2PAT sample
-def tauTypeInPF2PAT(process,tauType='shrinkingConePFTau', postfix = ""):
-    process.load("CommonTools.ParticleFlow.pfTaus_cff")
-    applyPostfix(process, "pfTaus",postfix).src = cms.InputTag(tauType+'Producer'+postfix)
-
-
-def addPFCandidates(process,src,patLabel='PFParticles',cut="",postfix=""):
-    from PhysicsTools.PatAlgos.producersLayer1.pfParticleProducer_cfi import patPFParticles
-    # make modules
-    producer = patPFParticles.clone(pfCandidateSource = src)
-    filter   = cms.EDFilter("PATPFParticleSelector",
-                    src = cms.InputTag("pat" + patLabel),
-                    cut = cms.string(cut))
-    counter  = cms.EDFilter("PATCandViewCountFilter",
-                    minNumber = cms.uint32(0),
-                    maxNumber = cms.uint32(999999),
-                    src       = cms.InputTag("pat" + patLabel))
-    # add modules to process
-    setattr(process, "pat"         + patLabel, producer)
-    setattr(process, "selectedPat" + patLabel, filter)
-    setattr(process, "countPat"    + patLabel, counter)
-    # insert into sequence
-    getattr(process, "patDefaultSequence"+postfix).replace(
-        applyPostfix(process, "patCandidateSummary", postfix),
-        producer+applyPostfix(process, "patCandidateSummary", postfix)
-    )
-    getattr(process, "patDefaultSequence"+postfix).replace(
-        applyPostfix(process, "selectedPatCandidateSummary", postfix),
-        filter+applyPostfix(process, "selectedPatCandidateSummary", postfix)
-    )
-    index = len( applyPostfix( process, "patDefaultSequence", postfix ).moduleNames() )
-    applyPostfix( process, "patDefaultSequence", postfix ).insert( index, counter )
-    # summary tables
-    applyPostfix(process, "patCandidateSummary", postfix).candidates.append(cms.InputTag('pat' + patLabel))
-    applyPostfix(process, "selectedPatCandidateSummary", postfix).candidates.append(cms.InputTag('selectedPat' + patLabel))
-
-
-def switchToPFMET(process,input=cms.InputTag('pfMET'), type1=False, postfix=""):
-    print 'MET: using ', input
-    if( not type1 ):
-        oldMETSource = applyPostfix(process, "patMETs",postfix).metSource
-        applyPostfix(process, "patMETs",postfix).metSource = input
-        applyPostfix(process, "patMETs",postfix).addMuonCorrections = False
-        getattr(process, "patDefaultSequence"+postfix).remove(applyPostfix(process, "patMETCorrections",postfix))
-    else:
-        # type1 corrected MET
-        # name of corrected MET hardcoded in PAT and meaningless
-        print 'Apply TypeI corrections for MET'
-        getattr(process, "patDefaultSequence"+postfix).remove(applyPostfix(process, "makePatMETs",postfix))
-        jecLabel = getattr(process,'patJetCorrFactors'+postfix).levels
-
-        if not hasattr(process,'producePatPFMETCorrections'):
-            process.load("PhysicsTools.PatUtils.patPFMETCorrections_cff")
-        #here add to the current path and give proper postfix
-        if not hasattr(process,'producePatPFMETCorrections'+postfix):
-            cloneProcessingSnippet(process,process.producePatPFMETCorrections,postfix)
-        
-        getattr(process,'patPFMet'+postfix).metSource = cms.InputTag('pfMET'+postfix)
-
-        getattr(process,'selectedPatJetsForMETtype1p2Corr'+postfix).src = cms.InputTag('selectedPatJets'+postfix)
-        getattr(process,'selectedPatJetsForMETtype2Corr'+postfix).src   = cms.InputTag('selectedPatJets'+postfix)
-
-        getattr(process,'pfCandMETcorr'+postfix).src = cms.InputTag('pfNoJet'+postfix)
-
-        getattr(process,'patPFJetMETtype1p2Corr'+postfix).offsetCorrLabel = cms.string(jecLabel[0])
-        getattr(process,'patPFJetMETtype1p2Corr'+postfix).jetCorrLabel = cms.string(jecLabel[-1])
-        getattr(process,'patPFJetMETtype1p2Corr'+postfix).type1JetPtThreshold = cms.double(10.0)
-        getattr(process,'patPFJetMETtype1p2Corr'+postfix).skipEM    = cms.bool(False)
-        getattr(process,'patPFJetMETtype1p2Corr'+postfix).skipMuons = cms.bool(False)
-
-        getattr(process,'patPFJetMETtype2Corr'+postfix).offsetCorrLabel = cms.string(jecLabel[0])
-        getattr(process,'patPFJetMETtype2Corr'+postfix).jetCorrLabel = cms.string(jecLabel[-1])
-        getattr(process,'patPFJetMETtype2Corr'+postfix).type1JetPtThreshold = cms.double(10.0)
-        getattr(process,'patPFJetMETtype2Corr'+postfix).skipEM    = cms.bool(False)
-        getattr(process,'patPFJetMETtype2Corr'+postfix).skipMuons = cms.bool(False)
-        
-        getattr(process,'patType1CorrectedPFMet'+postfix).srcType1Corrections = cms.VInputTag(
-            cms.InputTag("patPFJetMETtype1p2Corr"+postfix,"type1"),
-            #cms.InputTag("patPFMETtype0Corr"+postfix),
-            )
-        getattr(process,'patType1p2CorrectedPFMet'+postfix).srcType1Corrections = cms.VInputTag(
-            cms.InputTag("patPFJetMETtype1p2Corr"+postfix,"type1"),
-            #cms.InputTag("patPFMETtype0Corr"+postfix),
-            )
-        
-        getattr(process,'patMETs'+postfix).metSource = 'patType1CorrectedPFMet'+postfix
-
-        getattr(process,"patDefaultSequence"+postfix).replace( getattr(process,'selectedPatJets'+postfix),
-                                                               getattr(process,'selectedPatJets'+postfix)
-                                                               *getattr(process,'producePatPFMETCorrections'+postfix)
-                                                               *getattr(process,'patMETs'+postfix)
-                                                              )
-
-def switchToPFJets(process, input=cms.InputTag('pfNoTau'), algo='AK5', postfix = "", jetCorrections=('AK5PFchs', ['L1FastJet','L2Relative', 'L3Absolute']), type1=False, outputModules=['out']):
-
-    print "Switching to PFJets,  ", algo
-    print "************************ "
-    print "input collection: ", input
-
-    if( algo == 'IC5' ):
-        genJetCollection = cms.InputTag('iterativeCone5GenJetsNoNu')
-    elif algo == 'AK5':
-        genJetCollection = cms.InputTag('ak5GenJetsNoNu')
-    elif algo == 'AK7':
-        genJetCollection = cms.InputTag('ak7GenJetsNoNu')
-    else:
-        print 'bad jet algorithm:', algo, '! for now, only IC5, AK5 and AK7 are allowed. If you need other algorithms, please contact Colin'
-        sys.exit(1)
-
-    # changing the jet collection in PF2PAT:
-    from CommonTools.ParticleFlow.Tools.jetTools import jetAlgo
-    inputCollection = getattr(process,"pfJets"+postfix).src
-    setattr(process,"pfJets"+postfix,jetAlgo(algo)) # problem for cfgBrowser
-    getattr(process,"pfJets"+postfix).src = inputCollection
-    inputJetCorrLabel=jetCorrections
-    switchJetCollection(process,
-                        input,
-                        jetIdLabel = algo,
-                        doJTA=True,
-                        doBTagging=True,
-                        jetCorrLabel=inputJetCorrLabel,
-                        doType1MET=type1,
-                        genJetCollection = genJetCollection,
-                        doJetID = True,
-			postfix = postfix,
-                        outputModules = outputModules
-                        )
-    # check whether L1FastJet is in the list of correction levels or not
-    applyPostfix(process, "patJetCorrFactors", postfix).useRho = False
-    for corr in inputJetCorrLabel[1]:
-        if corr == 'L1FastJet':
-            applyPostfix(process, "patJetCorrFactors", postfix).useRho = True
-            applyPostfix(process, "pfJets", postfix).doAreaFastjet = True
-            # do correct treatment for TypeI MET corrections
-            if type1:
-                for mod in getattr(process,'patPF2PATSequence'+postfix).moduleNames():
-                    if mod.startswith("kt6") and mod.endswith("Jets"+postfix):
-                        prefix = mod.replace(postfix,'')
-                        prefix = prefix.replace('kt6PFJets','')
-                        prefix = prefix.replace('kt6CaloJets','')
-                        prefix = getattr(process,'patJetCorrFactors'+prefix+postfix).payload.pythonValue().replace("'","")
-                        for essource in process.es_sources_().keys():
-                            if essource == prefix+'L1FastJet':
-                                setattr(process,essource+postfix,getattr(process,essource).clone(srcRho=cms.InputTag(mod,'rho')))
-                                setattr(process,prefix+'CombinedCorrector'+postfix,getattr(process,prefix+'CombinedCorrector').clone())
-                                getattr(process,prefix+'CorMet'+postfix).corrector = prefix+'CombinedCorrector'+postfix
-                                for cor in getattr(process,prefix+'CombinedCorrector'+postfix).correctors:
-                                    if cor == essource:
-                                        idx = getattr(process,prefix+'CombinedCorrector'+postfix).correctors.index(essource);
-                                        getattr(process,prefix+'CombinedCorrector'+postfix).correctors[idx] = essource+postfix
-
-    applyPostfix(process, "patJets", postfix).embedCaloTowers   = False
-    applyPostfix(process, "patJets", postfix).embedPFCandidates = True
-
-#-- Remove MC dependence ------------------------------------------------------
-def removeMCMatchingPF2PAT( process, postfix="", outputModules=['out'] ):
-    from PhysicsTools.PatAlgos.tools.coreTools import removeMCMatching
-    removeIfInSequence(process, "genForPF2PATSequence", "patDefaultSequence", postfix)
-    removeMCMatching(process, names=['All'], postfix=postfix, outputModules=outputModules)
-
-
-def adaptPVs(process, pvCollection=cms.InputTag('offlinePrimaryVertices'), postfix=''):
-
-    print "Switching PV collection for PF2PAT:", pvCollection
-    print "***********************************"
-
-    # PV sources to be exchanged:
-    pvExchange = ['Vertices','vertices','pvSrc','primaryVertices','srcPVs']
-    # PV sources NOT to be exchanged:
-    #noPvExchange = ['src','PVProducer','primaryVertexSrc','vertexSrc','primaryVertex']
-
-    # find out all added jet collections (they don't belong to PF2PAT)
-    interPostfixes = []
-    for m in getattr(process,'patPF2PATSequence'+postfix).moduleNames():
-        if m.startswith('patJets') and m.endswith(postfix) and not len(m)==len('patJets')+len(postfix):
-            interPostfix = m.replace('patJets','')
-            interPostfix = interPostfix.replace(postfix,'')
-            interPostfixes.append(interPostfix)
-
-    # exchange the primary vertex source of all relevant modules
-    for m in getattr(process,'patPF2PATSequence'+postfix).moduleNames():
-        modName = m.replace(postfix,'')
-        # only if the module has a source with a relevant name
-        for namePvSrc in pvExchange:
-            if hasattr(getattr(process,m),namePvSrc):
-                # only if the module is not coming from an added jet collection
-                interPostFixFlag = False
-                for pfix in interPostfixes:
-                    if modName.endswith(pfix):
-                        interPostFixFlag = True
-                        break
-                if not interPostFixFlag:
-                    setattr(getattr(process,m),namePvSrc,deepcopy(pvCollection))
-
-
-def usePF2PAT(process, runPF2PAT=True, jetAlgo='AK5', runOnMC=True, postfix="", jetCorrections=('AK5PFchs', ['L1FastJet','L2Relative','L3Absolute']), pvCollection=cms.InputTag('offlinePrimaryVertices'), typeIMetCorrections=False, outputModules=['out']):
-    # PLEASE DO NOT CLOBBER THIS FUNCTION WITH CODE SPECIFIC TO A GIVEN PHYSICS OBJECT.
-    # CREATE ADDITIONAL FUNCTIONS IF NEEDED.
-
-    """Switch PAT to use PF2PAT instead of AOD sources. if 'runPF2PAT' is true, we'll also add PF2PAT in front of the PAT sequence"""
-
-    # -------- CORE ---------------
-    if runPF2PAT:
-        process.load("CommonTools.ParticleFlow.PF2PAT_cff")
-        #add Pf2PAT *before* cloning so that overlapping modules are cloned too
-        #process.patDefaultSequence.replace( process.patCandidates, process.PF2PAT+process.patCandidates)
-        process.patPF2PATSequence = cms.Sequence( process.PF2PAT + process.patDefaultSequence)
-    else:
-        process.patPF2PATSequence = cms.Sequence( process.patDefaultSequence )
-
-    if not postfix == "":
-        from PhysicsTools.PatAlgos.tools.helpers import cloneProcessingSnippet
-        cloneProcessingSnippet(process, process.patPF2PATSequence, postfix)
-        #delete everything pat PF2PAT modules! if you want to test the postfixing for completeness
-        #from PhysicsTools.PatAlgos.tools.helpers import listModules,listSequences
-        #for module in listModules(process.patDefaultSequence):
-        #    if not module.label() is None: process.__delattr__(module.label())
-        #for sequence in listSequences(process.patDefaultSequence):
-        #    if not sequence.label() is None: process.__delattr__(sequence.label())
-        #del process.patDefaultSequence
-
-    removeCleaning(process, postfix=postfix, outputModules=outputModules)
-
-    # -------- OBJECTS ------------
-    # Muons
-    adaptPFMuons(process,
-                 applyPostfix(process,"patMuons",postfix),
-                 postfix)
-
-    # Electrons
-    adaptPFElectrons(process,
-                     applyPostfix(process,"patElectrons",postfix),
-                     postfix)
-
-    # Photons
-    print "Temporarily switching off photons completely"
-
-    removeSpecificPATObjects(process,names=['Photons'],outputModules=outputModules,postfix=postfix)
-    removeIfInSequence(process,"patPhotonIsolation","patDefaultSequence",postfix)
-
-    # Jets
-    if runOnMC :
-        switchToPFJets( process, cms.InputTag('pfNoTau'+postfix), jetAlgo, postfix=postfix,
-                        jetCorrections=jetCorrections, type1=typeIMetCorrections, outputModules=outputModules )
-        applyPostfix(process,"patDefaultSequence",postfix).replace(
-            applyPostfix(process,"patJetGenJetMatch",postfix),
-            getattr(process,"genForPF2PATSequence") *
-            applyPostfix(process,"patJetGenJetMatch",postfix)
-            )
-    else :
-        if not 'L2L3Residual' in jetCorrections[1]:
-            print '#################################################'
-            print 'WARNING! Not using L2L3Residual but this is data.'
-            print 'If this is okay with you, disregard this message.'
-            print '#################################################'
-        switchToPFJets( process, cms.InputTag('pfNoTau'+postfix), jetAlgo, postfix=postfix,
-                        jetCorrections=jetCorrections, type1=typeIMetCorrections, outputModules=outputModules )
-
-    # Taus
-    #adaptPFTaus( process, tauType='shrinkingConePFTau', postfix=postfix )
-    #adaptPFTaus( process, tauType='fixedConePFTau', postfix=postfix )
-    adaptPFTaus( process, tauType='hpsPFTau', postfix=postfix )
-
-    # MET
-    switchToPFMET(process, cms.InputTag('pfMET'+postfix), type1=typeIMetCorrections, postfix=postfix)
-    if not runOnMC :
-        if hasattr(process,'patPFMet'+postfix):
-            getattr(process,'patPFMet'+postfix).addGenMET = cms.bool(False)
-
-    # Unmasked PFCandidates
-    addPFCandidates(process,cms.InputTag('pfNoJet'+postfix),patLabel='PFParticles'+postfix,cut="",postfix=postfix)
-
-    # adapt primary vertex collection
-    adaptPVs(process, pvCollection=pvCollection, postfix=postfix)
-
-    if runOnMC:
-        process.load("CommonTools.ParticleFlow.genForPF2PAT_cff")
-        getattr(process, "patDefaultSequence"+postfix).replace(
-            applyPostfix(process,"patCandidates",postfix),
-            process.genForPF2PATSequence+applyPostfix(process,"patCandidates",postfix)
-            )
-    else:
-        removeMCMatchingPF2PAT(process,postfix=postfix,outputModules=outputModules)
-
-    print "Done: PF2PAT interfaced to PAT, postfix=", postfix
diff --git a/PhysicsTools/PatAlgos/python/tools/photonTools.py b/PhysicsTools/PatAlgos/python/tools/photonTools.py
deleted file mode 100644
index 7d90d7b..0000000
--- a/PhysicsTools/PatAlgos/python/tools/photonTools.py
+++ /dev/null
@@ -1,155 +0,0 @@
-from FWCore.GuiBrowsers.ConfigToolBase import *
-
-class AddPhotonUserIsolation(ConfigToolBase):
-
-    """ add userIsolation to patPhoton
-    """
-    _label='addPhotonUserIsolation'    
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'isolationTypes',['All'],'List of predefined userIsolation types to be added; possible values are [\'Tracker\',\'Ecal\',\'Hcal\'] or just [\'All\']', allowedValues=['Tracker','Ecal','Hcal','All'])
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ''
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,isolationTypes=None) :
-        if  isolationTypes is None:
-            isolationTypes=self._defaultParameters['isolationTypes'].value 
-        self.setParameter('isolationTypes',isolationTypes)
-        self.apply(process) 
-        
-    def toolCode(self, process):                
-        isolationTypes=self._parameters['isolationTypes'].value
-
-        from RecoEgamma.EgammaIsolationAlgos.gamIsoDeposits_cff import gamIsoDepositTk, gamIsoDepositEcalFromHits, gamIsoDepositHcalFromTowers
-        from RecoEgamma.EgammaIsolationAlgos.gamIsoFromDepsModules_cff import gamIsoFromDepsTk, gamIsoFromDepsEcalFromHits, gamIsoFromDepsHcalFromTowers
-        
-        gamIsoDepositEcalFromHits.ExtractorPSet.barrelEcalHits = cms.InputTag("reducedEcalRecHitsEB")
-        gamIsoDepositEcalFromHits.ExtractorPSet.endcapEcalHits = cms.InputTag("reducedEcalRecHitsEE")
-        
-        # key to define the parameter sets
-        isolationKey=0
-        # add pre-requisits to the photon
-        for obj in range(len(isolationTypes)):
-            if ( isolationTypes[obj] == 'Tracker' or isolationTypes[obj] == 'All'):
-                print "adding predefined userIsolation to pat::Photon for Tracker"
-                print " -> to access this information call pat::Photon::userIsolation(pat::TrackIso) in your analysis code <-"
-                isolationKey=isolationKey+1
-                from PhysicsTools.PatAlgos.recoLayer0.photonIsolation_cff import patPhotonTrackIsolation
-                process.patPhotonTrackIsolation
-                process.patDefaultSequence.replace( process.patPhotons, process.patPhotonTrackIsolation*process.patPhotons )
-                
-            if ( isolationTypes[obj] == 'Ecal'    or isolationTypes[obj] == 'All'):
-                print "adding predefined userIsolation to pat::Photon for Ecal"
-                print " -> to access this information call pat::Photon::userIsolation(pat::EcalIso ) in your analysis code <-"
-                isolationKey=isolationKey+10
-                from PhysicsTools.PatAlgos.recoLayer0.photonIsolation_cff import patPhotonEcalIsolation
-                process.patPhotonEcalIsolation            
-                process.patDefaultSequence.replace( process.patPhotons, process.patPhotonEcalIsolation*process.patPhotons )
-                
-            if ( isolationTypes[obj] == 'Hcal'    or isolationTypes[obj] == 'All'):
-                print "adding predefined userIsolation to pat::Photon for Hcal"
-                print " -> to access this information call pat::Photon::userIsolation(pat::HcalIso ) in your analysis code <-"
-                isolationKey=isolationKey+100
-                from PhysicsTools.PatAlgos.recoLayer0.photonIsolation_cff import patPhotonHcalIsolation            
-                process.patPhotonHcalIsolation = patPhotonHcalIsolation
-                process.patDefaultSequence.replace( process.patPhotons, process.patPhotonHcalIsolation*process.patPhotons )  
-                
-        # do the corresponding replacements in the pat photon
-        if ( isolationKey ==   1 ):
-            # tracker
-            process.patPhotons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("gamIsoDepositTk"),
-            )
-            process.patPhotons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsTk"),
-                ),
-            )
-        if ( isolationKey ==  10 ):
-            # ecal
-            process.patPhotons.isoDeposits = cms.PSet(
-                ecal    = cms.InputTag("gamIsoDepositEcalFromHits"),
-            )
-            process.patPhotons.userIsolation = cms.PSet(
-                ecal = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsEcalFromHits"),
-                ),
-            )
-        if ( isolationKey == 100 ):
-            # hcal
-            process.patPhotons.isoDeposits = cms.PSet(
-                hcal    = cms.InputTag("gamIsoDepositHcalFromTowers"),
-            )
-            process.patPhotons.userIsolation = cms.PSet(
-                hcal = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsHcalFromTowers"),
-                ),
-            )
-        if ( isolationKey ==  11 ):
-            # ecal + tracker
-            process.patPhotons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("gamIsoDepositTk"),
-                ecal    = cms.InputTag("gamIsoDepositEcalFromHits"),
-            )
-            process.patPhotons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsTk"),
-                ),
-                ecal = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsEcalFromHits"),
-                ),
-            )
-        if ( isolationKey == 101 ):
-            # hcal + tracker
-            process.patPhotons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("gamIsoDepositTk"),
-                hcal    = cms.InputTag("gamIsoDepositHcalFromTowers"),
-            )
-            process.patPhotons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsTk"),
-                ),
-                hcal = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsHcalFromTowers"),
-                ),
-            )
-        if ( isolationKey == 110 ):
-            # hcal + ecal
-            process.patPhotons.isoDeposits = cms.PSet(
-                ecal    = cms.InputTag("gamIsoDepositEcalFromHits"),
-                hcal    = cms.InputTag("gamIsoDepositHcalFromTowers"),
-            )
-            process.patPhotons.userIsolation = cms.PSet(
-                ecal = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsEcalFromHits"),
-                ),
-                hcal = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsHcalFromTowers"),
-                ),
-            )
-        if ( isolationKey == 111 ):
-            # hcal + ecal + tracker
-            process.patPhotons.isoDeposits = cms.PSet(
-                tracker = cms.InputTag("gamIsoDepositTk"),
-                ecal    = cms.InputTag("gamIsoDepositEcalFromHits"),
-                hcal    = cms.InputTag("gamIsoDepositHcalFromTowers"),
-            )
-            process.patPhotons.userIsolation = cms.PSet(
-                tracker = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsTk"),
-                ),
-                ecal = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsEcalFromHits"),
-                ),
-                hcal = cms.PSet(
-                src = cms.InputTag("gamIsoFromDepsHcalFromTowers"),
-                ),
-            )
-
-
-addPhotonUserIsolation=AddPhotonUserIsolation()
diff --git a/PhysicsTools/PatAlgos/python/tools/tauTools.py b/PhysicsTools/PatAlgos/python/tools/tauTools.py
deleted file mode 100644
index 2bb5f71..0000000
--- a/PhysicsTools/PatAlgos/python/tools/tauTools.py
+++ /dev/null
@@ -1,614 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.tools.coreTools import *
-from FWCore.GuiBrowsers.ConfigToolBase import *
-from PhysicsTools.PatAlgos.tools.helpers import applyPostfix
-from PhysicsTools.PatAlgos.tools.helpers import cloneProcessingSnippet
-from RecoTauTag.RecoTau.TauDiscriminatorTools import *
-
-def redoPFTauDiscriminators(process,
-                            oldPFTauLabel = cms.InputTag('hpsPFTauProducer'),
-                            newPFTauLabel = cms.InputTag('hpsPFTauProducer'),
-                            tauType = 'hpsPFTau', postfix = ""):
-    print 'Tau discriminators: ', oldPFTauLabel, '->', newPFTauLabel
-    print 'Tau type: ', tauType
-    #oldPFTauLabel.setModuleLabel(oldPFTauLabel.getModuleLabel()+postfix)
-    tauSrc = 'PFTauProducer'
-
-    tauDiscriminationSequence = None
-
-    if tauType == 'hpsPFTau':
-        if hasattr(process,"updateHPSPFTaus"+postfix):
-            tauDiscriminationSequence = getattr(process,"patHPSPFTauDiscriminationUpdate"+postfix)
-        else:
-            #        remove producers
-            process.patHPSPFTauDiscrimination = process.produceAndDiscriminateHPSPFTaus.copy()
-            for iname in process.patHPSPFTauDiscrimination.moduleNames():
-                if not (iname.find("DiscriminationBy")>-1 or iname.find("DiscriminationAgainst")>-1 or iname.find("kt6PFJetsForRhoComputationVoronoi")>-1):
-                    process.patHPSPFTauDiscrimination.remove(getattr(process,iname) )
-            tauDiscriminationSequence = cloneProcessingSnippet(process, process.patHPSPFTauDiscrimination, postfix)
-
-    elif tauType == 'hpsTancTaus': #to be checked if correct
-        process.patHPSTaNCPFTauDiscrimination = process.hpsTancTauInitialSequence.copy()
-        process.patHPSTaNCPFTauDiscrimination *= process.hpsTancTauDiscriminantSequence
-        # remove producers
-        for iname in process.patHPSTaNCPFTauDiscrimination.moduleNames():
-            if not (iname.find("DiscriminationBy")>-1 or iname.find("DiscriminationAgainst")>-1):
-                process.patHPSTaNCPFTauDiscrimination.remove(getattr(process,iname) )
-        tauDiscriminationSequence = cloneProcessingSnippet(process, process.patHPSTaNCPFTauDiscrimination, postfix)
-
-    elif tauType == 'fixedConePFTau':
-        process.patFixedConePFTauDiscrimination = process.produceAndDiscriminateFixedConePFTaus.copy()
-        # remove producers
-        for iname in process.patFixedConePFTauDiscrimination.moduleNames():
-            if not (iname.find("DiscriminationBy")>-1 or iname.find("DiscriminationAgainst")>-1):
-                process.patFixedConePFTauDiscrimination.remove(getattr(process,iname) )
-        tauDiscriminationSequence =  cloneProcessingSnippet(process, process.patFixedConePFTauDiscrimination, postfix)
-
-    elif tauType == 'shrinkingConePFTau': #shr cone with TaNC
-        process.patShrinkingConePFTauDiscrimination = process.produceAndDiscriminateShrinkingConePFTaus.copy()
-        process.patShrinkingConePFTauDiscrimination *= process.produceShrinkingConeDiscriminationByTauNeuralClassifier
-        # remove producers
-        for iname in process.patShrinkingConePFTauDiscrimination.moduleNames():
-            if not (iname.find("DiscriminationBy")>-1 or iname.find("DiscriminationAgainst")>-1):
-                process.patShrinkingConePFTauDiscrimination.remove(getattr(process,iname) )
-        tauDiscriminationSequence =  cloneProcessingSnippet(process, process.patShrinkingConePFTauDiscrimination, postfix)
-
-    elif tauType == 'caloTau':
-        # fill calo sequence by discriminants
-        process.patCaloTauDiscrimination = process.tautagging.copy()
-        # remove producers
-        for iname in process.patCaloTauDiscrimination.moduleNames():
-            if not (iname.find("DiscriminationBy")>-1 or iname.find("DiscriminationAgainst")>-1):
-                process.patCaloTauDiscrimination.remove(getattr(process,iname) )
-        tauDiscriminationSequence =  cloneProcessingSnippet(process, process.patCaloTauDiscrimination, postfix)
-        tauSrc = 'CaloTauProducer'
-    else:
-        raise StandardError, "Unkown tauType: '%s'"%tauType
-
-    if not hasattr(process,"updateHPSPFTaus"+postfix):
-        applyPostfix(process,"patDefaultSequence",postfix).replace(
-            applyPostfix(process,"patTaus",postfix),
-            tauDiscriminationSequence*applyPostfix(process,"patTaus",postfix)
-            )
-
-    massSearchReplaceParam(tauDiscriminationSequence, tauSrc, oldPFTauLabel, newPFTauLabel)
-
-# switch to CaloTau collection
-def switchToCaloTau(process,
-                    pfTauLabelOld = cms.InputTag('hpsPFTauProducer'),
-                    pfTauLabelNew = cms.InputTag('caloRecoTauProducer'),
-                    patTauLabel = "",
-                    postfix = ""):
-    print ' Taus: ', pfTauLabelOld, '->', pfTauLabelNew
-
-    caloTauLabel = pfTauLabelNew
-    applyPostfix(process, "tauMatch" + patTauLabel, postfix).src = caloTauLabel
-    applyPostfix(process, "tauGenJetMatch"+ patTauLabel, postfix).src = caloTauLabel
-
-    applyPostfix(process, "patTaus" + patTauLabel, postfix).tauSource = caloTauLabel
-    applyPostfix(process, "patTaus" + patTauLabel, postfix).tauIDSources = _buildIDSourcePSet('caloRecoTau', classicTauIDSources, postfix)
-#    applyPostfix(process, "patTaus" + patTauLabel, postfix).tauIDSources = cms.PSet(
-#        leadingTrackFinding = cms.InputTag("caloRecoTauDiscriminationByLeadingTrackFinding" + postfix),
-#        leadingTrackPtCut   = cms.InputTag("caloRecoTauDiscriminationByLeadingTrackPtCut" + postfix),
-#        trackIsolation      = cms.InputTag("caloRecoTauDiscriminationByTrackIsolation" + postfix),
-#        ecalIsolation       = cms.InputTag("caloRecoTauDiscriminationByECALIsolation" + postfix),
-#        byIsolation         = cms.InputTag("caloRecoTauDiscriminationByIsolation" + postfix),
-#        againstElectron     = cms.InputTag("caloRecoTauDiscriminationAgainstElectron" + postfix),
-#        againstMuon         = cms.InputTag("caloRecoTauDiscriminationAgainstMuon" + postfix)
-#    )
-    ## Isolation is somewhat an issue, so we start just by turning it off
-    print "NO PF Isolation will be computed for CaloTau (this could be improved later)"
-    applyPostfix(process, "patTaus" + patTauLabel, postfix).isolation   = cms.PSet()
-    applyPostfix(process, "patTaus" + patTauLabel, postfix).isoDeposits = cms.PSet()
-    applyPostfix(process, "patTaus" + patTauLabel, postfix).userIsolation = cms.PSet()
-
-    ## no tau-jet energy corrections determined for CaloTaus yet
-#    applyPostfix(process, "patTauJetCorrFactors" + patTauLabel, postfix).src = caloTauLabel
-#    applyPostfix(process, "patTaus" + patTauLabel, postfix).addTauJetCorrFactors = cms.bool(False)
-
-    ## adapt cleanPatTaus
-    if hasattr(process, "cleanPatTaus" + patTauLabel + postfix):
-        getattr(process, "cleanPatTaus" + patTauLabel + postfix).preselection = \
-      'tauID("leadingTrackFinding") > 0.5 & tauID("leadingTrackPtCut") > 0.5' \
-     + ' & tauID("byIsolation") > 0.5 & tauID("againstElectron") > 0.5 & (signalTracks.size() = 1 | signalTracks.size() = 3)'
-
-def _buildIDSourcePSet(pfTauType, idSources, postfix =""):
-    """ Build a PSet defining the tau ID sources to embed into the pat::Tau """
-    output = cms.PSet()
-    for label, discriminator in idSources:
-        if ":" in discriminator:
-          discr = discriminator.split(":")
-          setattr(output, label, cms.InputTag(pfTauType + discr[0] + postfix + ":" + discr[1]))
-        else:  
-          setattr(output, label, cms.InputTag(pfTauType + discriminator + postfix))
-    return output
-
-def _switchToPFTau(process,
-                   pfTauLabelOld,
-                   pfTauLabelNew,
-                   pfTauType,
-                   idSources,
-                   jecLevels, jecPayloadMapping,
-                   patTauLabel = "",
-                   postfix = ""):
-    """internal auxiliary function to switch to **any** PFTau collection"""
-    print ' Taus: ', pfTauLabelOld, '->', pfTauLabelNew
-
-    applyPostfix(process, "tauMatch" + patTauLabel, postfix).src = pfTauLabelNew
-    applyPostfix(process, "tauGenJetMatch" + patTauLabel, postfix).src = pfTauLabelNew
-
-    applyPostfix(process, "tauIsoDepositPFCandidates" + patTauLabel, postfix).src = pfTauLabelNew
-    applyPostfix(process, "tauIsoDepositPFCandidates" + patTauLabel, postfix).ExtractorPSet.tauSource = pfTauLabelNew
-    applyPostfix(process, "tauIsoDepositPFChargedHadrons" + patTauLabel, postfix).src = pfTauLabelNew
-    applyPostfix(process, "tauIsoDepositPFChargedHadrons" + patTauLabel, postfix).ExtractorPSet.tauSource = pfTauLabelNew
-    applyPostfix(process, "tauIsoDepositPFNeutralHadrons" + patTauLabel, postfix).src = pfTauLabelNew
-    applyPostfix(process, "tauIsoDepositPFNeutralHadrons" + patTauLabel, postfix).ExtractorPSet.tauSource = pfTauLabelNew
-    applyPostfix(process, "tauIsoDepositPFGammas" + patTauLabel, postfix).src = pfTauLabelNew
-    applyPostfix(process, "tauIsoDepositPFGammas" + patTauLabel, postfix).ExtractorPSet.tauSource = pfTauLabelNew
-
-#    applyPostfix(process, "patTauJetCorrFactors" + patTauLabel, postfix).src = pfTauLabelNew
-#    if len(jecLevels) > 0:
-#        applyPostfix(process, "patTaus" + patTauLabel, postfix).addTauJetCorrFactors = cms.bool(True)
-#        applyPostfix(process, "patTauJetCorrFactors" + patTauLabel, postfix).parameters = jecPayloadMapping
-#    else:
-#        applyPostfix(process, "patTaus" + patTauLabel, postfix).addTauJetCorrFactors = cms.bool(False)
-
-
-    UpdateDiscriminators=True
-    try:
-        from RecoTauTag.Configuration.updateHPSPFTaus_cff import updateHPSPFTaus
-    except ImportError:
-        UpdateDiscriminators=False
-
-    if UpdateDiscriminators:
-        idSources += [
-                     ("byIsolationMVAraw", "DiscriminationByIsolationMVAraw"),
-                     ("byLooseIsolationMVA", "DiscriminationByLooseIsolationMVA"),
-                     ("byMediumIsolationMVA", "DiscriminationByMediumIsolationMVA"),
-                     ("byTightIsolationMVA", "DiscriminationByTightIsolationMVA"),
-                     ("byIsolationMVA2raw", "DiscriminationByIsolationMVA2raw"),
-                     ("byLooseIsolationMVA2", "DiscriminationByLooseIsolationMVA2"),
-                     ("byMediumIsolationMVA2", "DiscriminationByMediumIsolationMVA2"),
-                     ("byTightIsolationMVA2", "DiscriminationByTightIsolationMVA2"),
-#                      ("againstElectronMVA2raw", "DiscriminationByMVA2rawElectronRejection"),
-#                      ("againstElectronMVA2category", "DiscriminationByMVA2rawElectronRejection:category"),
-#                      ("againstElectronVLooseMVA2", "DiscriminationByMVA2VLooseElectronRejection"),
-#                      ("againstElectronLooseMVA2", "DiscriminationByMVA2LooseElectronRejection"),
-#                      ("againstElectronMediumMVA2", "DiscriminationByMVA2MediumElectronRejection"),
-#                      ("againstElectronTightMVA2", "DiscriminationByMVA2TightElectronRejection"),
-                     ("byLooseCombinedIsolationDeltaBetaCorr3Hits", "DiscriminationByLooseCombinedIsolationDBSumPtCorr3Hits"),
-                     ("byMediumCombinedIsolationDeltaBetaCorr3Hits", "DiscriminationByMediumCombinedIsolationDBSumPtCorr3Hits"),
-                     ("byTightCombinedIsolationDeltaBetaCorr3Hits", "DiscriminationByTightCombinedIsolationDBSumPtCorr3Hits"),
-                     ("byCombinedIsolationDeltaBetaCorrRaw3Hits", "DiscriminationByRawCombinedIsolationDBSumPtCorr3Hits"),
-                     ("againstElectronMVA3raw", "DiscriminationByMVA3rawElectronRejection"),
-                     ("againstElectronMVA3category", "DiscriminationByMVA3rawElectronRejection:category"),
-                     ("againstElectronLooseMVA3", "DiscriminationByMVA3LooseElectronRejection"),
-                     ("againstElectronMediumMVA3", "DiscriminationByMVA3MediumElectronRejection"),
-                     ("againstElectronTightMVA3", "DiscriminationByMVA3TightElectronRejection"),
-                     ("againstElectronVTightMVA3", "DiscriminationByMVA3VTightElectronRejection"),
-                     ("againstElectronDeadECAL", "DiscriminationByDeadECALElectronRejection"),
-                     ("againstMuonLoose2", "DiscriminationByLooseMuonRejection2"),
-                     ("againstMuonMedium2", "DiscriminationByMediumMuonRejection2"),
-                     ("againstMuonTight2", "DiscriminationByTightMuonRejection2"),
-                     ("againstMuonLoose3", "DiscriminationByLooseMuonRejection3"),
-                     ("againstMuonTight3", "DiscriminationByTightMuonRejection3")
-                     ]
-    
-    applyPostfix(process, "patTaus" + patTauLabel, postfix).tauSource = pfTauLabelNew
-    applyPostfix(process, "patTaus" + patTauLabel, postfix).tauIDSources = _buildIDSourcePSet(pfTauType, idSources, postfix)
-
-    if hasattr(process, "cleanPatTaus" + patTauLabel + postfix):
-        getattr(process, "cleanPatTaus" + patTauLabel + postfix).preselection = \
-          'tauID("leadingTrackFinding") > 0.5 & tauID("leadingPionPtCut") > 0.5 & tauID("byIsolationUsingLeadingPion") > 0.5' \
-         + ' & tauID("againstMuon") > 0.5 & tauID("againstElectron") > 0.5' \
-         + ' & (signalPFChargedHadrCands.size() = 1 | signalPFChargedHadrCands.size() = 3)'
-
-# Name mapping for classic tau ID sources (present for fixed and shrinkingCones)
-classicTauIDSources = [
-    ("leadingTrackFinding", "DiscriminationByLeadingTrackFinding"),
-    ("leadingTrackPtCut", "DiscriminationByLeadingTrackPtCut"),
-    ("trackIsolation", "DiscriminationByTrackIsolation"),
-    ("ecalIsolation", "DiscriminationByECALIsolation"),
-    ("byIsolation", "DiscriminationByIsolation"),
-    ("againstElectron", "DiscriminationAgainstElectron"),
-    ("againstMuon", "DiscriminationAgainstMuon") ]
-
-classicPFTauIDSources = [
-    ("leadingPionPtCut", "DiscriminationByLeadingPionPtCut"),
-    ("trackIsolationUsingLeadingPion", "DiscriminationByTrackIsolationUsingLeadingPion"),
-    ("ecalIsolationUsingLeadingPion", "DiscriminationByECALIsolationUsingLeadingPion"),
-    ("byIsolationUsingLeadingPion", "DiscriminationByIsolationUsingLeadingPion")]
-
-# Tau Neural Classifier Discriminators
-tancTauIDSources = [
-    ("byTaNC", "DiscriminationByTaNC"),
-    ("byTaNCfrOnePercent", "DiscriminationByTaNCfrOnePercent"),
-    ("byTaNCfrHalfPercent", "DiscriminationByTaNCfrHalfPercent"),
-    ("byTaNCfrQuarterPercent", "DiscriminationByTaNCfrQuarterPercent"),
-    ("byTaNCfrTenthPercent", "DiscriminationByTaNCfrTenthPercent") ]
-
-# Hadron-plus-strip(s) (HPS) Tau Discriminators
-hpsTauIDSources = [
-    ("decayModeFinding", "DiscriminationByDecayModeFinding"),
-    ("byVLooseIsolation", "DiscriminationByVLooseIsolation"),
-    ("byLooseIsolation", "DiscriminationByLooseIsolation"),
-    ("byMediumIsolation", "DiscriminationByMediumIsolation"),
-    ("byTightIsolation", "DiscriminationByTightIsolation"),
-    ("byVLooseIsolationDeltaBetaCorr", "DiscriminationByVLooseIsolationDBSumPtCorr"),
-    ("byLooseIsolationDeltaBetaCorr", "DiscriminationByLooseIsolationDBSumPtCorr"),
-    ("byMediumIsolationDeltaBetaCorr", "DiscriminationByMediumIsolationDBSumPtCorr"),
-    ("byTightIsolationDeltaBetaCorr", "DiscriminationByTightIsolationDBSumPtCorr"),
-    ("byVLooseCombinedIsolationDeltaBetaCorr", "DiscriminationByVLooseCombinedIsolationDBSumPtCorr"),
-    ("byLooseCombinedIsolationDeltaBetaCorr", "DiscriminationByLooseCombinedIsolationDBSumPtCorr"),
-    ("byMediumCombinedIsolationDeltaBetaCorr", "DiscriminationByMediumCombinedIsolationDBSumPtCorr"),
-    ("byTightCombinedIsolationDeltaBetaCorr", "DiscriminationByTightCombinedIsolationDBSumPtCorr"),
-    ("byCombinedIsolationDeltaBetaCorrRaw", "DiscriminationByRawCombinedIsolationDBSumPtCorr"),
-#    ("byLooseCombinedIsolationDeltaBetaCorr3Hits", "DiscriminationByLooseCombinedIsolationDBSumPtCorr3Hits"),
-#    ("byMediumCombinedIsolationDeltaBetaCorr3Hits", "DiscriminationByMediumCombinedIsolationDBSumPtCorr3Hits"),
-#    ("byTightCombinedIsolationDeltaBetaCorr3Hits", "DiscriminationByTightCombinedIsolationDBSumPtCorr3Hits"),    
-#commented out because of backwards compatibility. THey are added below in case new tauDiscriminators are re-run
-#    ("byIsolationMVAraw", "DiscriminationByIsolationMVAraw"),
-#    ("byLooseIsolationMVA", "DiscriminationByLooseIsolationMVA"),
-#    ("byMediumIsolationMVA", "DiscriminationByMediumIsolationMVA"),
-#    ("byTightIsolationMVA", "DiscriminationByTightIsolationMVA"),
-    ("againstElectronLoose", "DiscriminationByLooseElectronRejection"),
-    ("againstElectronMedium", "DiscriminationByMediumElectronRejection"),
-    ("againstElectronTight", "DiscriminationByTightElectronRejection"),
-#    ("againstElectronMVA", "DiscriminationByMVAElectronRejection"),
-# commented out because of backwards compatibility. THey are added below in case new tauDiscriminators are re-run
-#    ("againstElectronMVA2raw", "DiscriminationByMVA2rawElectronRejection"),
-#    ("againstElectronMVA2category", "DiscriminationByMVA2rawElectronRejection:category"),
-#    ("againstElectronVLooseMVA2", "DiscriminationByMVA2VLooseElectronRejection"),
-#    ("againstElectronLooseMVA2", "DiscriminationByMVA2LooseElectronRejection"),
-#    ("againstElectronMediumMVA2", "DiscriminationByMVA2MediumElectronRejection"),
-#    ("againstElectronTightMVA2", "DiscriminationByMVA2TightElectronRejection"),
-#    ("againstElectronMVA3raw", "DiscriminationByMVA3rawElectronRejection"),
-#    ("againstElectronMVA3category", "DiscriminationByMVA3rawElectronRejection:category"),
-#    ("againstElectronLooseMVA3", "DiscriminationByMVA3LooseElectronRejection"),
-#    ("againstElectronMediumMVA3", "DiscriminationByMVA3MediumElectronRejection"),
-#    ("againstElectronTightMVA3", "DiscriminationByMVA3TightElectronRejection"),
-#    ("againstElectronDeadECAL", "DiscriminationByDeadECALElectronRejection"),
-    ("againstMuonLoose", "DiscriminationByLooseMuonRejection"),
-    ("againstMuonMedium", "DiscriminationByMediumMuonRejection"),
-    ("againstMuonTight", "DiscriminationByTightMuonRejection") ]
-
-# Discriminators of new HPS + TaNC combined Tau id. algorithm
-hpsTancTauIDSources = [
-    ("leadingTrackFinding", "DiscriminationByLeadingTrackFinding"),
-    ("leadingTrackPtCut", "DiscriminationByLeadingTrackPtCut"),
-    ("leadingPionPtCut", "DiscriminationByLeadingPionPtCut"),
-    ("byTaNCraw", "DiscriminationByTancRaw"),
-    ("byTaNC", "DiscriminationByTanc"),
-    ("byTaNCvloose", "DiscriminationByTancVLoose"),
-    ("byTaNCloose", "DiscriminationByTancLoose"),
-    ("byTaNCmedium", "DiscriminationByTancMedium"),
-    ("byTaNCtight", "DiscriminationByTancTight"),
-    ("decayModeFinding", "DiscriminationByDecayModeSelection"),
-    ("byHPSvloose", "DiscriminationByVLooseIsolation"),
-    ("byHPSloose", "DiscriminationByLooseIsolation"),
-    ("byHPSmedium", "DiscriminationByMediumIsolation"),
-    ("byHPStight", "DiscriminationByTightIsolation"),
-    ("againstElectronLoose", "DiscriminationByLooseElectronRejection"),
-    ("againstElectronMedium", "DiscriminationByMediumElectronRejection"),
-    ("againstElectronTight", "DiscriminationByTightElectronRejection"),
-    ("againstMuonLoose", "DiscriminationByLooseMuonRejection"),
-    ("againstMuonTight", "DiscriminationByTightMuonRejection") ]
-
-# use tau-jet energy corrections determined for HPS taus for all PFTaus
-from RecoTauTag.TauTagTools.tauDecayModes_cfi import *
-pfTauJECpayloadMapping = cms.VPSet(
-    cms.PSet(
-        payload    = cms.string('AK5tauHPSlooseCombDBcorrOneProng0Pi0'),
-        decayModes = cms.vstring('%i' % tauToOneProng0PiZero)
-    ),
-    cms.PSet(
-        payload    = cms.string('AK5tauHPSlooseCombDBcorrOneProng1Pi0'),
-        decayModes = cms.vstring('%i' % tauToOneProng1PiZero)
-    ),
-    cms.PSet(
-        payload    = cms.string('AK5tauHPSlooseCombDBcorrOneProng2Pi0'),
-        decayModes = cms.vstring('%i' % tauToOneProng2PiZero)
-    ),
-    cms.PSet(
-        payload    = cms.string('AK5tauHPSlooseCombDBcorrThreeProng0Pi0'),
-        decayModes = cms.vstring('%i' % tauToThreeProng0PiZero)
-    ),
-    cms.PSet(
-        payload    = cms.string('AK5tauHPSlooseCombDBcorr'),
-        decayModes = cms.vstring('*')
-    )
-)
-
-# switch to PFTau collection produced for fixed dR = 0.07 signal cone size
-def switchToPFTauFixedCone(process,
-                           pfTauLabelOld = cms.InputTag('hpsPFTauProducer'),
-                           pfTauLabelNew = cms.InputTag('fixedConePFTauProducer'),
-                           patTauLabel = "",
-                           jecLevels = [],
-                           postfix = ""):
-    fixedConeIDSources = copy.copy(classicTauIDSources)
-    fixedConeIDSources.extend(classicPFTauIDSources)
-
-    fixedConeJECpayloadMapping = pfTauJECpayloadMapping
-
-    _switchToPFTau(process, pfTauLabelOld, pfTauLabelNew, 'fixedConePFTau', fixedConeIDSources,
-                   jecLevels, fixedConeJECpayloadMapping,
-                   patTauLabel = patTauLabel, postfix = postfix)
-
-# switch to PFTau collection produced for shrinking signal cone of size dR = 5.0/Et(PFTau)
-def switchToPFTauShrinkingCone(process,
-                               pfTauLabelOld = cms.InputTag('hpsPFTauProducer'),
-                               pfTauLabelNew = cms.InputTag('shrinkingConePFTauProducer'),
-                               patTauLabel = "",
-                               jecLevels = [],
-                               postfix = ""):
-    shrinkingIDSources = copy.copy(classicTauIDSources)
-    shrinkingIDSources.extend(classicPFTauIDSources)
-    # Only shrinkingCone has associated TaNC discriminators, so add them here
-    shrinkingIDSources.extend(tancTauIDSources)
-
-    shrinkingConeJECpayloadMapping = pfTauJECpayloadMapping
-
-    _switchToPFTau(process, pfTauLabelOld, pfTauLabelNew, 'shrinkingConePFTau', shrinkingIDSources,
-                   jecLevels, shrinkingConeJECpayloadMapping,
-                   patTauLabel = patTauLabel, postfix = postfix)
-
-# switch to hadron-plus-strip(s) (HPS) PFTau collection
-def switchToPFTauHPS(process,
-                     pfTauLabelOld = cms.InputTag('hpsPFTauProducer'),
-                     pfTauLabelNew = cms.InputTag('hpsPFTauProducer'),
-                     patTauLabel = "",
-                     jecLevels = [],
-                     postfix = ""):
-
-    hpsTauJECpayloadMapping = pfTauJECpayloadMapping
-
-    _switchToPFTau(process, pfTauLabelOld, pfTauLabelNew, 'hpsPFTau', hpsTauIDSources,
-                   jecLevels, hpsTauJECpayloadMapping,
-                   patTauLabel = patTauLabel, postfix = postfix)
-
-    ## adapt cleanPatTaus
-    if hasattr(process, "cleanPatTaus" + patTauLabel + postfix):
-        getattr(process, "cleanPatTaus" + patTauLabel + postfix).preselection = \
-      'pt > 15 & abs(eta) < 2.3 & tauID("decayModeFinding") > 0.5 & tauID("byLooseIsolation") > 0.5' \
-     + ' & tauID("againstMuonTight") > 0.5 & tauID("againstElectronLoose") > 0.5'
-
-# switch to hadron-plus-strip(s) (HPS) PFTau collection
-def switchToPFTauHPSpTaNC(process,
-                          pfTauLabelOld = cms.InputTag('hpsPFTauProducer'),
-                          pfTauLabelNew = cms.InputTag('hpsTancTaus'),
-                          patTauLabel = "",
-                          jecLevels = [],
-                          postfix = ""):
-
-    hpsTancTauJECpayloadMapping = pfTauJECpayloadMapping
-
-    _switchToPFTau(process, pfTauLabelOld, pfTauLabelNew, 'hpsTancTaus', hpsTancTauIDSources,
-                   jecLevels, hpsTancTauJECpayloadMapping,
-                   patTauLabel = patTauLabel, postfix = postfix)
-
-    ## adapt cleanPatTaus
-    if hasattr(process, "cleanPatTaus" + patTauLabel + postfix):
-        getattr(process, "cleanPatTaus" + patTauLabel + postfix).preselection = \
-      'pt > 15 & abs(eta) < 2.3 & tauID("decayModeFinding") > 0.5 & tauID("byHPSloose") > 0.5' \
-     + ' & tauID("againstMuonTight") > 0.5 & tauID("againstElectronLoose") > 0.5'
-
-# Select switcher by string
-def switchToPFTauByType(process,
-                        pfTauType = None,
-                        pfTauLabelNew = None,
-                        pfTauLabelOld = cms.InputTag('hpsPFTauProducer'),
-                        patTauLabel = "",
-                        jecLevels = [],
-                        postfix = "" ):
-    mapping = { 'shrinkingConePFTau' : switchToPFTauShrinkingCone,
-                'fixedConePFTau' : switchToPFTauFixedCone,
-                'hpsPFTau' : switchToPFTauHPS,
-                'caloRecoTau' : switchToCaloTau,
-                'hpsTancPFTau' : switchToPFTauHPSpTaNC }
-    mapping[pfTauType](process, pfTauLabelOld = pfTauLabelOld, pfTauLabelNew = pfTauLabelNew,
-                       jecLevels = jecLevels,
-                       patTauLabel = patTauLabel, postfix = postfix)
-
-# switch to PFTau collection that was default in PAT production in CMSSW_3_1_x release series
-def switchTo31Xdefaults(process):
-    switchToPFTauFixedCone(process)
-    process.cleanPatTaus.preselection = cms.string('tauID("byIsolation") > 0')
-
-class AddTauCollection(ConfigToolBase):
-
-    """ Add a new collection of taus. Takes the configuration from the
-    already configured standard tau collection as starting point;
-    replaces before calling addTauCollection will also affect the
-    new tau collections
-    """
-    _label='addTauCollection'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters, 'tauCollection',
-                          self._defaultValue, 'Input tau collection', cms.InputTag)
-        self.addParameter(self._defaultParameters, 'algoLabel',
-                          self._defaultValue, "label to indicate the tau algorithm (e.g.'hps')", str)
-        self.addParameter(self._defaultParameters, 'typeLabel',
-                          self._defaultValue, "label to indicate the type of constituents (either 'PFTau' or 'Tau')", str)
-        self.addParameter(self._defaultParameters, 'doPFIsoDeposits',
-                          True, "run sequence for computing particle-flow based IsoDeposits")
-        ##self.addParameter(self._defaultParameters, 'jetCorrLabel',
-        ##                  (pfTauJECpayloadMapping, ['L2Relative', 'L3Absolute']),
-        ##                  "payload and list of new jet correction labels", tuple, acceptNoneValue = True)
-        self.addParameter(self._defaultParameters, 'jetCorrLabel',
-                          None, "payload and list of new jet correction labels", tuple, acceptNoneValue = True)
-        self.addParameter(self._defaultParameters, 'standardAlgo',
-                          "hps", "standard algorithm label of the collection from which the clones " \
-                         + "for the new tau collection will be taken from " \
-                         + "(note that this tau collection has to be available in the event before hand)")
-        self.addParameter(self._defaultParameters, 'standardType',
-                          "PFTau", "standard constituent type label of the collection from which the clones " \
-                         + " for the new tau collection will be taken from "\
-                         + "(note that this tau collection has to be available in the event before hand)")
-
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 tauCollection      = None,
-                 algoLabel          = None,
-                 typeLabel          = None,
-                 doPFIsoDeposits    = None,
-                 jetCorrLabel       = None,
-                 standardAlgo       = None,
-                 standardType       = None):
-
-        if tauCollection is None:
-            tauCollection = self._defaultParameters['tauCollection'].value
-        if algoLabel is None:
-            algoLabel = self._defaultParameters['algoLabel'].value
-        if typeLabel is None:
-            typeLabel = self._defaultParameters['typeLabel'].value
-        if doPFIsoDeposits is None:
-            doPFIsoDeposits = self._defaultParameters['doPFIsoDeposits'].value
-        if jetCorrLabel is None:
-            jetCorrLabel = self._defaultParameters['jetCorrLabel'].value
-        if standardAlgo is None:
-            standardAlgo = self._defaultParameters['standardAlgo'].value
-        if standardType is None:
-            standardType = self._defaultParameters['standardType'].value
-
-        self.setParameter('tauCollection', tauCollection)
-        self.setParameter('algoLabel', algoLabel)
-        self.setParameter('typeLabel', typeLabel)
-        self.setParameter('doPFIsoDeposits', doPFIsoDeposits)
-        self.setParameter('jetCorrLabel', jetCorrLabel)
-        self.setParameter('standardAlgo', standardAlgo)
-        self.setParameter('standardType', standardType)
-
-        self.apply(process)
-
-    def toolCode(self, process):
-        tauCollection = self._parameters['tauCollection'].value
-        algoLabel = self._parameters['algoLabel'].value
-        typeLabel = self._parameters['typeLabel'].value
-        doPFIsoDeposits = self._parameters['doPFIsoDeposits'].value
-        jetCorrLabel = self._parameters['jetCorrLabel'].value
-        standardAlgo = self._parameters['standardAlgo'].value
-        standardType = self._parameters['standardType'].value
-
-        ## disable computation of particle-flow based IsoDeposits
-        ## in case tau is of CaloTau type
-        if typeLabel == 'Tau':
-#            print "NO PF Isolation will be computed for CaloTau (this could be improved later)"
-            doPFIsoDeposits = False
-
-        ## create old module label from standardAlgo
-        ## and standardType and return
-        def oldLabel(prefix = ''):
-            if prefix == '':
-                return "patTaus"
-            else:
-                return prefix + "PatTaus"
-
-        ## capitalize first character of appended part
-        ## when creating new module label
-        ## (giving e.g. "patTausCaloRecoTau")
-        def capitalize(label):
-            return label[0].capitalize() + label[1:]
-
-        ## create new module label from old module
-        ## label and return
-        def newLabel(oldLabel):
-            newLabel = oldLabel
-            if ( oldLabel.find(standardAlgo) >= 0 and oldLabel.find(standardType) >= 0 ):
-                oldLabel = oldLabel.replace(standardAlgo, algoLabel).replace(standardType, typeLabel)
-            else:
-                oldLabel = oldLabel + capitalize(algoLabel + typeLabel)
-            return oldLabel
-
-        ## clone module and add it to the patDefaultSequence
-        def addClone(hook, **replaceStatements):
-            ## create a clone of the hook with corresponding
-            ## parameter replacements
-            newModule = getattr(process, hook).clone(**replaceStatements)
-            ## add the module to the sequence
-            addModuleToSequence(hook, newModule)
-
-        ## clone module for computing particle-flow IsoDeposits
-        def addPFIsoDepositClone(hook, **replaceStatements):
-            newModule = getattr(process, hook).clone(**replaceStatements)
-            newModuleIsoDepositExtractor = getattr(newModule, "ExtractorPSet")
-            setattr(newModuleIsoDepositExtractor, "tauSource", getattr(newModule, "src"))
-            addModuleToSequence(hook, newModule)
-
-        ## add module to the patDefaultSequence
-        def addModuleToSequence(hook, newModule):
-            hookModule = getattr(process, hook)
-            ## add the new module with standardAlgo &
-            ## standardType replaced in module label
-            setattr(process, newLabel(hook), newModule)
-            ## add new module to default sequence
-            ## just behind the hookModule
-            process.patDefaultSequence.replace( hookModule, hookModule*newModule )
-
-        ## add a clone of patTaus
-        addClone(oldLabel(), tauSource = tauCollection)
-
-        ## add a clone of selectedPatTaus
-        addClone(oldLabel('selected'), src = cms.InputTag(newLabel(oldLabel())))
-
-        ## add a clone of cleanPatTaus
-        addClone(oldLabel('clean'), src=cms.InputTag(newLabel(oldLabel('selected'))))
-
-        ## get attributes of new module
-        newTaus = getattr(process, newLabel(oldLabel()))
-
-        ## add a clone of gen tau matching
-        addClone('tauMatch', src = tauCollection)
-        addClone('tauGenJetMatch', src = tauCollection)
-
-        ## add a clone of IsoDeposits computed based on particle-flow
-        if doPFIsoDeposits:
-            addPFIsoDepositClone('tauIsoDepositPFCandidates', src = tauCollection)
-            addPFIsoDepositClone('tauIsoDepositPFChargedHadrons', src = tauCollection)
-            addPFIsoDepositClone('tauIsoDepositPFNeutralHadrons', src = tauCollection)
-            addPFIsoDepositClone('tauIsoDepositPFGammas', src = tauCollection)
-
-        if jetCorrLabel:
-            addClone('patTauJetCorrFactors', src = tauCollection)
-            getattr(process,newLabel('patTauJetCorrFactors')).payload = jetCorrLabel[0]
-            getattr(process,newLabel('patTauJetCorrFactors')).levels = jetCorrLabel[1]
-            getattr(process, newLabel('patTaus')).tauJetCorrFactorsSource = cms.VInputTag(cms.InputTag(newLabel('patTauJetCorrFactors')))
-
-        ## fix label for input tag
-        def fixInputTag(x): x.setModuleLabel(newLabel(x.moduleLabel))
-
-        ## provide patTau inputs with individual labels
-        fixInputTag(newTaus.genParticleMatch)
-        fixInputTag(newTaus.genJetMatch)
-        fixInputTag(newTaus.isoDeposits.pfAllParticles)
-        fixInputTag(newTaus.isoDeposits.pfNeutralHadron)
-        fixInputTag(newTaus.isoDeposits.pfChargedHadron)
-        fixInputTag(newTaus.isoDeposits.pfGamma)
-        fixInputTag(newTaus.userIsolation.pfAllParticles.src)
-        fixInputTag(newTaus.userIsolation.pfNeutralHadron.src)
-        fixInputTag(newTaus.userIsolation.pfChargedHadron.src)
-        fixInputTag(newTaus.userIsolation.pfGamma.src)
-
-        ## set discriminators
-        ## (using switchTauCollection functions)
-        oldTaus = getattr(process, oldLabel())
-#        if typeLabel == 'Tau':
-#            switchToCaloTau(process,
-#                            pfTauLabel = getattr(oldTaus, "tauSource"),
-#                            caloTauLabel = getattr(newTaus, "tauSource"),
-#                            patTauLabel = capitalize(algoLabel + typeLabel))
-#        else:
-        switchToPFTauByType(process, pfTauType = algoLabel + typeLabel,
-                                pfTauLabelNew = getattr(newTaus, "tauSource"),
-                                pfTauLabelOld = getattr(oldTaus, "tauSource"),
-                                patTauLabel = capitalize(algoLabel + typeLabel))
-
-addTauCollection=AddTauCollection()
diff --git a/PhysicsTools/PatAlgos/python/tools/trackTools.py b/PhysicsTools/PatAlgos/python/tools/trackTools.py
deleted file mode 100644
index f1d5dc7..0000000
--- a/PhysicsTools/PatAlgos/python/tools/trackTools.py
+++ /dev/null
@@ -1,320 +0,0 @@
-from FWCore.GuiBrowsers.ConfigToolBase import *
-
-
-class MakeAODTrackCandidates(ConfigToolBase):
-
-    """ Create selected tracks and a candidate hypothesis on AOD:
-    """
-    _label='makeAODTrackCandidates'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'label','TrackCands', "output collection will be <'patAOD'+label>")
-        self.addParameter(self._defaultParameters,'tracks',cms.InputTag('generalTracks'), 'input tracks')
-        self.addParameter(self._defaultParameters,'particleType','pi+', 'particle type (for mass)')
-        self.addParameter(self._defaultParameters,'candSelection','pt > 10', 'preselection cut on the candidates')
-        
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 label         = None,
-                 tracks        = None,
-                 particleType  = None,
-                 candSelection = None) :
-        if label  is None:
-            label=self._defaultParameters['label'].value
-        if  tracks is None:
-            tracks=self._defaultParameters['tracks'].value
-        if  particleType is None:
-            particleType=self._defaultParameters['particleType'].value
-        if  candSelection is None:
-            candSelection=self._defaultParameters['candSelection'].value
-        self.setParameter('label',label)
-        self.setParameter('tracks',tracks)
-        self.setParameter('particleType',particleType)
-        self.setParameter('candSelection',candSelection)
-        self.apply(process) 
-        
-    def toolCode(self, process):             
-        label=self._parameters['label'].value
-        tracks=self._parameters['tracks'].value
-        particleType=self._parameters['particleType'].value
-        candSelection=self._parameters['candSelection'].value        
-
-        process.load("SimGeneral.HepPDTESSource.pythiapdt_cfi");
-        ## add ChargedCandidateProducer from track
-        setattr(process, 'patAOD' + label + 'Unfiltered', cms.EDProducer("ConcreteChargedCandidateProducer",
-                                                                         src  = tracks,
-                                                                         particleType = cms.string(particleType)
-                                                                         )
-                )
-        ## add CandViewSelector with preselection string
-        setattr(process, 'patAOD' + label, cms.EDFilter("CandViewSelector",
-                                                        src = cms.InputTag('patAOD' + label + 'Unfiltered'),
-                                                        cut = cms.string(candSelection)
-                                                        )
-                )
-        ## run production of TrackCandidates at the very beginning of the sequence
-        process.patDefaultSequence.replace(process.patCandidates, getattr(process, 'patAOD' + label + 'Unfiltered') * getattr(process, 'patAOD' + label) * process.patCandidates)
-        
-makeAODTrackCandidates=MakeAODTrackCandidates()
-
-
-class MakePATTrackCandidates(ConfigToolBase):
-
-    """ Create pat track candidates from AOD track collections:
-    """
-    _label='makePATTrackCandidates'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'label','TrackCands', "output will be 'all/selectedLayer1'+label")
-        self.addParameter(self._defaultParameters,'input',cms.InputTag('patAODTrackCands'), 'name of the input collection')
-        self.addParameter(self._defaultParameters,'selection','pt > 10', 'selection on PAT Layer 1 objects')
-        self.addParameter(self._defaultParameters,'isolation',{'tracker':0.3, 'ecalTowers':0.3, 'hcalTowers':0.3}, "solation to use (as 'source': value of dR)\ntracker     : as muon iso from tracks\necalTowers  : as muon iso from calo tower\nhcalTowers  : as muon iso from calo towers",allowedValues=['tracker','ecalTowers','hcalTowers'])
-        self.addParameter(self._defaultParameters,'isoDeposits',['tracker','ecalTowers','hcalTowers'], 'iso deposits')
-        self.addParameter(self._defaultParameters,'mcAs',None, "eplicate mc match as the one used by PAT on this AOD collection (None=no mc match); choose 'photon', 'electron', 'muon', 'tau','jet', 'met' as input string",Type=str, allowedValues=['photon', 'electron', 'muon', 'tau','jet', 'met', None], acceptNoneValue = True) 
-        
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 label       = None,
-                 input       = None,
-                 selection   = None,
-                 isolation   = None,
-                 isoDeposits = None,
-                 mcAs        = None) :
-        if label  is None:
-            label=self._defaultParameters['label'].value
-        if input is None:
-            input=self._defaultParameters['input'].value
-        if selection is None:
-            selection=self._defaultParameters['selection'].value
-        if isolation is None:
-            isolation=self._defaultParameters['isolation'].value
-        if isoDeposits is None:
-            isoDeposits=self._defaultParameters['isoDeposits'].value
-        if mcAs is None:
-            mcAs=self._defaultParameters['mcAs'].value    
-        self.setParameter('label',label)
-        self.setParameter('input',input)
-        self.setParameter('selection',selection)
-        self.setParameter('isolation',isolation)
-        self.setParameter('isoDeposits',isoDeposits)
-        self.setParameter('mcAs',mcAs,True)                                                                                              
-        self.apply(process) 
-        
-    def toolCode(self, process):                
-        label=self._parameters['label'].value
-        input=self._parameters['input'].value
-        selection=self._parameters['selection'].value
-        isolation=self._parameters['isolation'].value
-        isoDeposits=self._parameters['isoDeposits'].value
-        mcAs=self._parameters['mcAs'].value
-                                                
-        ## add patTracks to the process
-        from PhysicsTools.PatAlgos.producersLayer1.genericParticleProducer_cfi import patGenericParticles
-        setattr(process, 'pat' + label, patGenericParticles.clone(src = input))
-        ## add selectedPatTracks to the process
-        setattr(process, 'selectedPat' + label, cms.EDFilter("PATGenericParticleSelector",
-                                                             src = cms.InputTag("pat"+label),
-                                                             cut = cms.string(selection) 
-                                                             ) 
-                )
-        ## add cleanPatTracks to the process
-        from PhysicsTools.PatAlgos.cleaningLayer1.genericTrackCleaner_cfi import cleanPatTracks
-        setattr(process, 'cleanPat' + label, cleanPatTracks.clone(src = cms.InputTag('selectedPat' + label)))
-        
-        ## get them as variables, so we can put them in the sequences and/or configure them
-        l1cands         = getattr(process, 'pat' + label)
-        selectedL1cands = getattr(process, 'selectedPat' + label)
-        cleanL1cands    = getattr(process, 'cleanPat' + label)
-        
-        ## insert them in sequence, after the electrons
-        process.patCandidates.replace(process.patElectrons, l1cands + process.patElectrons)
-        process.selectedPatCandidates.replace(process.selectedPatElectrons, process.selectedPatElectrons + selectedL1cands)
-        process.cleanPatCandidates.replace(process.cleanPatElectrons, process.cleanPatElectrons + cleanL1cands)
-    
-        ## add them to the Summary Tables
-        process.patCandidateSummary.candidates += [ cms.InputTag("allPat"+label) ]
-        process.selectedPatCandidateSummary.candidates += [ cms.InputTag("selectedPat"+label) ]
-        process.cleanPatCandidateSummary.candidates += [ cms.InputTag("cleanPat"+label) ]
-    
-        ## isolation: start with empty config
-        if(isolation or isoDeposits):
-            process.load("TrackPropagation.SteppingHelixPropagator.SteppingHelixPropagatorAlong_cfi")
-            process.load("TrackPropagation.SteppingHelixPropagator.SteppingHelixPropagatorOpposite_cfi")
-            process.load("TrackPropagation.SteppingHelixPropagator.SteppingHelixPropagatorAny_cfi")
-        isoModules = []
-        runIsoDeps = {'tracker':False, 'caloTowers':False}
-    
-        for source,deltaR in isolation.items():
-            ## loop items in isolation
-            if(source == 'tracker'):
-                runIsoDeps['tracker'] = True
-                l1cands.userIsolation.tracker = cms.PSet(
-                    src    = cms.InputTag('pat'+label+'IsoDepositTracks'),
-                    deltaR = cms.double(deltaR),
-                    )
-            elif(source == 'ecalTowers'):
-                runIsoDeps['caloTowers'] = True
-                l1cands.userIsolation.ecal = cms.PSet(
-                    src    = cms.InputTag('pat'+label+'IsoDepositCaloTowers', 'ecal'),
-                    deltaR = cms.double(deltaR),
-                    )
-            elif(source == 'hcalTowers'):
-                runIsoDeps['caloTowers'] = True
-                l1cands.userIsolation.hcal = cms.PSet(
-                    src    = cms.InputTag('pat'+label+'IsoDepositCaloTowers', 'hcal'),
-                    deltaR = cms.double(deltaR),
-                    )
-            
-        for source in isoDeposits:
-            ## loop items in isoDeposits
-            if(source == 'tracker'):
-                runIsoDeps['tracker'] = True
-                l1cands.isoDeposits.tracker = cms.InputTag('pat'+label+'IsoDepositTracks') 
-            elif(source == 'ecalTowers'):
-                runIsoDeps['caloTowers'] = True
-                l1cands.isoDeposits.ecal = cms.InputTag('pat'+label+'IsoDepositCaloTowers', 'ecal') 
-            elif(source == 'hcalTowers'):
-                runIsoDeps['caloTowers'] = True
-                l1cands.isoDeposits.hcal = cms.InputTag('pat'+label+'IsoDepositCaloTowers', 'hcal')
-            
-        for dep in [ dep for dep,runme in runIsoDeps.items() if runme == True ]:
-            if(dep == 'tracker'):
-                from RecoMuon.MuonIsolationProducers.trackExtractorBlocks_cff import MIsoTrackExtractorCtfBlock
-                setattr(process, 'pat'+label+'IsoDepositTracks',
-                        cms.EDProducer("CandIsoDepositProducer",
-                                       src                  = input,
-                                       trackType            = cms.string('best'),
-                                       MultipleDepositsFlag = cms.bool(False),
-                                       ExtractorPSet        = cms.PSet( MIsoTrackExtractorCtfBlock )
-                                       )
-                        )
-                isoModules.append( getattr(process, 'pat'+label+'IsoDepositTracks') )
-            elif(dep == 'caloTowers'):
-                from RecoMuon.MuonIsolationProducers.caloExtractorByAssociatorBlocks_cff import MIsoCaloExtractorByAssociatorTowersBlock
-                setattr(process, 'pat'+label+'IsoDepositCaloTowers',
-                        cms.EDProducer("CandIsoDepositProducer",
-                                       src                  = input,
-                                       trackType            = cms.string('best'),
-                                       MultipleDepositsFlag = cms.bool(True),
-                                       ExtractorPSet        = cms.PSet( MIsoCaloExtractorByAssociatorTowersBlock )
-                                       )
-                        )
-                isoModules.append( getattr(process, 'pat'+label+'IsoDepositCaloTowers') )
-        for m in isoModules:
-            process.patDefaultSequence.replace(l1cands, m * l1cands)
-        # ES
-        process.load( 'TrackingTools.TrackAssociator.DetIdAssociatorESProducer_cff' ) 
-        # MC
-        from PhysicsTools.PatAlgos.tools.helpers import MassSearchParamVisitor
-        if(type(mcAs) != type(None)):
-            findMatch= []
-            findMatch.append(getattr(process, mcAs+'Match'))
-            
-            ## clone mc matchiong module of object mcAs and add it to the path
-            setattr(process, 'pat'+label+'MCMatch', findMatch[0].clone(src = input))
-            process.patDefaultSequence.replace( l1cands, getattr(process, 'pat'+label+'MCMatch') * l1cands)
-            l1cands.addGenMatch = True
-            l1cands.genParticleMatch = cms.InputTag('pat'+label+'MCMatch')
-
-      
-makePATTrackCandidates=MakePATTrackCandidates()
-
-
-class MakeTrackCandidates(ConfigToolBase):
-    """ Create selected tracks and a candidate hypothesis on AOD:
-    """
-    _label='makeTrackCandidates'
-    _defaultParameters=dicttypes.SortedKeysDict()
-    
-    def __init__(self):
-        ConfigToolBase.__init__(self)
-        self.addParameter(self._defaultParameters,'label','TrackCands', "output collection will be <'patAOD'+label>")
-        self.addParameter(self._defaultParameters,'tracks',cms.InputTag('generalTracks'), 'input tracks')
-        self.addParameter(self._defaultParameters,'particleType','pi+', 'particle type (for mass)')
-        self.addParameter(self._defaultParameters,'preselection','pt > 10', 'preselection cut on the AOD candidates')
-        self.addParameter(self._defaultParameters,'selection','pt > 10', 'selection cut on the PAT candidates (for the selectedLayer1Candidate collection)')
-        self.addParameter(self._defaultParameters,'isolation',{'tracker':0.3, 'ecalTowers':0.3, 'hcalTowers':0.3}, "isolation to use (as 'source': value of dR)\ntracker     : as muon iso from tracks\necalTowers  : as muon iso from calo tower\nhcalTowers  : as muon iso from calo towers",allowedValues=['tracker','ecalTowers','hcalTowers'])
-        self.addParameter(self._defaultParameters,'isoDeposits',['tracker','ecalTowers','hcalTowers'], 'iso deposits')
-        self.addParameter(self._defaultParameters,'mcAs',None, "eplicate mc match as the one used by PAT on this AOD collection (None=no mc match); choose 'photon', 'electron', 'muon', 'tau','jet', 'met' as input string",Type=str,allowedValues=['photon', 'electron', 'muon', 'tau','jet', 'met', None], acceptNoneValue = True)
-        
-        self._parameters=copy.deepcopy(self._defaultParameters)
-        self._comment = ""
-
-    def getDefaultParameters(self):
-        return self._defaultParameters
-
-    def __call__(self,process,
-                 label        = None,
-                 tracks       = None,
-                 particleType = None,
-                 preselection = None,
-                 selection    = None,
-                 isolation    = None,
-                 isoDeposits  = None,
-                 mcAs         = None) :
-        if label  is None:
-            label=self._defaultParameters['label'].value
-        if tracks is None:
-            tracks=self._defaultParameters['tracks'].value
-        if particleType is None:
-            particleType=self._defaultParameters['particleType'].value
-        if preselection is None:
-            preselection=self._defaultParameters['preselection'].value
-        if selection is None:
-            selection=self._defaultParameters['selection'].value
-        if isolation is None:
-            isolation=self._defaultParameters['isolation'].value
-        if isoDeposits is None:
-            isoDeposits=self._defaultParameters['isoDeposits'].value
-        if mcAs is None:
-            mcAs=self._defaultParameters['mcAs'].value  
-        self.setParameter('label',label)
-        self.setParameter('tracks',tracks)
-        self.setParameter('particleType',particleType)
-        self.setParameter('preselection',preselection)
-        self.setParameter('selection',selection)
-        self.setParameter('isolation',isolation)
-        self.setParameter('isoDeposits',isoDeposits)
-        self.setParameter('mcAs',mcAs,True)                                                                                              
-        self.apply(process) 
-        
-    def toolCode(self, process):                
-        label=self._parameters['label'].value
-        tracks=self._parameters['tracks'].value
-        particleType=self._parameters['particleType'].value
-        preselection=self._parameters['preselection'].value
-        selection=self._parameters['selection'].value
-        isolation=self._parameters['isolation'].value
-        isoDeposits=self._parameters['isoDeposits'].value
-        mcAs=self._parameters['mcAs'].value
-        
-        makeAODTrackCandidates(process,
-                               tracks        = tracks,
-                               particleType  = particleType,
-                               candSelection = preselection,
-                               label         = label
-                               ) 
-        makePATTrackCandidates(process,
-                               label         = label,
-                               input         = cms.InputTag('patAOD' + label), 
-                               isolation     = isolation,
-                               isoDeposits   = isoDeposits,
-                               mcAs          = mcAs,
-                               selection     = selection
-                               )
-    
-makeTrackCandidates=MakeTrackCandidates()
diff --git a/PhysicsTools/PatAlgos/python/tools/trigTools.py b/PhysicsTools/PatAlgos/python/tools/trigTools.py
deleted file mode 100644
index 306e56d..0000000
--- a/PhysicsTools/PatAlgos/python/tools/trigTools.py
+++ /dev/null
@@ -1,831 +0,0 @@
-from FWCore.GuiBrowsers.ConfigToolBase import *
-
-from PhysicsTools.PatAlgos.tools.helpers import *
-from PhysicsTools.PatAlgos.patEventContent_cff import patTriggerL1RefsEventContent
-
-_defaultTriggerMatchers      = [ 'cleanMuonTriggerMatchHLTMu20'
-                               , 'cleanMuonTriggerMatchHLTDoubleMu6'
-                               , 'cleanPhotonTriggerMatchHLTPhoton26IsoVLPhoton18'
-                               , 'cleanElectronTriggerMatchHLTEle27CaloIdVTCaloIsoTTrkIdTTrkIsoT'
-                               , 'cleanTauTriggerMatchHLTDoubleIsoPFTau20Trk5'
-                               , 'cleanJetTriggerMatchHLTJet240'
-                               , 'metTriggerMatchHLTMET100'
-                               , 'cleanMuonTriggerMatchHLTMu17CentralJet30'
-                               , 'cleanJetTriggerMatchHLTMu17CentralJet30'
-                               ]
-_defaultTriggerProducer      = 'patTrigger'
-_defaultTriggerEventProducer = 'patTriggerEvent'
-_defaultSequence             = 'patDefaultSequence'
-_defaultHltProcess           = 'HLT'
-_defaultOutputModule         = 'out'
-_defaultPostfix              = ''
-
-_defaultTriggerMatchersComment      = "Trigger matcher modules' labels, default: ..."
-_defaultTriggerProducerComment      = "PATTriggerProducer module label, default: %s"%( _defaultTriggerProducer )
-_defaultTriggerEventProducerComment = "PATTriggerEventProducer module label, default: %s"%( _defaultTriggerEventProducer )
-_defaultSequenceComment             = "Name of sequence to use, default: %s"%( _defaultSequence )
-_defaultHltProcessComment           = "HLT process name, default: %s"%( _defaultHltProcess )
-_defaultOutputModuleComment         = "Output module label, empty label indicates no output, default: %s"%( _defaultOutputModule )
-_defaultPostfixComment              = "Postfix to apply to PAT module labels, default: %s"%( _defaultPostfix )
-
-_longLine = '---------------------------------------------------------------------'
-
-
-def _modulesInSequence( process, sequenceLabel ):
-    return [ m.label() for m in listModules( getattr( process, sequenceLabel ) ) ]
-
-
-def _addEventContent( outputCommands, eventContent ):
-    # add new entry to event content
-    for content in eventContent:
-        if content not in outputCommands:
-            outputCommands += [ content ]
-    # check for obsolete entries
-    listToRemove = []
-    for i in range( len( outputCommands ) ):
-        if i in listToRemove:
-            continue
-        command = outputCommands[ i ]
-        if command[ : 4 ] == 'keep':
-            dropCommand = command.replace( 'keep ', 'drop ' )
-            for j in range( i + 1, len( outputCommands ) ):
-                testCommand = outputCommands[ j ]
-                if testCommand == command:
-                    listToRemove += [ j ]
-                elif testCommand == dropCommand:
-                    listToRemove += [ i, j ]
-                    break
-    # copy entries excl. obsolete ones
-    newOutputCommands = cms.untracked.vstring()
-    for i in range( len( outputCommands ) ):
-        if i not in listToRemove:
-            newOutputCommands += [ outputCommands[ i ] ]
-    # return result
-    return newOutputCommands
-
-
-class SwitchOnTrigger( ConfigToolBase ):
-    """  Enables trigger information in PAT
-    SwitchOnTrigger( [cms.Process], triggerProducer = 'patTrigger', triggerEventProducer = 'patTriggerEvent', sequence = 'patDefaultSequence', hltProcess = 'HLT', outputModule = 'out' )
-    - [cms.Process]       : the 'cms.Process'
-    - triggerProducer     : PATTriggerProducer module label;
-                            optional, default: 'patTrigger'
-    - triggerEventProducer: PATTriggerEventProducer module label;
-                            optional, default: 'patTriggerEvent'
-    - sequence            : name of sequence to use;
-                            optional, default: 'patDefaultSequence'
-    - hltProcess          : HLT process name;
-                            optional, default: 'HLT'
-    - outputModule        : output module label;
-                            empty label indicates no output;
-                            optional, default: 'out'
-    Using None as any argument restores its default value.
-    """
-    _label             = 'switchOnTrigger'
-    _defaultParameters = dicttypes.SortedKeysDict()
-
-    def __init__( self ):
-        ConfigToolBase.__init__( self )
-        self.addParameter( self._defaultParameters, 'triggerProducer'     , _defaultTriggerProducer     , _defaultTriggerProducerComment )
-        self.addParameter( self._defaultParameters, 'triggerEventProducer', _defaultTriggerEventProducer, _defaultTriggerEventProducerComment )
-        self.addParameter( self._defaultParameters, 'sequence'            , _defaultSequence            , _defaultSequenceComment )
-        self.addParameter( self._defaultParameters, 'hltProcess'          , _defaultHltProcess          , _defaultHltProcessComment )
-        self.addParameter( self._defaultParameters, 'outputModule'        , _defaultOutputModule        , _defaultOutputModuleComment )
-        self._parameters = copy.deepcopy( self._defaultParameters )
-        self._comment = ""
-
-    def getDefaultParameters( self ):
-        return self._defaultParameters
-
-    def __call__( self, process
-                , triggerProducer      = None
-                , triggerEventProducer = None
-                , sequence             = None
-                , hltProcess           = None
-                , outputModule         = None
-                ):
-        if triggerProducer is None:
-            triggerProducer = self._defaultParameters[ 'triggerProducer' ].value
-        if triggerEventProducer is None:
-            triggerEventProducer = self._defaultParameters[ 'triggerEventProducer' ].value
-        if sequence is None:
-            sequence = self._defaultParameters[ 'sequence' ].value
-        if hltProcess is None:
-            hltProcess = self._defaultParameters[ 'hltProcess' ].value
-        if outputModule is None:
-            outputModule = self._defaultParameters[ 'outputModule' ].value
-        self.setParameter( 'triggerProducer'     , triggerProducer )
-        self.setParameter( 'triggerEventProducer', triggerEventProducer )
-        self.setParameter( 'sequence'            , sequence )
-        self.setParameter( 'hltProcess'          , hltProcess )
-        self.setParameter( 'outputModule'        , outputModule )
-        self.apply( process )
-
-    def toolCode( self, process ):
-        triggerProducer      = self._parameters[ 'triggerProducer' ].value
-        triggerEventProducer = self._parameters[ 'triggerEventProducer' ].value
-        sequence             = self._parameters[ 'sequence' ].value
-        hltProcess           = self._parameters[ 'hltProcess' ].value
-        outputModule         = self._parameters[ 'outputModule' ].value
-
-        # Load default producers from existing config files, if needed
-        if not hasattr( process, triggerProducer ):
-            if triggerProducer is self.getDefaultParameters()[ 'triggerProducer' ].value:
-                process.load( "PhysicsTools.PatAlgos.triggerLayer1.triggerProducer_cfi" )
-        if not hasattr( process, triggerEventProducer ):
-            if triggerEventProducer is self.getDefaultParameters()[ 'triggerEventProducer' ].value:
-                process.load( "PhysicsTools.PatAlgos.triggerLayer1.triggerEventProducer_cfi" )
-
-        # Maintain configurations
-        prodSequence            = getattr( process, sequence )
-        trigProdMod             = getattr( process, triggerProducer )
-        trigProdMod.processName = hltProcess
-        if triggerProducer in _modulesInSequence( process, sequence ):
-            print '%s():'%( self._label )
-            print '    PATTriggerProducer module %s exists already in sequence %s'%( triggerProducer, sequence )
-            print '    ==> entry re-used'
-            if trigProdMod.onlyStandAlone.value() is True:
-                trigProdMod.onlyStandAlone = False
-                print '    configuration parameter automatically changed'
-                print '    PATTriggerProducer %s.onlyStandAlone --> %s'%( triggerProducer, trigProdMod.onlyStandAlone )
-            print _longLine
-        else:
-            # Sequence arithmetics for PATTriggerProducer module
-            if hasattr( process, sequence + 'Trigger' ):
-                index = len( getattr( process, sequence + 'Trigger' ).moduleNames() )
-                getattr( process, sequence + 'Trigger' ).insert( index, trigProdMod )
-            else:
-                patTriggerSequence = cms.Sequence( trigProdMod )
-                setattr( process, sequence + 'Trigger', patTriggerSequence )
-                prodSequence *= getattr( process, sequence + 'Trigger' )
-        trigEvtProdMod             = getattr( process, triggerEventProducer )
-        trigEvtProdMod.processName = hltProcess
-        if hasattr( trigEvtProdMod, 'patTriggerProducer' ):
-            trigEvtProdMod.patTriggerProducer = triggerProducer
-        else:
-            trigEvtProdMod.patTriggerProducer = cms.InputTag( triggerProducer )
-        if triggerEventProducer in _modulesInSequence( process, sequence ):
-            print '%s():'%( self._label )
-            print '    PATTriggerEventProducer module %s exists already in sequence %s'%( triggerEventProducer, sequence )
-            print '    ==> entry re-used'
-            print _longLine
-        else:
-            # Sequence arithmetics for PATTriggerEventProducer module
-            if hasattr( process, sequence + 'TriggerEvent' ):
-                index = len( getattr( process, sequence + 'Trigger' ).moduleNames() )
-                getattr( process, sequence + 'TriggerEvent' ).insert( index, trigEvtProdMod )
-            else:
-                patTriggerEventSequence = cms.Sequence( trigEvtProdMod )
-                setattr( process, sequence + 'TriggerEvent', patTriggerEventSequence )
-                prodSequence *= getattr( process, sequence + 'TriggerEvent' )
-
-        # Add event content
-        if outputModule is not '':
-            patTriggerEventContent = [ 'keep patTriggerObjects_%s_*_%s'%( triggerProducer, process.name_() )
-                                     , 'keep patTriggerFilters_%s_*_%s'%( triggerProducer, process.name_() )
-                                     , 'keep patTriggerPaths_%s_*_%s'%( triggerProducer, process.name_() )
-                                     , 'keep patTriggerEvent_%s_*_%s'%( triggerEventProducer, process.name_() )
-                                     ]
-            if hasattr( trigProdMod, 'addL1Algos' ) and trigProdMod.addL1Algos.value() is True:
-                patTriggerEventContent += [ 'keep patTriggerConditions_%s_*_%s'%( triggerProducer, process.name_() )
-                                          , 'keep patTriggerAlgorithms_%s_*_%s'%( triggerProducer, process.name_() )
-                                          ]
-            if hasattr( trigProdMod, 'saveL1Refs' ) and trigProdMod.saveL1Refs.value() is True:
-                patTriggerEventContent += patTriggerL1RefsEventContent
-            getattr( process, outputModule ).outputCommands = _addEventContent( getattr( process, outputModule ).outputCommands, patTriggerEventContent )
-
-switchOnTrigger = SwitchOnTrigger()
-
-
-class SwitchOnTriggerStandAlone( ConfigToolBase ):
-    """  Enables trigger information in PAT, limited to stand-alone trigger objects
-    SwitchOnTriggerStandAlone( [cms.Process], triggerProducer = 'patTrigger', sequence = 'patDefaultSequence', hltProcess = 'HLT', outputModule = 'out' )
-    - [cms.Process]       : the 'cms.Process'
-    - triggerProducer     : PATTriggerProducer module label;
-                            optional, default: 'patTrigger'
-    - sequence            : name of sequence to use;
-                            optional, default: 'patDefaultSequence'
-    - hltProcess          : HLT process name;
-                            optional, default: 'HLT'
-    - outputModule        : output module label;
-                            empty label indicates no output;
-                            optional, default: 'out'
-    Using None as any argument restores its default value.
-    """
-    _label             = 'switchOnTriggerStandAlone'
-    _defaultParameters = dicttypes.SortedKeysDict()
-
-    def __init__( self ):
-        ConfigToolBase.__init__( self )
-        self.addParameter( self._defaultParameters, 'triggerProducer', _defaultTriggerProducer, _defaultTriggerProducerComment )
-        self.addParameter( self._defaultParameters, 'sequence'       , _defaultSequence       , _defaultSequenceComment )
-        self.addParameter( self._defaultParameters, 'hltProcess'     , _defaultHltProcess     , _defaultHltProcessComment )
-        self.addParameter( self._defaultParameters, 'outputModule'   , _defaultOutputModule   , _defaultOutputModuleComment )
-        self._parameters = copy.deepcopy( self._defaultParameters )
-        self._comment = ""
-
-    def getDefaultParameters( self ):
-        return self._defaultParameters
-
-    def __call__( self, process
-                , triggerProducer      = None
-                , sequence             = None
-                , hltProcess           = None
-                , outputModule         = None
-                ):
-        if triggerProducer is None:
-            triggerProducer = self._defaultParameters[ 'triggerProducer' ].value
-        if sequence is None:
-            sequence = self._defaultParameters[ 'sequence' ].value
-        if hltProcess is None:
-            hltProcess = self._defaultParameters[ 'hltProcess' ].value
-        if outputModule is None:
-            outputModule = self._defaultParameters[ 'outputModule' ].value
-        self.setParameter( 'triggerProducer', triggerProducer )
-        self.setParameter( 'sequence'       , sequence )
-        self.setParameter( 'hltProcess'     , hltProcess )
-        self.setParameter( 'outputModule'   , outputModule )
-        self.apply( process )
-
-    def toolCode( self, process ):
-        triggerProducer = self._parameters[ 'triggerProducer' ].value
-        sequence        = self._parameters[ 'sequence' ].value
-        hltProcess      = self._parameters[ 'hltProcess' ].value
-        outputModule    = self._parameters[ 'outputModule' ].value
-
-        # Load default producer from existing config file, if needed
-        if not hasattr( process, triggerProducer ):
-            if triggerProducer is self.getDefaultParameters()[ 'triggerProducer' ].value:
-                process.load( "PhysicsTools.PatAlgos.triggerLayer1.triggerProducer_cfi" )
-
-        # Maintain configuration
-        prodSequence            = getattr( process, sequence )
-        trigProdMod             = getattr( process, triggerProducer )
-        trigProdMod.processName = hltProcess
-        if triggerProducer in _modulesInSequence( process, sequence ):
-            print '%s():'%( self._label )
-            print '    PATTriggerProducer module %s exists already in sequence %s'%( triggerProducer, sequence )
-            print '    ==> entry re-used'
-            print _longLine
-        else:
-            # Sequence arithmetics for PATTriggerProducer module
-            if trigProdMod.onlyStandAlone.value() is False:
-                trigProdMod.onlyStandAlone = True
-                print '%s():'%( self._label )
-                print '    configuration parameter automatically changed'
-                print '    PATTriggerProducer %s.onlyStandAlone --> %s'%( triggerProducer, trigProdMod.onlyStandAlone )
-                print _longLine
-            if hasattr( process, sequence + 'Trigger' ):
-                index = len( getattr( process, sequence + 'Trigger' ).moduleNames() )
-                getattr( process, sequence + 'Trigger' ).insert( index, trigProdMod )
-            else:
-                patTriggerSequence = cms.Sequence( trigProdMod )
-                setattr( process, sequence + 'Trigger', patTriggerSequence )
-                prodSequence *= getattr( process, sequence + 'Trigger' )
-
-        # Add event content
-        if outputModule is not '':
-            patTriggerEventContent = [ 'keep patTriggerObjectStandAlones_%s_*_%s'%( triggerProducer, process.name_() )
-                                     ]
-            if hasattr( trigProdMod, 'saveL1Refs' ) and trigProdMod.saveL1Refs.value() is True:
-                patTriggerEventContent += patTriggerL1RefsEventContent
-            getattr( process, outputModule ).outputCommands = _addEventContent( getattr( process, outputModule ).outputCommands, patTriggerEventContent )
-
-switchOnTriggerStandAlone = SwitchOnTriggerStandAlone()
-
-
-class SwitchOnTriggerMatching( ConfigToolBase ):
-    """  Enables trigger matching in PAT
-    SwitchOnTriggerMatching( [cms.Process], triggerMatchers = [default list], triggerProducer = 'patTrigger', triggerEventProducer = 'patTriggerEvent', sequence = 'patDefaultSequence', hltProcess = 'HLT', outputModule = 'out', postfix = '' )
-    - [cms.Process]       : the 'cms.Process'
-    - triggerMatchers     : PAT trigger matcher module labels (list)
-                            optional; default: defined in 'triggerMatchingDefaultSequence'
-                            (s. PhysicsTools/PatAlgos/python/triggerLayer1/triggerMatcher_cfi.py)
-    - triggerProducer     : PATTriggerProducer module label;
-                            optional, default: 'patTrigger'
-    - triggerEventProducer: PATTriggerEventProducer module label;
-                            optional, default: 'patTriggerEvent'
-    - sequence            : name of sequence to use;
-                            optional, default: 'patDefaultSequence'
-    - hltProcess          : HLT process name;
-                            optional, default: 'HLT'
-    - outputModule        : output module label;
-                            empty label indicates no output;
-                            optional, default: 'out'
-    - postfix             : postfix to apply to PAT module labels;
-                            optional, default: ''
-    Using None as any argument restores its default value.
-    """
-    _label             = 'switchOnTriggerMatching'
-    _defaultParameters = dicttypes.SortedKeysDict()
-
-    def __init__( self ):
-        ConfigToolBase.__init__( self )
-        self.addParameter( self._defaultParameters, 'triggerMatchers'     , _defaultTriggerMatchers     , _defaultTriggerMatchersComment )
-        self.addParameter( self._defaultParameters, 'triggerProducer'     , _defaultTriggerProducer     , _defaultTriggerProducerComment )
-        self.addParameter( self._defaultParameters, 'triggerEventProducer', _defaultTriggerEventProducer, _defaultTriggerEventProducerComment )
-        self.addParameter( self._defaultParameters, 'sequence'            , _defaultSequence            , _defaultSequenceComment )
-        self.addParameter( self._defaultParameters, 'hltProcess'          , _defaultHltProcess          , _defaultHltProcessComment )
-        self.addParameter( self._defaultParameters, 'outputModule'        , _defaultOutputModule        , _defaultOutputModuleComment )
-        self.addParameter( self._defaultParameters, 'postfix'             , _defaultPostfix             , _defaultPostfixComment )
-        self._parameters = copy.deepcopy( self._defaultParameters )
-        self._comment = ""
-
-    def getDefaultParameters( self ):
-        return self._defaultParameters
-
-    def __call__( self, process
-                , triggerMatchers      = None
-                , triggerProducer      = None
-                , triggerEventProducer = None
-                , sequence             = None
-                , hltProcess           = None
-                , outputModule         = None
-                , postfix              = None
-                ):
-        if triggerMatchers is None:
-            triggerMatchers = self._defaultParameters[ 'triggerMatchers' ].value
-        if triggerProducer is None:
-            triggerProducer = self._defaultParameters[ 'triggerProducer' ].value
-        if triggerEventProducer is None:
-            triggerEventProducer = self._defaultParameters[ 'triggerEventProducer' ].value
-        if sequence is None:
-            sequence = self._defaultParameters[ 'sequence' ].value
-        if hltProcess is None:
-            hltProcess = self._defaultParameters[ 'hltProcess' ].value
-        if outputModule is None:
-            outputModule = self._defaultParameters[ 'outputModule' ].value
-        if postfix is None:
-            postfix = self._defaultParameters[ 'postfix' ].value
-        self.setParameter( 'triggerMatchers'     , triggerMatchers )
-        self.setParameter( 'triggerProducer'     , triggerProducer )
-        self.setParameter( 'triggerEventProducer', triggerEventProducer )
-        self.setParameter( 'sequence'            , sequence )
-        self.setParameter( 'hltProcess'          , hltProcess )
-        self.setParameter( 'outputModule'        , outputModule )
-        self.setParameter( 'postfix'             , postfix )
-        self.apply( process )
-
-    def toolCode( self, process ):
-        triggerMatchers      = self._parameters[ 'triggerMatchers' ].value
-        triggerProducer      = self._parameters[ 'triggerProducer' ].value
-        triggerEventProducer = self._parameters[ 'triggerEventProducer' ].value
-        sequence             = self._parameters[ 'sequence' ].value
-        hltProcess           = self._parameters[ 'hltProcess' ].value
-        outputModule         = self._parameters[ 'outputModule' ].value
-        postfix              = self._parameters[ 'postfix' ].value
-
-        # Load default producers from existing config file, if needed
-        if not hasattr( process, 'triggerMatchingDefaultSequence' ):
-            for matcher in triggerMatchers:
-                if matcher in self.getDefaultParameters()[ 'triggerMatchers' ].value:
-                    process.load( "PhysicsTools.PatAlgos.triggerLayer1.triggerMatcher_cfi" )
-                    break
-
-        # Switch on PAT trigger information if needed
-        if ( triggerProducer not in _modulesInSequence( process, sequence ) or triggerEventProducer not in _modulesInSequence( process, sequence ) ):
-            print '%s():'%( self._label )
-            print '    PAT trigger production switched on automatically using'
-            print '    switchOnTrigger( process, %s, %s, %s, %s, %s )'%( hltProcess, triggerProducer, triggerEventProducer, sequence, outputModule )
-            print _longLine
-            switchOnTrigger( process, triggerProducer, triggerEventProducer, sequence, hltProcess, outputModule )
-
-        # Maintain configurations
-        prodSequence   = getattr( process, sequence )
-        trigEvtProdMod = getattr( process, triggerEventProducer )
-        if trigEvtProdMod.patTriggerProducer.value() is not triggerProducer:
-            print '%s():'%( self._label )
-            print '    Configuration conflict found'
-            print '    triggerProducer = %s'%( triggerProducer )
-            print '    differs from'
-            print '    %s.patTriggerProducer = %s'%( triggerEventProducer, trigEvtProdMod.patTriggerProducer )
-            print '    parameter automatically changed'
-            print '    ==> triggerProducer --> %s'%( trigEvtProdMod.patTriggerProducer )
-            triggerProducer = trigEvtProdMod.patTriggerProducer
-        for matcher in triggerMatchers:
-            trigMchMod         = getattr( process, matcher )
-            trigMchMod.src     = cms.InputTag( trigMchMod.src.getModuleLabel() + postfix )
-            trigMchMod.matched = triggerProducer
-            if matcher in _modulesInSequence( process, sequence ):
-                print '%s():'%( self._label )
-                print '    PAT trigger matcher %s exists already in sequence %s'%( matcher, sequence )
-                print '    ==> entry re-used'
-                print _longLine
-            else:
-                # Sequence arithmetics for PAT trigger matcher modules
-                index = len( getattr( process, sequence + 'Trigger' ).moduleNames() )
-                getattr( process, sequence + 'Trigger' ).insert( index, trigMchMod )
-        matchers = getattr( trigEvtProdMod, 'patTriggerMatches' )
-        if len( matchers ) > 0:
-            print '%s():'%( self._label )
-            print '    PAT trigger matchers already attached to existing PATTriggerEventProducer %s'%( triggerEventProducer )
-            print '    configuration parameters automatically changed'
-            for matcher in matchers:
-                trigMchMod = getattr( process, matcher )
-                if trigMchMod.matched.value() is not triggerProducer:
-                    removeIfInSequence( process, matcher, sequence + 'Trigger' )
-                    trigMchMod.matched = triggerProducer
-                    index = len( getattr( process, sequence + 'Trigger' ).moduleNames() )
-                    getattr( process, sequence + 'Trigger' ).insert( index, trigMchMod )
-                    print '    PAT trigger matcher %s.matched --> %s'%( matcher, trigMchMod.matched )
-            print _longLine
-        else:
-            trigEvtProdMod.patTriggerMatches = cms.VInputTag()
-        for matcher in triggerMatchers:
-            trigEvtProdMod.patTriggerMatches.append( cms.InputTag( matcher ) )
-
-        # Add event content
-        if outputModule is not '':
-            patTriggerEventContent = []
-            for matcher in triggerMatchers:
-                patTriggerEventContent += [ 'keep patTriggerObjectsedmAssociation_%s_%s_%s'%( triggerEventProducer, matcher, process.name_() )
-                                          , 'keep *_%s_*_*'%( getattr( process, matcher ).src.value() )
-                                          ]
-            getattr( process, outputModule ).outputCommands = _addEventContent( getattr( process, outputModule ).outputCommands, patTriggerEventContent )
-
-switchOnTriggerMatching = SwitchOnTriggerMatching()
-
-
-class SwitchOnTriggerMatchingStandAlone( ConfigToolBase ):
-    """  Enables trigger matching in PAT
-    SwitchOnTriggerMatchingStandAlone( [cms.Process], triggerMatchers = [default list], triggerProducer = 'patTrigger', sequence = 'patDefaultSequence', hltProcess = 'HLT', outputModule = 'out', postfix = '' )
-    - [cms.Process]  : the 'cms.Process'
-    - triggerMatchers: PAT trigger matcher module labels (list)
-                       optional; default: defined in 'triggerMatchingDefaultSequence'
-                       (s. PhysicsTools/PatAlgos/python/triggerLayer1/triggerMatcher_cfi.py)
-    - triggerProducer: PATTriggerProducer module label;
-                       optional, default: 'patTrigger'
-    - sequence       : name of sequence to use;
-                       optional, default: 'patDefaultSequence'
-    - hltProcess     : HLT process name;
-                       optional, default: 'HLT'
-    - outputModule   : output module label;
-                       empty label indicates no output;
-                       optional, default: 'out'
-    - postfix        : postfix to apply to PAT module labels;
-                       optional, default: ''
-    Using None as any argument restores its default value.
-    """
-    _label             = 'switchOnTriggerMatchingStandAlone'
-    _defaultParameters = dicttypes.SortedKeysDict()
-
-    def __init__( self ):
-        ConfigToolBase.__init__( self )
-        self.addParameter( self._defaultParameters, 'triggerMatchers', _defaultTriggerMatchers, _defaultTriggerMatchersComment )
-        self.addParameter( self._defaultParameters, 'triggerProducer', _defaultTriggerProducer, _defaultTriggerProducerComment )
-        self.addParameter( self._defaultParameters, 'sequence'       , _defaultSequence       , _defaultSequenceComment )
-        self.addParameter( self._defaultParameters, 'hltProcess'     , _defaultHltProcess     , _defaultHltProcessComment )
-        self.addParameter( self._defaultParameters, 'outputModule'   , _defaultOutputModule   , _defaultOutputModuleComment )
-        self.addParameter( self._defaultParameters, 'postfix'        , _defaultPostfix        , _defaultPostfixComment )
-        self._parameters = copy.deepcopy( self._defaultParameters )
-        self._comment = ""
-
-    def getDefaultParameters( self ):
-        return self._defaultParameters
-
-    def __call__( self, process
-                , triggerMatchers = None
-                , triggerProducer = None
-                , sequence        = None
-                , hltProcess      = None
-                , outputModule    = None
-                , postfix         = None
-                ):
-        if triggerMatchers is None:
-            triggerMatchers = self._defaultParameters[ 'triggerMatchers' ].value
-        if triggerProducer is None:
-            triggerProducer = self._defaultParameters[ 'triggerProducer' ].value
-        if sequence is None:
-            sequence = self._defaultParameters[ 'sequence' ].value
-        if hltProcess is None:
-            hltProcess = self._defaultParameters[ 'hltProcess' ].value
-        if outputModule is None:
-            outputModule = self._defaultParameters[ 'outputModule' ].value
-        if postfix is None:
-            postfix = self._defaultParameters[ 'postfix' ].value
-        self.setParameter( 'triggerMatchers', triggerMatchers )
-        self.setParameter( 'triggerProducer', triggerProducer )
-        self.setParameter( 'sequence'       , sequence )
-        self.setParameter( 'hltProcess'     , hltProcess )
-        self.setParameter( 'outputModule'   , outputModule )
-        self.setParameter( 'postfix'        , postfix )
-        self.apply( process )
-
-    def toolCode( self, process ):
-        triggerMatchers = self._parameters[ 'triggerMatchers' ].value
-        triggerProducer = self._parameters[ 'triggerProducer' ].value
-        sequence        = self._parameters[ 'sequence' ].value
-        hltProcess      = self._parameters[ 'hltProcess' ].value
-        outputModule    = self._parameters[ 'outputModule' ].value
-        postfix         = self._parameters[ 'postfix' ].value
-
-        # Load default producers from existing config file, if needed
-        if not hasattr( process, 'triggerMatchingDefaultSequence' ):
-            for matcher in triggerMatchers:
-                if matcher in self.getDefaultParameters()[ 'triggerMatchers' ].value:
-                    process.load( "PhysicsTools.PatAlgos.triggerLayer1.triggerMatcher_cfi" )
-                    break
-
-        # Switch on PAT trigger information if needed
-        if triggerProducer not in _modulesInSequence( process, sequence ):
-            print '%s():'%( self._label )
-            print '    PAT trigger production switched on automatically using'
-            print '    switchOnTriggerStandAlone( process, %s, %s, %s, %s )'%( hltProcess, triggerProducer, sequence, outputModule )
-            print _longLine
-            switchOnTriggerStandAlone( process, triggerProducer, sequence, hltProcess, outputModule )
-
-        # Maintain configurations
-        for matcher in triggerMatchers:
-            trigMchMod         = getattr( process, matcher )
-            trigMchMod.src     = cms.InputTag( trigMchMod.src.getModuleLabel() + postfix )
-            trigMchMod.matched = triggerProducer
-            if matcher in _modulesInSequence( process, sequence ):
-                print '%s():'%( self._label )
-                print '    PAT trigger matcher %s exists already in sequence %s'%( matcher, sequence )
-                print '    ==> entry re-used'
-                print _longLine
-            else:
-                # Sequence arithmetics for PAT trigger matcher modules
-                index = len( getattr( process, sequence + 'Trigger' ).moduleNames() )
-                getattr( process, sequence + 'Trigger' ).insert( index, trigMchMod )
-
-        # Add event content
-        if outputModule is not '':
-            patTriggerEventContent = []
-            for matcher in triggerMatchers:
-                patTriggerEventContent += [ 'keep patTriggerObjectStandAlonesedmAssociation_%s_*_%s'%( matcher, process.name_() )
-                                          , 'keep *_%s_*_*'%( getattr( process, matcher ).src.value() )
-                                          ]
-            getattr( process, outputModule ).outputCommands = _addEventContent( getattr( process, outputModule ).outputCommands, patTriggerEventContent )
-
-switchOnTriggerMatchingStandAlone = SwitchOnTriggerMatchingStandAlone()
-
-
-class SwitchOnTriggerMatchEmbedding( ConfigToolBase ):
-    """  Enables embedding of trigger matches into PAT objects
-    SwitchOnTriggerMatchEmbedding( [cms.Process], triggerMatchers = [default list], triggerProducer = 'patTrigger', sequence = 'patDefaultSequence', hltProcess = 'HLT', outputModule = 'out', postfix = '' )
-    - [cms.Process]  : the 'cms.Process'
-    - triggerMatchers: PAT trigger matcher module labels (list)
-                       optional; default: defined in 'triggerMatchingDefaultSequence'
-                       (s. PhysicsTools/PatAlgos/python/triggerLayer1/triggerMatcher_cfi.py)
-    - triggerProducer: PATTriggerProducer module label;
-                       optional, default: 'patTrigger'
-    - sequence       : name of sequence to use;
-                       optional, default: 'patDefaultSequence'
-    - hltProcess     : HLT process name;
-                       optional, default: 'HLT'
-    - outputModule   : output module label;
-                       empty label indicates no output;
-                       optional, default: 'out'
-    - postfix        : postfix to apply to PAT module labels;
-                       optional, default: ''
-    Using None as any argument restores its default value.
-    """
-    _label             = 'switchOnTriggerMatchEmbedding'
-    _defaultParameters = dicttypes.SortedKeysDict()
-
-    def __init__( self ):
-        ConfigToolBase.__init__( self )
-        self.addParameter( self._defaultParameters, 'triggerMatchers', _defaultTriggerMatchers, _defaultTriggerMatchersComment )
-        self.addParameter( self._defaultParameters, 'triggerProducer', _defaultTriggerProducer, _defaultTriggerProducerComment )
-        self.addParameter( self._defaultParameters, 'sequence'       , _defaultSequence       , _defaultSequenceComment )
-        self.addParameter( self._defaultParameters, 'hltProcess'     , _defaultHltProcess     , _defaultHltProcessComment )
-        self.addParameter( self._defaultParameters, 'outputModule'   , _defaultOutputModule   , _defaultOutputModuleComment )
-        self.addParameter( self._defaultParameters, 'postfix'        , _defaultPostfix        , _defaultPostfixComment )
-        self._parameters = copy.deepcopy( self._defaultParameters )
-        self._comment = ""
-
-    def getDefaultParameters( self ):
-        return self._defaultParameters
-
-    def __call__( self, process
-                , triggerMatchers = None
-                , triggerProducer = None
-                , sequence        = None
-                , hltProcess      = None
-                , outputModule    = None
-                , postfix         = None
-                ):
-        if triggerMatchers is None:
-            triggerMatchers = self._defaultParameters[ 'triggerMatchers' ].value
-        if triggerProducer is None:
-            triggerProducer = self._defaultParameters[ 'triggerProducer' ].value
-        if sequence is None:
-            sequence = self._defaultParameters[ 'sequence' ].value
-        if hltProcess is None:
-            hltProcess = self._defaultParameters[ 'hltProcess' ].value
-        if outputModule is None:
-            outputModule = self._defaultParameters[ 'outputModule' ].value
-        if postfix is None:
-            postfix = self._defaultParameters[ 'postfix' ].value
-        self.setParameter( 'triggerMatchers', triggerMatchers )
-        self.setParameter( 'triggerProducer', triggerProducer )
-        self.setParameter( 'sequence'       , sequence )
-        self.setParameter( 'hltProcess'     , hltProcess )
-        self.setParameter( 'outputModule'   , outputModule )
-        self.setParameter( 'postfix'        , postfix )
-        self.apply( process )
-
-    def toolCode( self, process ):
-        triggerMatchers = self._parameters[ 'triggerMatchers' ].value
-        triggerProducer = self._parameters[ 'triggerProducer' ].value
-        sequence        = self._parameters[ 'sequence' ].value
-        hltProcess      = self._parameters[ 'hltProcess' ].value
-        outputModule    = self._parameters[ 'outputModule' ].value
-        postfix         = self._parameters[ 'postfix' ].value
-
-        # Build dictionary of known input collections
-        dictPatObjects = { 'Photons'  : 'PATTriggerMatchPhotonEmbedder'
-                         , 'Electrons': 'PATTriggerMatchElectronEmbedder'
-                         , 'Muons'    : 'PATTriggerMatchMuonEmbedder'
-                         , 'Taus'     : 'PATTriggerMatchTauEmbedder'
-                         , 'Jets'     : 'PATTriggerMatchJetEmbedder'
-                         , 'METs'     : 'PATTriggerMatchMETEmbedder'
-                         }
-        listPatSteps   = [ 'pat', 'selectedPat', 'cleanPat' ]
-        listJetAlgos   = [ 'IC5', 'SC5', 'KT4', 'KT6', 'AK5' ]
-        listJetTypes   = [ 'Calo', 'PF', 'JPT' ]
-        dictEmbedders  = {}
-        for objects in dictPatObjects.keys():
-            steps = len( listPatSteps )
-            if objects is 'METs':
-                steps = 1
-            for step in range( steps ):
-                coll = listPatSteps[ step ] + objects
-                dictEmbedders[ coll ]           = dictPatObjects[ objects ]
-                dictEmbedders[ coll + postfix ] = dictPatObjects[ objects ]
-                if objects is 'Jets':
-                    for jetAlgo in listJetAlgos:
-                        for jetType in listJetTypes:
-                            jetColl = coll + jetAlgo + jetType
-                            dictEmbedders[ jetColl ]           = dictPatObjects[ objects ]
-                            dictEmbedders[ jetColl + postfix ] = dictPatObjects[ objects ]
-
-        # Build dictionary of matchers and switch on PAT trigger matching if needed
-        dictConfig = {}
-        matchingOn = False
-        for matcher in triggerMatchers:
-            trigMchMod = getattr( process, matcher )
-            if trigMchMod.src.value() in dictConfig:
-                dictConfig[ trigMchMod.src.value() ] += [ matcher ]
-            else:
-                dictConfig[ trigMchMod.src.value() ] = [ matcher ]
-            if matcher not in _modulesInSequence( process, sequence ) and not matchingOn:
-                print '%s():'%( self._label )
-                print '    PAT trigger matching switched on automatically using'
-                print '    switchOnTriggerMatchingStandAlone( process, %s, %s, %s, %s, %s )'%( hltProcess, triggerMatchers, triggerProducer, sequence, outputModule )
-                print _longLine
-                switchOnTriggerMatchingStandAlone( process, triggerMatchers, triggerProducer, sequence, hltProcess, '', postfix )
-                matchingOn = True
-
-        # Maintain configurations
-        patTriggerEventContent = []
-        for srcInput in dictConfig.keys():
-            if dictEmbedders.has_key( srcInput ):
-                # Configure embedder module
-                dictIndex = srcInput
-                srcInput += postfix
-                if dictEmbedders.has_key( srcInput ):
-                    label = srcInput + 'TriggerMatch'
-                    if label in _modulesInSequence( process, sequence ):
-                        print '%s():'%( self._label )
-                        print '    PAT trigger match embedder %s exists already in sequence %s'%( label, sequence )
-                        print '    ==> entry moved to proper place'
-                        print _longLine
-                        removeIfInSequence( process, label, sequence + 'Trigger' )
-                    module         = cms.EDProducer( dictEmbedders[ dictIndex ] )
-                    module.src     = cms.InputTag( srcInput )
-                    module.matches = cms.VInputTag( dictConfig[ dictIndex ] )
-                    setattr( process, label, module )
-                    trigEmbMod = getattr( process, label )
-                    index = len( getattr( process, sequence + 'Trigger' ).moduleNames() )
-                    getattr( process, sequence + 'Trigger' ).insert( index, trigEmbMod )
-                    # Add event content
-                    patTriggerEventContent += [ 'drop *_%s_*_*'%( srcInput )
-                                              , 'keep *_%s_*_%s'%( label, process.name_() )
-                                              ]
-                else:
-                    print '%s():'%( self._label )
-                    print '    Invalid new input source for trigger match embedding'
-                    print '    ==> %s with matchers %s is skipped'%( srcInput, dictConfig[ dictIndex ] )
-                    print _longLine
-            else:
-                print '%s():'%( self._label )
-                print '    Invalid input source for trigger match embedding'
-                print '    ==> %s with matchers %s is skipped'%( srcInput, dictConfig[ srcInput ] )
-                print _longLine
-        if outputModule is not '':
-            getattr( process, outputModule ).outputCommands = _addEventContent( getattr( process, outputModule ).outputCommands, patTriggerEventContent )
-
-switchOnTriggerMatchEmbedding = SwitchOnTriggerMatchEmbedding()
-
-
-class RemoveCleaningFromTriggerMatching( ConfigToolBase ):
-    """  Removes cleaning from already existing PAT trigger matching/embedding configuration
-    RemoveCleaningFromTriggerMatching( [cms.Process], outputModule = 'out' )
-    - [cms.Process]  : the 'cms.Process'
-    - sequence       : name of sequence to use;
-                       optional, default: 'patDefaultSequence'
-    - outputModule   : output module label;
-                       empty label indicates no output;
-                       optional, default: 'out'
-    Using None as any argument restores its default value.
-    """
-    _label             = 'removeCleaningFromTriggerMatching'
-    _defaultParameters = dicttypes.SortedKeysDict()
-
-    def __init__( self ):
-        ConfigToolBase.__init__( self )
-        self.addParameter( self._defaultParameters, 'sequence'    , _defaultSequence    , _defaultSequenceComment )
-        self.addParameter( self._defaultParameters, 'outputModule', _defaultOutputModule, _defaultOutputModuleComment )
-        self._parameters = copy.deepcopy( self._defaultParameters )
-        self._comment = ""
-
-    def getDefaultParameters( self ):
-        return self._defaultParameters
-
-    def __call__( self, process
-                , sequence     = None
-                , outputModule = None
-                ):
-        if sequence is None:
-            sequence = self._defaultParameters[ 'sequence' ].value
-        if outputModule is None:
-            outputModule = self._defaultParameters[ 'outputModule' ].value
-        self.setParameter( 'sequence'    , sequence )
-        self.setParameter( 'outputModule', outputModule )
-        self.apply( process )
-
-    def toolCode( self, process ):
-        sequence     = self._parameters[ 'sequence' ].value
-        outputModule = self._parameters[ 'outputModule' ].value
-
-        # Maintain configurations
-        listMatchers = [ 'PATTriggerMatcherDRLessByR'
-                       , 'PATTriggerMatcherDRDPtLessByR'
-                       , 'PATTriggerMatcherDRLessByPt'
-                       , 'PATTriggerMatcherDRDPtLessByPt'
-                       , 'PATTriggerMatcherDEtaLessByDR'
-                       , 'PATTriggerMatcherDEtaLessByDEta'
-                       ]
-        listEmbedders = [ 'PATTriggerMatchPhotonEmbedder'
-                        , 'PATTriggerMatchElectronEmbedder'
-                        , 'PATTriggerMatchMuonEmbedder'
-                        , 'PATTriggerMatchTauEmbedder'
-                        , 'PATTriggerMatchJetEmbedder'
-                        , 'PATTriggerMatchMETEmbedder'
-                        ]
-        modules = _modulesInSequence( process, sequence )
-        oldModules = []
-        oldSources = []
-        # input source labels
-        for module in modules:
-            if hasattr( process, module ):
-                trigMod = getattr( process, module )
-                if trigMod.type_() in listMatchers:
-                    if trigMod.src.value()[ : 8 ] == 'cleanPat':
-                        trigMod.src = trigMod.src.value().replace( 'cleanPat', 'selectedPat' )
-                        if trigMod.label()[ : 5 ] == 'clean':
-                            oldModules += [ trigMod.label() ]
-                            setattr( process, trigMod.label().replace( 'clean', 'selected' ), trigMod )
-                if trigMod.type_() in listEmbedders:
-                    if trigMod.src.value()[ : 8 ] == 'cleanPat':
-                        oldSources += [ trigMod.src.getModuleLabel() ]
-                        trigMod.src = trigMod.src.value().replace( 'cleanPat', 'selectedPat' )
-                        if trigMod.label()[ : 5 ] == 'clean':
-                            oldModules += [ trigMod.label() ]
-                            setattr( process, trigMod.label().replace( 'clean', 'selected' ), trigMod )
-        # matcher labels
-        for module in modules:
-            if hasattr( process, module ):
-                trigMod = getattr( process, module )
-                if trigMod.type_() == 'PATTriggerEventProducer':
-                    matchers = getattr( trigMod, 'patTriggerMatches' )
-                    matchers = self._renameMatchers( matchers, oldModules )
-                elif trigMod.type_() in listEmbedders:
-                    matchers = getattr( trigMod, 'matches' )
-                    matchers = self._renameMatchers( matchers, oldModules )
-
-        # Maintain event content
-        if outputModule is not '':
-            patTriggerEventContent = getattr( process, outputModule ).outputCommands
-            for statement in range( len( patTriggerEventContent ) ):
-                for module in oldModules:
-                    if module in patTriggerEventContent[ statement ]:
-                        patTriggerEventContent[ statement ] = patTriggerEventContent[ statement ].replace( 'clean', 'selected' )
-                for source in oldSources:
-                    if source in patTriggerEventContent[ statement ] and 'drop' in patTriggerEventContent[ statement ]:
-                        patTriggerEventContent[ statement ] = patTriggerEventContent[ statement ].replace( 'clean', 'selected' )
-        print '%s():'%( self._label )
-        print '    Input from cleaning has been switched to input from selection;'
-        print '    matcher and embedder modules have been renamed accordingly.'
-        print _longLine
-
-    def _renameMatchers( self, matchers, oldModules ):
-        for matcher in range( len( matchers ) ):
-            if matchers[ matcher ] in oldModules:
-                if matchers[ matcher ][ : 5 ] == 'clean':
-                     matchers[ matcher ] = matchers[ matcher ].replace( 'clean', 'selected' )
-        return matchers
-
-removeCleaningFromTriggerMatching = RemoveCleaningFromTriggerMatching()
diff --git a/PhysicsTools/PatAlgos/python/triggerLayer1/triggerEventProducer_cfi.py b/PhysicsTools/PatAlgos/python/triggerLayer1/triggerEventProducer_cfi.py
deleted file mode 100644
index b09b996..0000000
--- a/PhysicsTools/PatAlgos/python/triggerLayer1/triggerEventProducer_cfi.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patTriggerEvent = cms.EDProducer(
-  "PATTriggerEventProducer"
-, processName        = cms.string( 'HLT' )               # default; change only, if you know exactly, what you are doing!
-# , triggerResults     = cms.InputTag( 'TriggerResults' )  # default; change only, if you know exactly, what you are doing!
-# , patTriggerProducer = cms.InputTag( 'patTrigger' )      # default; change only, if you know exactly, what you are doing!
-# , condGtTag          = cms.InputTag( 'conditionsInEdm' ) # default; change only, if you know exactly, what you are doing!
-# , l1GtTag            = cms.InputTag( 'gtDigis' )         # default; change only, if you know exactly, what you are doing!
-, patTriggerMatches  = cms.VInputTag(
-  )
-)
diff --git a/PhysicsTools/PatAlgos/python/triggerLayer1/triggerMatchEmbedder_cfi.py b/PhysicsTools/PatAlgos/python/triggerLayer1/triggerMatchEmbedder_cfi.py
deleted file mode 100644
index 5edb78c..0000000
--- a/PhysicsTools/PatAlgos/python/triggerLayer1/triggerMatchEmbedder_cfi.py
+++ /dev/null
@@ -1,66 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# Embedding in muons
-cleanPatMuonsTriggerMatch = cms.EDProducer(
-  "PATTriggerMatchMuonEmbedder"
-, src     = cms.InputTag( "cleanPatMuons" )
-, matches = cms.VInputTag(
-    'cleanMuonTriggerMatchHLTMu20'
-  , 'cleanMuonTriggerMatchHLTDoubleMu6'
-  )
-)
-
-# Embedding in photons
-cleanPatPhotonsTriggerMatch = cms.EDProducer(
-  "PATTriggerMatchPhotonEmbedder"
-, src     = cms.InputTag( "cleanPatPhotons" )
-, matches = cms.VInputTag(
-    'cleanPhotonTriggerMatchHLTPhoton26IsoVLPhoton18'
-  )
-)
-
-# Embedding in electrons
-cleanPatElectronsTriggerMatch = cms.EDProducer(
-  "PATTriggerMatchElectronEmbedder"
-, src     = cms.InputTag( "cleanPatElectrons" )
-, matches = cms.VInputTag(
-    'cleanElectronTriggerMatchHLTEle27CaloIdVTCaloIsoTTrkIdTTrkIsoT'
-  )
-)
-
-# Embedding in taus
-cleanPatTausTriggerMatch = cms.EDProducer(
-  "PATTriggerMatchTauEmbedder"
-, src     = cms.InputTag( "cleanPatTaus" )
-, matches = cms.VInputTag(
-    'cleanTauTriggerMatchHLTDoubleIsoPFTau20Trk5'
-  )
-)
-
-# Embedding in jets
-cleanPatJetsTriggerMatch = cms.EDProducer(
-  "PATTriggerMatchJetEmbedder"
-, src     = cms.InputTag( "cleanPatJets" )
-, matches = cms.VInputTag(
-    'cleanJetTriggerMatchHLTJet240'
-  )
-)
-
-# Embedding in MET
-patMETsTriggerMatch = cms.EDProducer(
-  "PATTriggerMatchMETEmbedder"
-, src     = cms.InputTag( "patMETs" )
-, matches = cms.VInputTag(
-    'metTriggerMatchHLTMET100'
-  )
-)
-
-## Embedding sequences
-patTriggerMatchEmbedderDefaultSequence = cms.Sequence(
-  cleanPatPhotonsTriggerMatch
-+ cleanPatElectronsTriggerMatch
-+ cleanPatMuonsTriggerMatch
-+ cleanPatTausTriggerMatch
-+ cleanPatJetsTriggerMatch
-+ patMETsTriggerMatch
-)
diff --git a/PhysicsTools/PatAlgos/python/triggerLayer1/triggerMatcher_cfi.py b/PhysicsTools/PatAlgos/python/triggerLayer1/triggerMatcher_cfi.py
deleted file mode 100644
index 9f7165b..0000000
--- a/PhysicsTools/PatAlgos/python/triggerLayer1/triggerMatcher_cfi.py
+++ /dev/null
@@ -1,183 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-# Examples for configurations of the trigger match for various physics objects
-#
-# A detailed description is given in
-# https://twiki.cern.ch/twiki/bin/view/CMS/SWGuidePATTrigger#PATTriggerMatcher
-# Cuts on the parameters
-# - 'maxDPtRel' and
-# - 'maxDeltaR'
-# are NOT tuned (using old values from TQAF MC match, January 2008)
-
-
-## Default example matches ##
-
-# firing trigger objects used in succeeding HLT path 'HLT_Mu20'
-cleanMuonTriggerMatchHLTMu20 = cms.EDProducer(
-  "PATTriggerMatcherDRDPtLessByR"                 # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( "cleanPatMuons" )
-, matched = cms.InputTag( "patTrigger" )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'path( "HLT_Mu20_v*" )' )
-, maxDPtRel = cms.double( 0.5 )
-, maxDeltaR = cms.double( 0.5 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
-
-# firing trigger objects used in succeeding HLT path 'HLT_DoubleMu6'
-cleanMuonTriggerMatchHLTDoubleMu6 = cms.EDProducer(
-  "PATTriggerMatcherDRDPtLessByR"                 # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( "cleanPatMuons" )
-, matched = cms.InputTag( "patTrigger" )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'path( "HLT_DoubleMu6_v*" )' )
-, maxDPtRel = cms.double( 0.5 )
-, maxDeltaR = cms.double( 0.5 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
-
-# firing trigger objects used in succeeding HLT path 'HLT_Photon26_IsoVL_Photon18'
-cleanPhotonTriggerMatchHLTPhoton26IsoVLPhoton18 = cms.EDProducer(
-  "PATTriggerMatcherDRDPtLessByR"                 # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( "cleanPatPhotons" )
-, matched = cms.InputTag( "patTrigger" )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'path( "HLT_Photon26_IsoVL_Photon18_v*" )' )
-, maxDPtRel = cms.double( 0.5 )
-, maxDeltaR = cms.double( 0.5 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
-
-# firing trigger objects used in succeeding HLT path 'HLT_Ele27_CaloIdVT_CaloIsoT_TrkIdT_TrkIsoT'
-cleanElectronTriggerMatchHLTEle27CaloIdVTCaloIsoTTrkIdTTrkIsoT = cms.EDProducer(
-  "PATTriggerMatcherDRDPtLessByR"                 # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( "cleanPatElectrons" )
-, matched = cms.InputTag( "patTrigger" )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'path( "HLT_Ele27_CaloIdVT_CaloIsoT_TrkIdT_TrkIsoT_v*" )' )
-, maxDPtRel = cms.double( 0.5 )
-, maxDeltaR = cms.double( 0.5 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
-
-# firing trigger objects used in succeeding HLT path 'HLT_DoubleIsoPFTau20_Trk5'
-cleanTauTriggerMatchHLTDoubleIsoPFTau20Trk5 = cms.EDProducer(
-  "PATTriggerMatcherDRDPtLessByR"                 # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( "cleanPatTaus" )
-, matched = cms.InputTag( "patTrigger" )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'path( "HLT_DoubleIsoPFTau20_Trk5_v*" )' )
-, maxDPtRel = cms.double( 0.5 )
-, maxDeltaR = cms.double( 0.5 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
-
-# firing trigger objects used in succeeding HLT path 'HLT_Jet240'
-cleanJetTriggerMatchHLTJet240 = cms.EDProducer(
-  "PATTriggerMatcherDRLessByR"                    # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( 'cleanPatJets' )
-, matched = cms.InputTag( 'patTrigger' )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'path( "HLT_Jet240_v*" )' )
-, maxDPtRel = cms.double( 3.0 )
-, maxDeltaR = cms.double( 0.4 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
-
-# firing trigger objects used in succeeding HLT path 'HLT_MET100'
-metTriggerMatchHLTMET100 = cms.EDProducer(
-  "PATTriggerMatcherDRLessByR"                    # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( 'patMETs' )
-, matched = cms.InputTag( 'patTrigger' )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'path( "HLT_MET100_v*" )' )
-, maxDPtRel = cms.double( 3.0 )
-, maxDeltaR = cms.double( 0.4 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
-
-# firing trigger objects used in succeeding HLT path 'HLT_Mu17_CentralJet30_v' (x-trigger)
-cleanMuonTriggerMatchHLTMu17CentralJet30 = cms.EDProducer(
-  "PATTriggerMatcherDRDPtLessByR"                 # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( "cleanPatMuons" )
-, matched = cms.InputTag( "patTrigger" )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'type( "TriggerMuon" ) && path( "HLT_Mu17_CentralJet30_v*" )' )
-, maxDPtRel = cms.double( 0.5 )
-, maxDeltaR = cms.double( 0.5 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
-cleanJetTriggerMatchHLTMu17CentralJet30 = cms.EDProducer(
-  "PATTriggerMatcherDRDPtLessByR"                 # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( "cleanPatJets" )
-, matched = cms.InputTag( "patTrigger" )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'type( "TriggerJet" ) && path( "HLT_Mu17_CentralJet30_v*" )' )
-, maxDPtRel = cms.double( 3.0 )
-, maxDeltaR = cms.double( 0.4 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
-
-
-triggerMatchingDefaultSequence = cms.Sequence(
-  cleanMuonTriggerMatchHLTMu20
-+ cleanMuonTriggerMatchHLTDoubleMu6
-+ cleanPhotonTriggerMatchHLTPhoton26IsoVLPhoton18
-+ cleanElectronTriggerMatchHLTEle27CaloIdVTCaloIsoTTrkIdTTrkIsoT
-+ cleanTauTriggerMatchHLTDoubleIsoPFTau20Trk5
-+ cleanJetTriggerMatchHLTJet240
-+ metTriggerMatchHLTMET100
-+ cleanMuonTriggerMatchHLTMu17CentralJet30
-+ cleanJetTriggerMatchHLTMu17CentralJet30
-)
-
-
-## Further examples ##
-
-# L1 e/gammas by original collection
-cleanElectronTriggerMatchL1EGammaCollection = cms.EDProducer(
-  "PATTriggerMatcherDRLessByR"                  # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( 'cleanPatElectrons' )
-, matched = cms.InputTag( 'patTrigger' )        # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'coll( "l1extraParticles:NonIsolated" ) || coll( "l1extraParticles:Isolated" )' )
-, maxDPtRel = cms.double( 0.5 )
-, maxDeltaR = cms.double( 0.5 )
-, resolveAmbiguities    = cms.bool( True )      # only one match per trigger object
-, resolveByMatchQuality = cms.bool( False )     # take first match found per reco object
-)
-
-# L1 and HLT muons by ID
-cleanMuonTriggerMatchTriggerMuon = cms.EDProducer(
-  "PATTriggerMatcherDRDPtLessByR"           # match by DeltaR and DeltaPt, best match by DeltaR
-, src     = cms.InputTag( 'cleanPatMuons' )
-, matched = cms.InputTag( 'patTrigger' )    # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'type( "TriggerL1Mu" ) || type( "TriggerMuon" )' )
-, maxDPtRel = cms.double( 0.5 )
-, maxDeltaR = cms.double( 0.5 )
-, resolveAmbiguities    = cms.bool( True )  # only one match per trigger object
-, resolveByMatchQuality = cms.bool( False ) # take first match found per reco object
-)
-
-# firing trigger objects used in succeeding HLT paths of PD /SingleMu
-cleanMuonTriggerMatchPDSingleMu = cms.EDProducer(
-  "PATTriggerMatcherDRDPtLessByR"                 # match by DeltaR and DeltaPt, best match by DeltaR
-, src     = cms.InputTag( 'cleanPatMuons' )
-, matched = cms.InputTag( 'patTrigger' )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'path( "HLT_IsoMu12_v*" ) || path( "HLT_IsoMu15_v*" ) || path( "HLT_IsoMu17_v*" ) || path( "HLT_IsoMu24_v*" ) || path( "HLT_IsoMu30_v*" ) || path( "HLT_L1SingleMu10_v*" ) || path( "HLT_L1SingleMu20_v*" ) || path( "HLT_L2Mu10_v*" ) || path( "HLT_L2Mu20_v*" ) || path( "HLT_Mu3_v*" ) || path( "HLT_Mu5_v*" ) || path( "HLT_Mu8_v*" ) || path( "HLT_Mu12_v*" ) || path( "HLT_Mu15_v*" ) || path( "HLT_Mu20_v*" ) || path( "HLT_Mu24_v*" ) || path( "HLT_Mu30_v*" )' )
-, maxDPtRel = cms.double( 0.5 )
-, maxDeltaR = cms.double( 0.5 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
-
-# all trigger objects used in HLT path 'HLT_Mu20' (fake MET)
-metTriggerMatchHLTMu20 = cms.EDProducer(
-  "PATTriggerMatcherDRLessByR"                    # match by DeltaR only, best match by DeltaR
-, src     = cms.InputTag( 'patMETs' )
-, matched = cms.InputTag( 'patTrigger' )          # default producer label as defined in PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
-, matchedCuts = cms.string( 'path( "HLT_Mu20_v*" )' )
-, maxDPtRel = cms.double( 0.5 )
-, maxDeltaR = cms.double( 0.5 )
-, resolveAmbiguities    = cms.bool( True )        # only one match per trigger object
-, resolveByMatchQuality = cms.bool( True )        # take best match found per reco object: by DeltaR here (s. above)
-)
diff --git a/PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cff.py b/PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cff.py
deleted file mode 100644
index 38b4c34..0000000
--- a/PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cff.py
+++ /dev/null
@@ -1,12 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-from PhysicsTools.PatAlgos.triggerLayer1.triggerProducer_cfi      import *
-from PhysicsTools.PatAlgos.triggerLayer1.triggerMatcher_cfi       import *
-from PhysicsTools.PatAlgos.triggerLayer1.triggerMatchEmbedder_cfi import *
-from PhysicsTools.PatAlgos.triggerLayer1.triggerEventProducer_cfi import *
-
-# Default sequence without any matching and/or embedding
-patTriggerDefaultSequence = cms.Sequence(
-  patTrigger
-* patTriggerEvent
-)
diff --git a/PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py b/PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
deleted file mode 100644
index ad0d5f8..0000000
--- a/PhysicsTools/PatAlgos/python/triggerLayer1/triggerProducer_cfi.py
+++ /dev/null
@@ -1,27 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-patTrigger = cms.EDProducer( "PATTriggerProducer"
-, onlyStandAlone = cms.bool( False )
-# ## L1
-# , addL1Algos                     = cms.bool( False )                                 # default; possibly superseded by 'onlyStandAlone' = True
-# , l1GlobalTriggerObjectMaps      = cms.InputTag( "l1L1GtObjectMap" )                 # default; change only, if you know exactly, what you are doing!
-# , l1ExtraMu                      = cms.InputTag( "l1extraParticles", ""            ) # default; change only, if you know exactly, what you are doing!
-# , l1ExtraNoIsoEG                 = cms.InputTag( "l1extraParticles", "NonIsolated" ) # default; change only, if you know exactly, what you are doing!
-# , l1ExtraIsoEG                   = cms.InputTag( "l1extraParticles", "Isolated"    ) # default; change only, if you know exactly, what you are doing!
-# , l1ExtraCenJet                  = cms.InputTag( "l1extraParticles", "Central"     ) # default; change only, if you know exactly, what you are doing!
-# , l1ExtraForJet                  = cms.InputTag( "l1extraParticles", "Forward"     ) # default; change only, if you know exactly, what you are doing!
-# , l1ExtraTauJet                  = cms.InputTag( "l1extraParticles", "Tau"         ) # default; change only, if you know exactly, what you are doing!
-# , l1ExtraETM                     = cms.InputTag( "l1extraParticles", "MET"         ) # default; change only, if you know exactly, what you are doing!
-# , l1ExtraHTM                     = cms.InputTag( "l1extraParticles", "MHT"         ) # default; change only, if you know exactly, what you are doing!
-# , mainBxOnly                     = cms.bool( True )                                  # default
-# , saveL1Refs                     = cms.bool( False )                                 # default; setting this to True requires to keep '*_l1extraParticles_*_[processName]' and '*_gctDigis_*_[processName]' in the event
-## HLT (L3)
-, processName    = cms.string( "HLT" )                    # default; change only, if you know exactly, what you are doing!
-# , triggerResults = cms.InputTag( "TriggerResults" )       # default; change only, if you know exactly, what you are doing!
-# , triggerEvent   = cms.InputTag( "hltTriggerSummaryAOD" ) # default; change only, if you know exactly, what you are doing!
-# , hltPrescaleLabel = cms.string( "0" )
-# , hltPrescaleTable = cms.string( "hltPrescaleRecorder" )  # only the label!
-# , addPathModuleLabels = cms.bool( False )                 # setting this "True" stores the names of all modules as strings (~10kB/ev.); possibly superseded by 'onlyStandAlone' = True
-# , exludeCollections = cms.vstring()
-)
-
diff --git a/PhysicsTools/PatAlgos/scripts/patReplaceFast.pl b/PhysicsTools/PatAlgos/scripts/patReplaceFast.pl
deleted file mode 100755
index 01207a5..0000000
--- a/PhysicsTools/PatAlgos/scripts/patReplaceFast.pl
+++ /dev/null
@@ -1,92 +0,0 @@
-#!/bin/env perl
-#
-# Replaces for fast simulation
-#
-# Usage: $0 <file> <replaces file>
-#        Replaces in <file> from <replaces file>
-
-use strict;
-
-die "Usage: $0 <file> <replaces>\n" if ( @ARGV != 2 );
-
-my $cfgFile = $ARGV[0];
-my $replaceFile = $ARGV[1];
-
-my %replaces;
-
-# Get list of replaces
-open(IN,$replaceFile) or die "Couldn't open $replaceFile: $!";
-while( <IN> ) {
-  if ( /replace\s+(\S+)(\s*=.*)[#|\/\/]?/ ) {
-    my $key   = $1;
-    my $value = $2;
-    # Check for multi-line value
-    while ( &countBraces($value) > 0 ) {
-      my $line = <IN>;
-      $value .= $line;
-    }
-    $replaces{$key} = $value;
-  }
-}
-close(IN);
-
-# Open temporary file
-my $temp = $cfgFile.".tmp";
-open(TEMP,">$temp") or die "Couldn't open $temp: $!";
-
-# Scan cfgfile and replace
-open(CFG,$cfgFile) or die "Couldn't open $cfgFile: $!";
-while ( <CFG> ) {
-  chomp();
-  my $line = $_;
-  my $matched = 0;
-  foreach my $replace ( keys %replaces ) {
-    next if ( !$replaces{$replace} );
-    if ( $line =~ /$replace/ ) {
-      print TEMP "replace ".$replace.$replaces{$replace}."\n";
-      $replaces{$replace} = 0;
-      ++$matched;
-      last;
-    }
-  }
-  if ( !$matched ) {
-    print TEMP $line."\n";
-  }
-}
-close(CFG);
-
-
-# Add missing items at the end of file (things that are only replaced in FastSim)
-# Print header
-print TEMP <<HEADER
-############################
-# Fast simulation replaces #
-############################
-HEADER
-;
-foreach my $replace ( keys %replaces ) {
-  next if ( !$replaces{$replace} );
-  print TEMP "replace ".$replace.$replaces{$replace}."\n";
-}
-close(TEMP) or die "Couldn't close $temp: $!";
-rename($temp,$cfgFile);
-
-
-#______________________________________________________________________
-# Count number of braces
-# Opening adds one, closing removes one
-sub countBraces {
-
-  my $string = shift;
-  my $nBraces = 0;
-  my $char = "";
-
-  while ( length($string)>0 ) {
-    $char = chop($string);
-    ++$nBraces if ( $char =~ /\{/ );
-    --$nBraces if ( $char =~ /\}/ );
-  }
-
-  return $nBraces;
-
-}
diff --git a/PhysicsTools/PatAlgos/scripts/patReplaceGenerator.sh b/PhysicsTools/PatAlgos/scripts/patReplaceGenerator.sh
deleted file mode 100755
index 6444733..0000000
--- a/PhysicsTools/PatAlgos/scripts/patReplaceGenerator.sh
+++ /dev/null
@@ -1,114 +0,0 @@
-#!/bin/bash
-
-# warning: these scripts don't work for replaces on parameters in parameter's psets
-#          see the added comment in PATLayer1_ReplaceDefaults_fast.cff
-#
-#
-# file name settings
-export baseDir=${CMSSW_BASE}/src/PhysicsTools/PatAlgos
-export parser=${CMSSW_BASE}/src/PhysicsTools/PatAlgos/scripts/patReplaceParser.pl
-export fastReplacer=${CMSSW_BASE}/src/PhysicsTools/PatAlgos/scripts/patReplaceFast.pl
-if [ ! -d $baseDir ]; then 
-  echo "*** " $baseDir not found
-  echo "*** " Please make sure to run scramv1 run -[c]sh first
-  exit -1
-fi
-export layer0FamosSetup=${baseDir}/data/famos/patLayer0_FamosSetup.cff
-export layer0FileFull=${baseDir}/test/patLayer0_ReplaceDefaults_full.cff
-export layer0FileFast=${baseDir}/test/patLayer0_ReplaceDefaults_fast.cff
-export layer1FamosSetup=${baseDir}/data/famos/patLayer1_FamosSetup.cff
-export layer1FileFull=${baseDir}/test/patLayer1_ReplaceDefaults_full.cff
-export layer1FileFast=${baseDir}/test/patLayer1_ReplaceDefaults_fast.cff
-
-# make backups of the old ones
-if [ -e $layer0FileFull ]; then mv $layer0FileFull $layer0FileFull.bak; fi
-if [ -e $layer0FileFast ]; then mv $layer0FileFast $layer0FileFast.bak; fi
-if [ -e $layer1FileFull ]; then mv $layer1FileFull $layer1FileFull.bak; fi
-if [ -e $layer1FileFast ]; then mv $layer1FileFast $layer1FileFast.bak; fi
-
-# Define input directories
-export dataDir=${baseDir}/data
-export recDir=${dataDir}/recoLayer0
-export clDir=${dataDir}/cleaningLayer0
-export mcDir=${dataDir}/mcMatchLayer0
-export prodDir=${dataDir}/producersLayer1
-export selDir=${dataDir}/selectionLayer1
-
-# produce the replace-file
-cat > $layer0FileFull << EOF
-
-############################
-### PAT Layer-0 cleaning ###
-############################
-`${parser} ${clDir}/caloJetCleaner.cfi`
-`${parser} ${clDir}/caloMetCleaner.cfi`
-`${parser} ${clDir}/electronCleaner.cfi`
-`${parser} ${clDir}/muonCleaner.cfi`
-`${parser} ${clDir}/pfTauCleaner.cfi`
-`${parser} ${clDir}/photonCleaner.cfi`
-
-###############################
-### PAT Layer-0 MC matching ###
-###############################
-`${parser} ${mcDir}/muonMatch.cfi`
-`${parser} ${mcDir}/electronMatch.cfi`
-`${parser} ${mcDir}/photonMatch.cfi`
-`${parser} ${mcDir}/tauMatch.cfi`
-`${parser} ${mcDir}/jetMatch.cfi`
-
-###############################
-### PAT Layer-0 jets        ###
-###############################
-`${parser} ${recDir}/jetTracksCharge.cff`
-
-
-EOF
-
-# adapt layer 1 replace-file for fast simulation
-cp $layer0FileFull $layer0FileFast
-${fastReplacer} $layer0FileFast $layer0FamosSetup
-
-
-# produce the replace-file
-cat > $layer1FileFull << EOF
-
-####################################
-### PAT Layer-1 object producers ###
-####################################
-`${parser} ${prodDir}/muonProducer.cfi`
-`${parser} ${prodDir}/electronProducer.cfi`
-`${parser} ${prodDir}/photonProducer.cfi`
-`${parser} ${prodDir}/tauProducer.cfi`
-`${parser} ${prodDir}/jetProducer.cfi`
-`${parser} ${prodDir}/metProducer.cfi`
-
-####################################
-### PAT Layer-1 Object Selectors ###
-####################################
-`${parser} ${selDir}/muonSelector.cfi`
-`${parser} ${selDir}/electronSelector.cfi`
-`${parser} ${selDir}/photonSelector.cfi`
-`${parser} ${selDir}/tauSelector.cfi`
-`${parser} ${selDir}/jetSelector.cfi`
-`${parser} ${selDir}/metSelector.cfi`
-
-#################################
-### PAT Layer-1 Count Filters ###
-#################################
-`${parser} ${selDir}/muonMinFilter.cfi`
-`${parser} ${selDir}/muonMaxFilter.cfi`
-`${parser} ${selDir}/electronMinFilter.cfi`
-`${parser} ${selDir}/electronMaxFilter.cfi`
-`${parser} ${selDir}/photonMinFilter.cfi`
-`${parser} ${selDir}/photonMaxFilter.cfi`
-`${parser} ${selDir}/tauMinFilter.cfi`
-`${parser} ${selDir}/tauMaxFilter.cfi`
-`${parser} ${selDir}/jetMinFilter.cfi`
-`${parser} ${selDir}/jetMaxFilter.cfi`
-`${parser} ${selDir}/leptonCountFilter.cfi`
-
-EOF
-
-# adapt layer 1 replace-file for fast simulation
-cp $layer1FileFull $layer1FileFast
-${fastReplacer} $layer1FileFast $layer1FamosSetup
diff --git a/PhysicsTools/PatAlgos/scripts/patReplaceParser.pl b/PhysicsTools/PatAlgos/scripts/patReplaceParser.pl
deleted file mode 100755
index 9be4283..0000000
--- a/PhysicsTools/PatAlgos/scripts/patReplaceParser.pl
+++ /dev/null
@@ -1,225 +0,0 @@
-#!/bin/env perl
-#
-# A script to parse cfi files for parameters to replace
-# Probably not very stable...
-#
-
-
-### To turn on verbosity, uncomment following line
-#open(MSG,">&STDERR") or die "Couldn't open stderr: $!";
-
-use strict;
-
-# Extract source name from argument
-my $config = $ARGV[0];
-(my $source = $config) =~ s/.*(CMSSW)/$1/;
-
-
-# Alignment of comments: column number
-my $alignment = 60;
-
-print "# Generated from $source\n";
-print MSG "Parsing  $source\n";
-
-open(INPUT,$config) or die "Couldn't open $config: $!";
-my $levelName = ""; # Name of current block/module
-my $lineNb = 0;
-my $isMulti = 0;
-MAIN: while( <INPUT> ) {
-  print MSG ++$lineNb."\n";
-
-  # Skip empty lines
-  next if (!/\S/);
-
-  # Skip includes
-  next if ( /\s*include\s+\".*\"/ );
-
-  # Skip commented-out lines
-  next if (m@^\s*(//|#)@);
-
-  chomp();
-  my $line = $_; # Store line
-
-  while ( $line =~ /\S/ ) {
-    # 1. Process named blocks (modules, blocks, PSets)
-    ($line,$levelName) = &processBlocks( $line, $levelName );
-
-    # 2. Skip VPSets and sequences
-    #    NB. This is fragile!
-    if ( $line =~ /(VPSet|sequence)\s+(\S+)\s*=\s*\{\s*/ ) {
-      print MSG "Found $1 with name $2: skipping\n";
-      my $nBraces = 1; # Start with one, from above matching
-      $line = $';
-      $nBraces += &countBraces( $line );
-      print MSG "$nBraces: $line\n";
-      if ( $nBraces>0 ){
-        while ( <INPUT> ) {
-          $line = $_;
-          $nBraces += &countBraces( $line );
-          print MSG "$nBraces: $line\n";
-          last if ( $nBraces <= 0 );
-        }
-      }
-      $line = "";
-      next;       # This assumes closing brace is last on line...
-    }
-
-    # 3. Process parameters (might be multiline)
-    ($line,$isMulti) = &processParameters( $line, $levelName );
-    if ( $isMulti ) { # Treat mutliline separately...
-      while (<INPUT>) {
-        print MSG ++$lineNb."\n";
-        s/^\s+//; # Remove leading spaces
-        chomp();
-        $_ = &nukeComments( $_ ); # Remove comments in that case
-        if ( /.*?\}/ ) {
-          print $line.$&."\n"; # Dump what we have found
-          $line = $';     # Store remainder in line for future use
-          $isMulti = 0;
-          last;
-        } else {
-          $line .= $_;
-        }
-      }
-      print MSG "End of span\n";
-    }
-
-    # 4. Remove remaining comments on blocks
-    $line = &nukeComments( $line );
-
-    # 5. Climb up levels if braces are closed
-    ($line,$levelName) = &closeBraces( $line, $levelName );
-  }
-}
-close(INPUT);
-
-
-#_______________________________________________________________________
-# Check line for new blocks and add them to level name
-sub processBlocks {
-
-  my $line = shift;
-  my $levelName = shift;
-
-  if ( $line =~ /(module|block|[^V]PSet)\s+(\S+)\s*=\s*(\S+)?\s*\{\s*/ ) {
-    print MSG "Found $1 with name $2".($3?" and label $3":"")."\n";
-    $levelName .= (length($levelName)>0?'.':'').$2;
-    $line = $';
-  }
-
-  return ($line,$levelName);
-}
-
-
-#_______________________________________________________________________
-# Check for new parameters
-sub processParameters{
-
-  my $line = shift;
-  my $levelName = shift;
-  my $isMulti = 0;
-
-  if ( $line =~ /([\w\d]+)\s+(\S+)\s*=\s*(.*)$/ ) {
-    my $type = $1;
-    my $name = $2;
-    my $value = $3;
-    $line = $';
-
-    # Check for un-balanced closing brace and put back on line
-    if ( $value !~ /\{/ && $value =~ /\}/ ) {
-      $value = $`;
-      $line = '}'.$line;
-    }
-
-    print MSG "Found $type with name $name and value $value";
-    # Check if this parameter spans over several lines
-    if ( $value =~ /\{/ && $value !~ /\}/ ) {
-      $isMulti++;
-      print MSG " spanning over multiple lines";
-      $value = &nukeComments($value); # Don't keep comments in that case: too disturbing
-    }
-    print MSG "\n";
-
-    # Dump out
-    &dumpReplace($levelName,$name,$value);
-    if ( !$isMulti ) { print "\n"; }
-
-  }
-
-
-  return $line,$isMulti;
-
-}
-
-#_______________________________________________________________________
-# Remove trailing comments from block definitions (can't carry them)
-sub nukeComments {
-
-  my $line = shift;
-
-  if ( $line =~ m@\s*(//|#)@ ) {
-    $line = $`;
-  }
-  return $line;
-
-} 
-
-#______________________________________________________________________
-# Close braces and adjust levelName correspondingly
-sub closeBraces {
-
-  my $line = shift;
-  my $levelName = shift;
-
-  if ( $line =~ /^\s*\}\s*/ ) {
-    my $curLevel = $levelName;
-    print MSG "Found closing brace - climbing up: '$levelName' -> ";
-    $levelName =~ s/\.[^\.]*?$//;
-    if ( $curLevel =~ /^$levelName$/ ) { # Treat special case...
-      $levelName = "";
-    }
-    $line = $';
-    print MSG "'$levelName'\n";
-  }
-  return ($line,$levelName);
-
-}
-
-#______________________________________________________________________
-# Count number of braces
-# Opening adds one, closing removes one
-sub countBraces {
-
-  my $string = shift;
-  my $nBraces = 0;
-  my $char = "";
-
-  while ( length($string)>0 ) {
-    $char = chop($string);
-    ++$nBraces if ( $char =~ /\{/ );
-    --$nBraces if ( $char =~ /\}/ );
-  }
-
-  return $nBraces;
-
-}
-
-
-#______________________________________________________________________
-# Subroutine to nicely dump the replace statements
-# Tries to align comments
-sub dumpReplace {
-  my $prefix = shift; # Level name
-  my $name   = shift; # Parameter name
-  my $string = shift; # Value, including possible comment
-
-  if ( $string =~ /(#|\/\/)\s*/ ) {
-    my $value = $`;
-    my $comment = $';
-    $value =~ s/\s+$//g; # Remove trailing spaces
-    # Alignment: add necessary spaces
-    while ( length($prefix.$name." = ".$value) < $alignment ) { $value .= " "; }
-    $string = $value." # ".$comment;
-  }
-  print "replace $prefix.$name = $string";
-}
diff --git a/PhysicsTools/PatAlgos/src/BaseIsolator.cc b/PhysicsTools/PatAlgos/src/BaseIsolator.cc
deleted file mode 100644
index 5e7918b..0000000
--- a/PhysicsTools/PatAlgos/src/BaseIsolator.cc
+++ /dev/null
@@ -1,19 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/BaseIsolator.h"
-#include <sstream>
-#include <iomanip>
-
-using pat::helper::BaseIsolator;
-
-BaseIsolator::BaseIsolator(const edm::ParameterSet &conf, bool withCut) :
-    input_(conf.getParameter<edm::InputTag>("src")),
-    cut_(withCut ? conf.getParameter<double>("cut") : -2.0),
-    try_(0), fail_(0)
-{
-}
-
-void 
-BaseIsolator::print(std::ostream &out) const {
-    using namespace std;
-    out << description() << " < " << cut_ << ": try " << try_ << ", fail " << fail_;
-}
-
diff --git a/PhysicsTools/PatAlgos/src/EfficiencyLoader.cc b/PhysicsTools/PatAlgos/src/EfficiencyLoader.cc
deleted file mode 100644
index 3a2e0be..0000000
--- a/PhysicsTools/PatAlgos/src/EfficiencyLoader.cc
+++ /dev/null
@@ -1,27 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/EfficiencyLoader.h"
-
-#include <algorithm>
-
-using pat::helper::EfficiencyLoader;
-
-EfficiencyLoader::EfficiencyLoader(const edm::ParameterSet &iConfig) 
-{
-    // Get the names (sorted)
-    names_ = iConfig.getParameterNamesForType<edm::InputTag>();
-    std::sort(names_.begin(), names_.end());
-    
-    // get the InputTags
-    for (std::vector<std::string>::const_iterator it = names_.begin(), ed = names_.end(); it != ed; ++it) {
-        tags_.push_back( iConfig.getParameter<edm::InputTag>(*it) );
-    }
-
-    // prepare the Handles
-    handles_.resize(names_.size());
-}
-
-void
-EfficiencyLoader::newEvent(const edm::Event &iEvent) const {
-    for (size_t i = 0, n = names_.size(); i < n; ++i) {
-        iEvent.getByLabel(tags_[i], handles_[i]);
-    }    
-}
diff --git a/PhysicsTools/PatAlgos/src/HemisphereAlgo.cc b/PhysicsTools/PatAlgos/src/HemisphereAlgo.cc
deleted file mode 100644
index 78c5d962..0000000
--- a/PhysicsTools/PatAlgos/src/HemisphereAlgo.cc
+++ /dev/null
@@ -1,393 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/HemisphereAlgo.h"
-
-#include "FWCore/MessageLogger/interface/MessageLogger.h"
-
-#include "DataFormats/Math/interface/deltaPhi.h"
-#include "DataFormats/Math/interface/deltaR.h"
-
-using namespace std;
-using std::vector;
-
-HemisphereAlgo::HemisphereAlgo(const std::vector<reco::CandidatePtr>& componentPtr_,const int seed_method, const int hemisphere_association_method )
-  : Object(componentPtr_), Object_Group() , Axis1(), Axis2(), seed_meth(seed_method), hemi_meth(hemisphere_association_method), status(0) {
-
-  for(int i = 0; i < (int) Object.size(); i++){
-    Object_Noseed.push_back(0);
-  }
-
-}   
-
-
-   
-vector<float> HemisphereAlgo::getAxis1(){
-  if (status != 1){this->reconstruct();}   
-  return Axis1;
-}   
-vector<float> HemisphereAlgo::getAxis2(){
-  if (status != 1){this->reconstruct();}  
-  return Axis2;
-}
-
-vector<int> HemisphereAlgo::getGrouping(){
-  if (status != 1){this->reconstruct();}  
-  return Object_Group;
-}
-
-int HemisphereAlgo::reconstruct(){
-
-     int vsize = (int) Object.size();
-
-  LogDebug("HemisphereAlgo") << " HemisphereAlgo method ";
-  
-  Object_Group.clear();
-  Axis1.clear();
-  Axis2.clear();
-
-  for(int j = 0; j < vsize; j++){
-    Object_Group.push_back(0);
-  }
-
-  for(int j = 0; j < 5; j++){
-    Axis1.push_back(0);
-    Axis2.push_back(0);
-  }
-  
- 
-  for (int i = 0; i <vsize; i++){
-   
-    if ( (*(Object)[i]).p() > (*Object[i]).energy() + 0.001) { 
- 
-      edm::LogWarning("HemisphereAlgo") << "Object " << i << " has E = " << (*Object[i]).energy()
-                                        << " less than P = " << (*Object[i]).p() ;
-    
-    } 
-  } 
-
-   
-   
-  LogDebug("HemisphereAlgo") << " Seeding method = " << seed_meth;
-  int I_Max = -1;
-  int J_Max = -1;
-   
-  if (seed_meth == 1) {
-    
-    float P_Max = 0.;
-    float DeltaRP_Max = 0.;
-       
-    // take highest momentum object as first axis   
-    for (int i=0;i<vsize;i++){    
-      Object_Group[i] = 0;
-      if (Object_Noseed[i] == 0 && P_Max < (*Object[i]).p()){
-        P_Max = (*Object[i]).p();
-        I_Max = i; 
-      }           
-    }
-    
-    Axis1[0] = (*Object[I_Max]).px() /  (*Object[I_Max]).p();
-    Axis1[1] = (*Object[I_Max]).py() /  (*Object[I_Max]).p();
-    Axis1[2] = (*Object[I_Max]).pz() /  (*Object[I_Max]).p();
-    Axis1[3] = (*Object[I_Max]).p();
-    Axis1[4] = (*Object[I_Max]).energy();
-    
-    // take as second axis
-    for (int i=0;i<vsize;i++){     
-      
-      float DeltaR = deltaR((*Object[i]).eta(),(*Object[i]).phi(),(*Object[I_Max]).eta(),(*Object[I_Max]).phi()) ;   
-      
-      if (Object_Noseed[i] == 0 && DeltaR > 0.5) { 
-    
-        float DeltaRP = DeltaR * (*Object[i]).p();       
-        if (DeltaRP > DeltaRP_Max){
-          DeltaRP_Max = DeltaRP;
-          J_Max = i;
-	}	
-      }
-    } 
-    
-    if (J_Max >=0){
-      Axis2[0] = (*Object[J_Max]).px() /  (*Object[J_Max]).p();
-      Axis2[1] =(*Object[J_Max]).py() /  (*Object[J_Max]).p();
-      Axis2[2] = (*Object[J_Max]).pz() /  (*Object[J_Max]).p();
-      Axis2[3] = (*Object[J_Max]).p();
-      Axis2[4] = (*Object[J_Max]).energy();
-     
-    } else {   
-      return 0;
-    }
-    LogDebug("HemisphereAlgo") << " Axis 1 is Object = " << I_Max;
-    LogDebug("HemisphereAlgo") << " Axis 2 is Object = " << J_Max;
-
-   
-  } else if ( (seed_meth == 2) | (seed_meth == 3)  ) {
-
-    float Mass_Max = 0.;
-    float InvariantMass = 0.;
-    
-    // maximize the invariant mass of two objects
-    for (int i=0;i<vsize;i++){    
-      Object_Group[i] = 0;
-      if (Object_Noseed[i] == 0){ 
-        for (int j=i+1;j<vsize;j++){  
-          if (Object_Noseed[j] == 0){ 
-
-            // either the invariant mass
-            if (seed_meth == 2){
-              InvariantMass =  ((*Object[i]).energy() +  (*Object[j]).energy())* ((*Object[i]).energy() + (*Object[j]).energy())
-                - ((*Object[i]).px() + (*Object[j]).px())* ((*Object[i]).px() + (*Object[j]).px()) 
-                - ((*Object[i]).py() + (*Object[j]).py())* ((*Object[i]).py() + (*Object[j]).py())
-                - ((*Object[i]).pz() + (*Object[j]).pz())* ((*Object[i]).pz() + (*Object[j]).pz()) ;  
-            } 
-            // or the transverse mass
-            else if (seed_meth == 3){
-              float pti = sqrt((*Object[i]).px()*(*Object[i]).px() + (*Object[i]).py()*(*Object[i]).py());
-              float ptj = sqrt((*Object[j]).px()*(*Object[j]).px() + (*Object[j]).py()*(*Object[j]).py());
-              InvariantMass =  2. * (pti*ptj - (*Object[i]).px()*(*Object[j]).px()
-                                     - (*Object[i]).py()*(*Object[j]).py() );
-            }
-            if ( Mass_Max < InvariantMass){
-              Mass_Max = InvariantMass;
-              I_Max = i;
-              J_Max = j;
-            }
-          }               
-        }
-      }
-    }
-    
-    if (J_Max>0) {
-
-      Axis1[0] = (*Object[I_Max]).px() /  (*Object[I_Max]).p();
-      Axis1[1] = (*Object[I_Max]).py() /  (*Object[I_Max]).p();
-      Axis1[2] = (*Object[I_Max]).pz() /  (*Object[I_Max]).p();
-    
-      Axis1[3] = (*Object[I_Max]).p();
-      Axis1[4] = (*Object[I_Max]).energy(); 
-  
-      Axis2[0] = (*Object[J_Max]).px() /  (*Object[J_Max]).p();
-      Axis2[1] =(*Object[J_Max]).py() /  (*Object[J_Max]).p();
-      Axis2[2] = (*Object[J_Max]).pz() /  (*Object[J_Max]).p();
-    
-      Axis2[3] = (*Object[J_Max]).p();
-      Axis2[4] = (*Object[J_Max]).energy(); 
-
-    } else {
-      return 0;
-    }
-    LogDebug("HemisphereAlgo") << " Axis 1 is Object = " << I_Max;
-    LogDebug("HemisphereAlgo") << " Axis 2 is Object = " << J_Max;
-    
-    
-  } else {
-    throw cms::Exception("Configuration") << "Please give a valid seeding method!";
-  }
-   
-  // seeding done 
-  // now do the hemisphere association
-   
-  LogDebug("HemisphereAlgo") << " Association method = " << hemi_meth;
-
-  int numLoop = 0;
-  bool I_Move = true;
-
-
-  while (I_Move && (numLoop < 100)){
-
-    I_Move = false;
-    numLoop++;
-    LogDebug("HemisphereAlgo")  << " Iteration = " << numLoop;
-   
-    float Sum1_Px = 0.;
-    float Sum1_Py = 0.;
-    float Sum1_Pz = 0.;
-    float Sum1_P = 0.;
-    float Sum1_E = 0.; 
-    float Sum2_Px = 0.;
-    float Sum2_Py = 0.;
-    float Sum2_Pz = 0.;
-    float Sum2_P = 0.;
-    float Sum2_E = 0.; 
-   
-    
-    if (hemi_meth == 1) {
-       
-      for (int i=0;i<vsize;i++){  
-        float  P_Long1 = (*Object[i]).px()*Axis1[0] + (*Object[i]).py()*Axis1[1] + (*Object[i]).pz()*Axis1[2];
-        float  P_Long2 = (*Object[i]).px()*Axis2[0]+ (*Object[i]).py()*Axis2[1] + (*Object[i]).pz()*Axis2[2];
-        if (P_Long1 >= P_Long2){
-          if (Object_Group[i] != 1){ 
-	    I_Move = true;
-	  }      
-          Object_Group[i] = 1;
-	  Sum1_Px += (*Object[i]).px();
-	  Sum1_Py += (*Object[i]).py();
-	  Sum1_Pz += (*Object[i]).pz();
-	  Sum1_P += (*Object[i]).p();
-	  Sum1_E += (*Object[i]).energy(); 
-        } else {
-          if (Object_Group[i] != 2){ 
-	    I_Move = true;
-	  }
-          Object_Group[i] = 2;
-	  Sum2_Px += (*Object[i]).px();
-	  Sum2_Py += (*Object[i]).py();
-	  Sum2_Pz += (*Object[i]).pz();
-	  Sum2_P += (*Object[i]).p();
-	  Sum2_E += (*Object[i]).energy(); 
-        }
-      }
-    
-    } else if (hemi_meth == 2 || hemi_meth == 3){
-    
-      for (int i=0;i<vsize;i++){  
-        if (i == I_Max) {
-	  Object_Group[i] = 1;
-	  Sum1_Px += (*Object[i]).px();
-	  Sum1_Py += (*Object[i]).py();
-	  Sum1_Pz += (*Object[i]).pz();
-	  Sum1_P += (*Object[i]).p();
-	  Sum1_E += (*Object[i]).energy(); 
-	} else if (i == J_Max) {
-	  Object_Group[i] = 2;
-	  Sum2_Px += (*Object[i]).px();
-	  Sum2_Py += (*Object[i]).py();
-	  Sum2_Pz += (*Object[i]).pz();
-	  Sum2_P += (*Object[i]).p();
-	  Sum2_E += (*Object[i]).energy(); 
-        } else {
-	
-	
-          if(!I_Move){ 
-	  
-            float NewAxis1_Px = Axis1[0] * Axis1[3];
-            float NewAxis1_Py = Axis1[1] * Axis1[3];
-            float NewAxis1_Pz = Axis1[2] * Axis1[3];
-            float NewAxis1_E = Axis1[4];
-	 
-            float NewAxis2_Px = Axis2[0] * Axis2[3];
-            float NewAxis2_Py = Axis2[1] * Axis2[3];
-            float NewAxis2_Pz = Axis2[2] * Axis2[3];
-            float NewAxis2_E = Axis2[4];
-       
-            if (Object_Group[i] == 1){
-	  
-              NewAxis1_Px = NewAxis1_Px - (*Object[i]).px();
-              NewAxis1_Py = NewAxis1_Py - (*Object[i]).py();
-              NewAxis1_Pz = NewAxis1_Pz - (*Object[i]).pz();
-              NewAxis1_E = NewAxis1_E - (*Object[i]).energy(); 
-	 
-            } else if (Object_Group[i] == 2) {
-	 
-              NewAxis2_Px = NewAxis2_Px - (*Object[i]).px();
-              NewAxis2_Py = NewAxis2_Py - (*Object[i]).py();
-              NewAxis2_Pz = NewAxis2_Pz - (*Object[i]).pz();
-              NewAxis2_E = NewAxis2_E - (*Object[i]).energy();
-            }
-               
-	  
-            float mass1 =  NewAxis1_E - (((*Object[i]).px()*NewAxis1_Px + (*Object[i]).py()*NewAxis1_Py +
-                                          (*Object[i]).pz()*NewAxis1_Pz)/(*Object[i]).p());
-	 
-            float mass2 =  NewAxis2_E - (((*Object[i]).px()*NewAxis2_Px + (*Object[i]).py()*NewAxis2_Py +
-                                          (*Object[i]).pz()*NewAxis2_Pz)/(*Object[i]).p());
-	 
-            if (hemi_meth == 3) {
-	 
-              mass1 *= NewAxis1_E/((NewAxis1_E+(*Object[i]).energy())*(NewAxis1_E+(*Object[i]).energy()));
-	 
-              mass2 *= NewAxis2_E/((NewAxis2_E+(*Object[i]).energy())*(NewAxis2_E+(*Object[i]).energy()));
-	
-            }
-	 
-            if(mass1 < mass2) {
-              if (Object_Group[i] != 1){ 
-                I_Move = true;
-              }
-              Object_Group[i] = 1;
-       
-              Sum1_Px += (*Object[i]).px();
-              Sum1_Py += (*Object[i]).py();
-              Sum1_Pz += (*Object[i]).pz();
-              Sum1_P += (*Object[i]).p();
-              Sum1_E += (*Object[i]).energy(); 
-            } else {
-              if (Object_Group[i] != 2){ 
-                I_Move = true;
-              }
-              Object_Group[i] = 2;
-              Sum2_Px += (*Object[i]).px();
-              Sum2_Py += (*Object[i]).py();
-              Sum2_Pz += (*Object[i]).pz();
-              Sum2_P += (*Object[i]).p();
-              Sum2_E += (*Object[i]).energy(); 
-	 
-            }
-      
-      
-          } else {
-	
-            if (Object_Group[i] == 1){
-              Sum1_Px += (*Object[i]).px();
-              Sum1_Py += (*Object[i]).py();
-              Sum1_Pz += (*Object[i]).pz();
-              Sum1_P += (*Object[i]).p();
-              Sum1_E += (*Object[i]).energy(); 
-            }
-            if (Object_Group[i] == 2){
-              Sum2_Px += (*Object[i]).px();
-              Sum2_Py += (*Object[i]).py();
-              Sum2_Pz += (*Object[i]).pz();
-              Sum2_P += (*Object[i]).p();
-              Sum2_E += (*Object[i]).energy(); 
-            }
-         
-	
-	
-          }
-	
-	
-        }
-      }
-    } else {
-      throw cms::Exception("Configuration") 
-        << "Please give a valid hemisphere association method!";
-    }
-    
-    // recomputing the axes     
-
-    Axis1[3] = sqrt(Sum1_Px*Sum1_Px + Sum1_Py*Sum1_Py + Sum1_Pz*Sum1_Pz);
-    if (Axis1[3]<0.0001) {
-      edm::LogWarning("HemisphereAlgo") << "ZERO objects in group 1! "; 
-    } else {    
-      Axis1[0] = Sum1_Px / Axis1[3];   
-      Axis1[1] = Sum1_Py / Axis1[3];
-      Axis1[2] = Sum1_Pz / Axis1[3];
-      Axis1[4] = Sum1_E; 
-    }
-    
-   
-    
-    Axis2[3] = sqrt(Sum2_Px*Sum2_Px + Sum2_Py*Sum2_Py + Sum2_Pz*Sum2_Pz);
-    if (Axis2[3]<0.0001) {
-      edm::LogWarning("HemisphereAlgo") << "ZERO objects in group 2!";
-    } else {  
-      Axis2[0] = Sum2_Px / Axis2[3];   
-      Axis2[1] = Sum2_Py / Axis2[3];
-      Axis2[2] = Sum2_Pz / Axis2[3];
-      Axis2[4] = Sum2_E; 
-    }
-
-    LogDebug("HemisphereAlgo") << " Grouping = ";
-    for (int i=0;i<vsize;i++){  
-      LogTrace("HemisphereAlgo") << "  " << Object_Group[i];
-    }
-    LogTrace("HemisphereAlgo") << std::endl;
-    
-  }
-  
-        
-  status = 1;
-  return 1;
-}
-
-
- 
diff --git a/PhysicsTools/PatAlgos/src/IsoDepositIsolator.cc b/PhysicsTools/PatAlgos/src/IsoDepositIsolator.cc
deleted file mode 100644
index 32d890b..0000000
--- a/PhysicsTools/PatAlgos/src/IsoDepositIsolator.cc
+++ /dev/null
@@ -1,104 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/IsoDepositIsolator.h"
-#include <sstream>
-
-#include "DataFormats/RecoCandidate/interface/IsoDepositVetos.h"
-#include "PhysicsTools/IsolationAlgos/interface/IsoDepositVetoFactory.h"
-
-#include <boost/regex.hpp>
-
-using pat::helper::IsoDepositIsolator;
-using pat::helper::BaseIsolator;
-using namespace reco::isodeposit;
-
-IsoDepositIsolator::IsoDepositIsolator(const edm::ParameterSet &conf, bool withCut) :
-    BaseIsolator(conf,withCut), deltaR_(conf.getParameter<double>("deltaR")), 
-    mode_(Sum), skipDefaultVeto_(false)
-{
-    if (conf.exists("mode")) {
-        std::string mode = conf.getParameter<std::string>("mode");
-        if (mode == "sum") mode_ = Sum;
-        else if (mode == "sumRelative") mode_ = SumRelative;
-        else if (mode == "max") mode_ = Max;                  
-        else if (mode == "maxRelative") mode_ = MaxRelative;  
-        else if (mode == "sum2") mode_ = Sum2;
-        else if (mode == "sum2Relative") mode_ = Sum2Relative;
-        else if (mode == "count") mode_ = Count;
-        else throw cms::Exception("Not Implemented") << "Mode '" << mode << "' not implemented. " <<
-                "Supported modes are 'sum', 'sumRelative', 'max', 'maxRelative', 'sum2', 'sum2Relative', 'count'." <<
-                "New methods can be easily implemented if requested.";
-    }
-
-    if (conf.exists("veto")) {
-        vetos_.push_back(new ConeVeto(Direction(), conf.getParameter<double>("veto"))); 
-    }
-    if (conf.exists("threshold")) {
-        vetos_.push_back(new ThresholdVeto(conf.getParameter<double>("threshold"))); 
-    }
-    if (conf.exists("skipDefaultVeto")) {
-        skipDefaultVeto_ = conf.getParameter<bool>("skipDefaultVeto");
-    }
-
-    if (conf.exists("vetos")) { // expert configuration
-        if (!vetos_.empty()) 
-            throw cms::Exception("Configuration") << "You can't both configure this module with 'veto'/'threshold' AND with 'vetos'!";
-        if (!conf.exists("skipDefaultVeto")) 
-            throw cms::Exception("Configuration") << "When using the expert configuration variable 'vetos' you must specify the value for 'skipDefaultVeto' too.";
-
-        typedef std::vector<std::string> vstring;
-        vstring vetos = conf.getParameter< vstring >("vetos");
-        reco::isodeposit::EventDependentAbsVeto *evdep = 0;
-        for (vstring::const_iterator it = vetos.begin(), ed = vetos.end(); it != ed; ++it) {
-              vetos_.push_back( IsoDepositVetoFactory::make( it->c_str(), evdep ) );
-              if (evdep != 0) evdepVetos_.push_back(evdep);
-        }
-    }
-
-}
-
-IsoDepositIsolator::~IsoDepositIsolator() {
-    for (AbsVetos::iterator it = vetos_.begin(), ed = vetos_.end(); it != ed; ++it) {
-        delete *it;
-    }
-}
-
-void
-IsoDepositIsolator::beginEvent(const edm::Event &event, const edm::EventSetup &eventSetup) {
-    event.getByLabel(input_, handle_);
-    for (EventDependentAbsVetos::iterator it = evdepVetos_.begin(), ed = evdepVetos_.end(); it != ed; ++it) {
-        (*it)->setEvent(event,eventSetup);
-    }
-}
-
-void
-IsoDepositIsolator::endEvent() {
-    handle_.clear();
-}
-
-std::string 
-IsoDepositIsolator::description() const {
-    using namespace std;
-    ostringstream oss;
-    oss << input_.encode() << "(dR=" << deltaR_ <<")";
-    return oss.str();
-}
-
-float
-IsoDepositIsolator::getValue(const edm::ProductID &id, size_t index) const {
-    const reco::IsoDeposit &dep = handle_->get(id, index);
-
-    double eta = dep.eta(), phi = dep.phi(); // better to center on the deposit direction that could be, e.g., the impact point at calo
-    for (AbsVetos::const_iterator it = vetos_.begin(), ed = vetos_.end(); it != ed; ++it) {
-        (const_cast<AbsVeto *>(*it))->centerOn(eta, phi); // I need the const_cast to be able to 'move' the veto
-    }
-    switch (mode_) {
-        case Count:        return dep.countWithin(deltaR_, vetos_, skipDefaultVeto_);
-        case Sum:          return dep.sumWithin(deltaR_, vetos_, skipDefaultVeto_);
-        case SumRelative:  return dep.sumWithin(deltaR_, vetos_, skipDefaultVeto_) / dep.candEnergy() ;
-        case Sum2:         return dep.sum2Within(deltaR_, vetos_, skipDefaultVeto_);
-        case Sum2Relative: return dep.sum2Within(deltaR_, vetos_, skipDefaultVeto_) / (dep.candEnergy() * dep.candEnergy()) ;
-        case Max:          return dep.maxWithin(deltaR_, vetos_, skipDefaultVeto_);
-        case MaxRelative:  return dep.maxWithin(deltaR_, vetos_, skipDefaultVeto_) / dep.candEnergy() ;
-    }
-    throw cms::Exception("Logic error") << "Should not happen at " << __FILE__ << ", line " << __LINE__; // avoid gcc warning
-}
-
diff --git a/PhysicsTools/PatAlgos/src/KinResolutionsLoader.cc b/PhysicsTools/PatAlgos/src/KinResolutionsLoader.cc
deleted file mode 100644
index 6b6e7ad..0000000
--- a/PhysicsTools/PatAlgos/src/KinResolutionsLoader.cc
+++ /dev/null
@@ -1,41 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/KinResolutionsLoader.h"
-#include "PhysicsTools/PatAlgos/interface/KinematicResolutionRcd.h"
-
-#include <algorithm>
-
-using pat::helper::KinResolutionsLoader;
-
-KinResolutionsLoader::KinResolutionsLoader(const edm::ParameterSet &iConfig) 
-{
-    // Get the names (sorted)
-    patlabels_ = iConfig.getParameterNamesForType<std::string>();
-    
-    // get the InputTags
-    for (std::vector<std::string>::const_iterator it = patlabels_.begin(), ed = patlabels_.end(); it != ed; ++it) {
-        eslabels_.push_back( iConfig.getParameter<std::string>(*it) );
-    }
-
-    // prepare the Handles
-    handles_.resize(patlabels_.size());
-
-    // 'default' maps to empty string
-    for (std::vector<std::string>::iterator it = patlabels_.begin(), ed = patlabels_.end(); it != ed; ++it) {
-        if (*it == "default") *it = "";
-    }
-}
-
-void
-KinResolutionsLoader::newEvent(const edm::Event &iEvent, const edm::EventSetup &iSetup) const {
-    for (size_t i = 0, n = patlabels_.size(); i < n; ++i) {
-        iSetup.get<KinematicResolutionRcd>().get(eslabels_[i], handles_[i]);
-        handles_[i]->setup(iSetup);
-    }    
-}
-
-void 
-KinResolutionsLoader::fillDescription(edm::ParameterSetDescription & iDesc) {
-    iDesc.add<bool>("addResolutions",false)->setComment("Add resolutions into this PAT Object");
-    edm::ParameterSetDescription resolutionPSet;
-    resolutionPSet.setAllowAnything();
-    iDesc.addOptional("resolutions", resolutionPSet)->setComment("Resolution values to get from EventSetup");
-}
diff --git a/PhysicsTools/PatAlgos/src/KinematicResolutionRcd.cc b/PhysicsTools/PatAlgos/src/KinematicResolutionRcd.cc
deleted file mode 100644
index e793deb..0000000
--- a/PhysicsTools/PatAlgos/src/KinematicResolutionRcd.cc
+++ /dev/null
@@ -1,19 +0,0 @@
-// -*- C++ -*-
-//
-// Package:     PatAlgos
-// Class  :     KinematicResolutionRcd
-// 
-// Implementation:
-//     <Notes on implementation>
-//
-// Author:      
-// Created:     Sun Jun 24 16:53:34 CEST 2007
-// $Id: KinematicResolutionRcd.cc,v 1.3 2010/02/20 21:00:30 wmtan Exp $
-
-#include "PhysicsTools/PatAlgos/interface/KinematicResolutionRcd.h"
-#include "PhysicsTools/PatAlgos/interface/KinematicResolutionProvider.h"
-#include "FWCore/Utilities/interface/typelookup.h"
-#include "FWCore/Framework/interface/eventsetuprecord_registration_macro.h"
-
-TYPELOOKUP_DATA_REG(KinematicResolutionProvider);
-EVENTSETUP_RECORD_REG(KinematicResolutionRcd);
diff --git a/PhysicsTools/PatAlgos/src/MultiIsolator.cc b/PhysicsTools/PatAlgos/src/MultiIsolator.cc
deleted file mode 100644
index e47299f..0000000
--- a/PhysicsTools/PatAlgos/src/MultiIsolator.cc
+++ /dev/null
@@ -1,95 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/MultiIsolator.h"
-#include "PhysicsTools/PatAlgos/interface/SimpleIsolator.h"
-#include "PhysicsTools/PatAlgos/interface/IsoDepositIsolator.h"
-#include "DataFormats/PatCandidates/interface/Flags.h"
-#include <sstream>
-
-using namespace pat::helper;
-
-MultiIsolator::MultiIsolator(const edm::ParameterSet &conf, bool cuts) {
-    using pat::Flags;
-    if (conf.exists("tracker")) addIsolator(conf.getParameter<edm::ParameterSet>("tracker"), cuts, Flags::Isolation::Tracker, pat::TrackIso);
-    if (conf.exists("ecal"))    addIsolator(conf.getParameter<edm::ParameterSet>("ecal"),    cuts, Flags::Isolation::ECal, pat::EcalIso);
-    if (conf.exists("hcal"))    addIsolator(conf.getParameter<edm::ParameterSet>("hcal"),    cuts, Flags::Isolation::HCal, pat::HcalIso);
-    if (conf.exists("calo"))    addIsolator(conf.getParameter<edm::ParameterSet>("calo"),    cuts, Flags::Isolation::Calo, pat::CaloIso);
-    if (conf.exists("calo") && (conf.exists("ecal") || conf.exists("hcal"))) {
-        throw cms::Exception("Configuration") << 
-            "MultiIsolator: you can't specify both 'calo' isolation and 'ecal'/'hcal', " <<
-            "as the 'calo' isolation flag is just the logical OR of 'ecal' and 'hcal'.\n";                            
-    }
-    if (conf.exists("pfAllParticles"))  addIsolator(conf.getParameter<edm::ParameterSet>("pfAllParticles"), cuts,Flags::Isolation::Calo, pat::PfAllParticleIso); 	 
-    if (conf.exists("pfChargedHadron")) addIsolator(conf.getParameter<edm::ParameterSet>("pfChargedHadron"), cuts,Flags::Isolation::Calo, pat::PfChargedHadronIso); 	 
-    if (conf.exists("pfNeutralHadron")) addIsolator(conf.getParameter<edm::ParameterSet>("pfNeutralHadron"), cuts,Flags::Isolation::Calo, pat::PfNeutralHadronIso); 	 
-    if (conf.exists("pfGamma"))         addIsolator(conf.getParameter<edm::ParameterSet>("pfGamma"), cuts,Flags::Isolation::Calo, pat::PfGammaIso);
-    if (conf.exists("user")) {
-   
-        std::vector<edm::ParameterSet> psets = conf.getParameter<std::vector<edm::ParameterSet> >("user");
-        if (psets.size() > 5) {
-            throw cms::Exception("Configuration") << 
-                "MultiIsolator: you can specify at most 5 user isolation collections.\n";            
-        }
-        uint32_t bit = Flags::Isolation::User1;
-        for (std::vector<edm::ParameterSet>::const_iterator it = psets.begin(), ed = psets.end(); it != ed; ++it, bit <<= 1) {
-            addIsolator(*it, cuts, bit, pat::IsolationKeys(pat::UserBaseIso + (it - psets.begin())));
-        }
-    }
-}
-
-
-void 
-MultiIsolator::addIsolator(BaseIsolator *iso, uint32_t mask, pat::IsolationKeys key) {
-    isolators_.push_back(iso);
-    masks_.push_back(mask); 
-    keys_.push_back(key);
-}
-
-BaseIsolator * 
-MultiIsolator::make(const edm::ParameterSet &conf, bool withCut) {
-    if (conf.empty()) return 0;
-    if (conf.exists("placeholder") && conf.getParameter<bool>("placeholder")) return 0;
-    if (conf.exists("deltaR")) {
-        return new IsoDepositIsolator(conf, withCut);
-    } else {
-        return new SimpleIsolator(conf, withCut);
-    }
-}
-
-
-void 
-MultiIsolator::addIsolator(const edm::ParameterSet &conf, bool withCut, uint32_t mask, pat::IsolationKeys key) {
-   BaseIsolator * iso = make(conf, withCut);
-    if (iso) addIsolator(iso, mask, key);
-}
-
-
-void
-MultiIsolator::beginEvent(const edm::Event &event, const edm::EventSetup &eventSetup) {
-    for (boost::ptr_vector<BaseIsolator>::iterator it = isolators_.begin(), ed = isolators_.end(); it != ed; ++it) {
-        it->beginEvent(event, eventSetup);
-    }
-}
-
-void
-MultiIsolator::endEvent() {
-    for (boost::ptr_vector<BaseIsolator>::iterator it = isolators_.begin(), ed = isolators_.end(); it != ed; ++it) {
-        it->endEvent();
-    }
-}
-
-void
-MultiIsolator::print(std::ostream &out) const {
-    for (boost::ptr_vector<BaseIsolator>::const_iterator it = isolators_.begin(), ed = isolators_.end(); it != ed; ++it) {
-        out << " * ";
-        it->print(out); 
-        out << ": Flag " << pat::Flags::bitToString( masks_[it - isolators_.begin()] ) << "\n";
-    }    
-    out << "\n";
-}
-
-std::string 
-MultiIsolator::printSummary() const {
-    std::ostringstream isoSumm;
-    print(isoSumm);
-    return isoSumm.str();
-}
-
diff --git a/PhysicsTools/PatAlgos/src/OverlapTest.cc b/PhysicsTools/PatAlgos/src/OverlapTest.cc
deleted file mode 100644
index b89755a..0000000
--- a/PhysicsTools/PatAlgos/src/OverlapTest.cc
+++ /dev/null
@@ -1,78 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/OverlapTest.h"
-
-#include <algorithm>
-#include "DataFormats/Math/interface/deltaR.h"
-#include "DataFormats/Candidate/interface/OverlapChecker.h"
-
-using namespace pat::helper;
-
-void
-BasicOverlapTest::readInput(const edm::Event & iEvent, const edm::EventSetup &iSetup) 
-{
-    iEvent.getByLabel(src_, candidates_);
-    isPreselected_.resize(candidates_->size());
-    size_t idx = 0;
-    for (reco::CandidateView::const_iterator it = candidates_->begin(); it != candidates_->end(); ++it, ++idx) {
-        isPreselected_[idx] = presel_(*it);
-    }
-    // Yes, I could use std::transform. But would people like it?
-    // http://www.sgi.com/tech/stl/transform.html
-}
-
-bool
-BasicOverlapTest::fillOverlapsForItem(const reco::Candidate &item, reco::CandidatePtrVector &overlapsToFill) const 
-{
-    size_t idx = 0;
-    std::vector<std::pair<float,size_t> > matches;
-    for (reco::CandidateView::const_iterator it = candidates_->begin(); it != candidates_->end(); ++it, ++idx) {
-        if (!isPreselected_[idx]) continue;
-        double dr = reco::deltaR(item, *it);
-        if (dr < deltaR_) {
-            if (checkRecoComponents_) {
-                OverlapChecker overlaps;
-                if (!overlaps(item, *it)) continue;
-            }
-            if (!pairCut_(pat::DiObjectProxy(item,*it))) continue;
-            matches.push_back(std::make_pair(dr, idx));
-        }
-    }
-    // see if we matched anything
-    if (matches.empty()) return false;
-
-    // sort matches
-    std::sort(matches.begin(), matches.end());
-    // fill ptr vector
-    for (std::vector<std::pair<float,size_t> >::const_iterator it = matches.begin(); it != matches.end(); ++it) {
-        overlapsToFill.push_back(candidates_->ptrAt(it->second));
-    }
-    return true;
-}
-
-bool
-OverlapBySuperClusterSeed::fillOverlapsForItem(const reco::Candidate &item, reco::CandidatePtrVector &overlapsToFill) const
-{
-    const reco::RecoCandidate * input = dynamic_cast<const reco::RecoCandidate *>(&item);
-    if (input == 0) throw cms::Exception("Type Error") << "Input to OverlapBySuperClusterSeed is not a RecoCandidate. " 
-                                                       << "It's a " << typeid(item).name() << "\n";
-    reco::SuperClusterRef mySC = input->superCluster();
-    if (mySC.isNull() || !mySC.isAvailable()) {
-        throw cms::Exception("Bad Reference") << "Input to OverlapBySuperClusterSeed has a null or dangling superCluster reference\n";
-    }
-    const reco::CaloClusterPtr & mySeed = mySC->seed();
-    if (mySeed.isNull()) {
-        throw cms::Exception("Bad Reference") << "Input to OverlapBySuperClusterSeed has a null superCluster seed reference\n";
-    }
-    bool hasOverlaps = false;
-    size_t idx = 0;
-    for (edm::View<reco::RecoCandidate>::const_iterator it = others_->begin(); it != others_->end(); ++it, ++idx) {
-        reco::SuperClusterRef otherSc = it->superCluster();
-        if (otherSc.isNull() || !otherSc.isAvailable()) {
-            throw cms::Exception("Bad Reference") << "One item in the OverlapBySuperClusterSeed input list has a null or dangling superCluster reference\n";
-        }
-        if (mySeed == otherSc->seed()) {
-            overlapsToFill.push_back(others_->ptrAt(idx));
-            hasOverlaps = true;
-        }
-    }
-    return hasOverlaps;
-}
diff --git a/PhysicsTools/PatAlgos/src/PATPrimaryVertexSelector.cc b/PhysicsTools/PatAlgos/src/PATPrimaryVertexSelector.cc
deleted file mode 100644
index 40e5c84..0000000
--- a/PhysicsTools/PatAlgos/src/PATPrimaryVertexSelector.cc
+++ /dev/null
@@ -1,60 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/PATPrimaryVertexSelector.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "DataFormats/TrackReco/interface/Track.h"
-#include "DataFormats/TrackReco/interface/TrackFwd.h"
-
-PATPrimaryVertexSelector::PATPrimaryVertexSelector (const edm::ParameterSet& cfg) :
-  multiplicityCut_(cfg.getParameter<unsigned int>("minMultiplicity")),
-  ptSumCut_(cfg.getParameter<double>("minPtSum")),
-  trackEtaCut_(cfg.getParameter<double>("maxTrackEta")),
-  chi2Cut_(cfg.getParameter<double>("maxNormChi2")),
-  dr2Cut_(cfg.getParameter<double>("maxDeltaR")),
-  dzCut_(cfg.getParameter<double>("maxDeltaZ")) {
-  // store squared cut (avoid using sqrt() for each vertex)
-  dr2Cut_ *= dr2Cut_;
-}
-
-void
-PATPrimaryVertexSelector::select (const edm::Handle<collection>& handle, 
-				  const edm::Event& event,
-				  const edm::EventSetup& setup) {
-  selected_.clear();
-  // FIXME: the fixed reference point should be replaced with the measured beamspot
-  const math::XYZPoint beamSpot(0.,0.,0.);
-  unsigned int multiplicity;
-  double ptSum;
-  for ( collection::const_iterator iv=handle->begin(); iv!=handle->end(); ++iv ) {
-    math::XYZVector displacement(iv->position()-beamSpot);
-    if ( iv->normalizedChi2()<chi2Cut_ &&
-	 fabs(displacement.z())<dzCut_ && displacement.perp2()<dr2Cut_ ) {
-      getVertexVariables(*iv,multiplicity,ptSum);
-      if ( multiplicity>=multiplicityCut_ && ptSum>ptSumCut_ ) selected_.push_back(&*iv);
-    }
-  }
-  sort(selected_.begin(),selected_.end(),*this);
-}
-
-bool
-PATPrimaryVertexSelector::operator() (const reco::Vertex* v1, const reco::Vertex* v2) const {
-  unsigned int mult1;
-  double ptSum1;
-  getVertexVariables(*v1,mult1,ptSum1);
-  unsigned int mult2;
-  double ptSum2;
-  getVertexVariables(*v2,mult2,ptSum2);
-  return ptSum1>ptSum2;
-}
-
-void
-PATPrimaryVertexSelector::getVertexVariables (const reco::Vertex& vertex,
-					      unsigned int& multiplicity, double& ptSum) const {
-  multiplicity = 0;
-  ptSum = 0.;
-  for(reco::Vertex::trackRef_iterator it=vertex.tracks_begin();
-      it!=vertex.tracks_end(); ++it) {
-    if(fabs((**it).eta())<trackEtaCut_) {
-      ++multiplicity;
-      ptSum += (**it).pt();
-    }
-  }
-}
diff --git a/PhysicsTools/PatAlgos/src/PATUserDataMerger.cc b/PhysicsTools/PatAlgos/src/PATUserDataMerger.cc
deleted file mode 100644
index ee97e09..0000000
--- a/PhysicsTools/PatAlgos/src/PATUserDataMerger.cc
+++ /dev/null
@@ -1,2 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/PATUserDataMerger.h"
-
diff --git a/PhysicsTools/PatAlgos/src/SimpleIsolator.cc b/PhysicsTools/PatAlgos/src/SimpleIsolator.cc
deleted file mode 100644
index a4b4615..0000000
--- a/PhysicsTools/PatAlgos/src/SimpleIsolator.cc
+++ /dev/null
@@ -1,22 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/SimpleIsolator.h"
-#include <sstream>
-
-using pat::helper::SimpleIsolator;
-using pat::helper::BaseIsolator;
-
-
-SimpleIsolator::SimpleIsolator(const edm::ParameterSet &conf, bool withCut) :
-    BaseIsolator(conf, withCut)
-{
-}
-
-void
-SimpleIsolator::beginEvent(const edm::Event &event, const edm::EventSetup &eventSetup) {
-    event.getByLabel(input_, handle_);
-}
-
-void
-SimpleIsolator::endEvent() {
-    handle_.clear();
-}
-
diff --git a/PhysicsTools/PatAlgos/src/StringResolutionProvider.cc b/PhysicsTools/PatAlgos/src/StringResolutionProvider.cc
deleted file mode 100644
index f8f89c3..0000000
--- a/PhysicsTools/PatAlgos/src/StringResolutionProvider.cc
+++ /dev/null
@@ -1,56 +0,0 @@
-#include <map>
-#include <Math/Functions.h>
-
-#include "CommonTools/Utils/interface/StringCutObjectSelector.h"
-#include "PhysicsTools/PatAlgos/interface/StringResolutionProvider.h"
-#include "DataFormats/PatCandidates/interface/ParametrizationHelper.h"
-
-StringResolutionProvider::StringResolutionProvider(const edm::ParameterSet& cfg): constraints_() 
-{ 
-  typedef pat::CandKinResolution::Parametrization Parametrization;
-  
-  // 
-  std::vector<double> constr = cfg.getParameter<std::vector<double> > ("constraints");
-  constraints_.insert(constraints_.end(), constr.begin(), constr.end());
-  
-  std::string parametrization(cfg.getParameter<std::string> ("parametrization") );
-  parametrization_ = pat::helper::ParametrizationHelper::fromString(parametrization);
-  
-  std::vector<edm::ParameterSet> functionSets_ = cfg.getParameter <std::vector<edm::ParameterSet> >("functions");
-  for(std::vector<edm::ParameterSet>::const_iterator iSet = functionSets_.begin(); iSet != functionSets_.end(); ++iSet){
-    if(iSet->exists("bin"))bins_.push_back(iSet->getParameter<std::string>("bin"));
-    else if(functionSets_.size()==1)bins_.push_back("");
-    else throw cms::Exception("WrongConfig") << "Parameter 'bin' is needed if more than one PSet is specified\n";
-
-    funcEt_.push_back(iSet->getParameter<std::string>("et"));
-    funcEta_.push_back(iSet->getParameter<std::string>("eta"));
-    funcPhi_.push_back(iSet->getParameter<std::string>("phi"));
-  }
-}
-
-StringResolutionProvider::~StringResolutionProvider()
-{
-}
- 
-pat::CandKinResolution
-StringResolutionProvider::getResolution(const reco::Candidate& cand) const 
-{ 
-  int selectedBin=-1;
-  for(unsigned int i=0; i<bins_.size(); ++i){
-    StringCutObjectSelector<reco::Candidate> select_(bins_[i]);
-    if(select_(cand)){
-      selectedBin = i;
-      break;
-    }
-  }
-  std::vector<pat::CandKinResolution::Scalar> covariances(3);
-  if(selectedBin>=0){
-    covariances[0] = ROOT::Math::Square(Function(funcEt_ [selectedBin]).operator()(cand));
-    covariances[1] = ROOT::Math::Square(Function(funcEta_[selectedBin]).operator()(cand));
-    covariances[2] = ROOT::Math::Square(Function(funcPhi_[selectedBin]).operator()(cand));
-  }
-  // fill 0. for not selected candidates
-  else for(int i=0; i<3; ++i){covariances[i] = 0.;}
-  
-  return pat::CandKinResolution(parametrization_, covariances, constraints_);
-}
diff --git a/PhysicsTools/PatAlgos/src/VertexingHelper.cc b/PhysicsTools/PatAlgos/src/VertexingHelper.cc
deleted file mode 100644
index 74eb102..0000000
--- a/PhysicsTools/PatAlgos/src/VertexingHelper.cc
+++ /dev/null
@@ -1,92 +0,0 @@
-#include "PhysicsTools/PatAlgos/interface/VertexingHelper.h"
-#include <algorithm>
-
-#include <iostream> 
-
-#include "TrackingTools/Records/interface/TransientTrackRecord.h"
-#include "TrackingTools/TransientTrack/interface/TransientTrack.h"
-#include "DataFormats/ParticleFlowCandidate/interface/PFCandidate.h"
-#include "DataFormats/RecoCandidate/interface/RecoCandidate.h"
-
-pat::helper::VertexingHelper::VertexingHelper(const edm::ParameterSet &iConfig) 
-{
-    if (!iConfig.empty()) { 
-        enabled_ = true;
-        if ( iConfig.existsAs<edm::InputTag>("vertexAssociations") == iConfig.existsAs<edm::InputTag>("vertices")) {
-            throw cms::Exception("Configuration") <<
-                "VertexingHelper: you must configure either 'vertices' (to produce associations) or 'vertexAssociations' (to read them from disk), " <<
-                "you can't specify both, nor you can specify none!\n";
-        }
-            
-        if (iConfig.existsAs<edm::InputTag>("vertexAssociations")) {
-            playback_ = true;
-            vertexAssociations_ = iConfig.getParameter<edm::InputTag>("vertexAssociations");
-        }
-        if (iConfig.existsAs<edm::InputTag>("vertices")) { // vertex have been specified, so run on the fly
-            playback_ = false;
-            vertices_ = iConfig.getParameter<edm::InputTag>("vertices");
-            // ------ MODE ------------------
-            useTracks_ = iConfig.getParameter<bool>("useTracks");
-            // ------ CUTS (fully optional) ------------------
-        }
-        assoSelector_ = reco::modules::make<pat::VertexAssociationSelector>(iConfig);
-    } else {
-        enabled_ = false;
-    }
-}
-
-void
-pat::helper::VertexingHelper::newEvent(const edm::Event &iEvent) {
-    if (playback_) {
-        iEvent.getByLabel(vertexAssociations_, vertexAssoMap_);
-    } else {
-        iEvent.getByLabel(vertices_, vertexHandle_);
-    }
-}
-
-void
-pat::helper::VertexingHelper::newEvent(const edm::Event &iEvent, const edm::EventSetup & iSetup) {
-    newEvent(iEvent);
-    if (!playback_) iSetup.get<TransientTrackRecord>().get("TransientTrackBuilder", ttBuilder_);
-}
-
-
-pat::VertexAssociation
-pat::helper::VertexingHelper::associate(const reco::Candidate &c) const {
-    if (playback_) throw cms::Exception("Configuration") << "VertexingHelper: if this module was configured to read associations from the event," << 
-                                                            " you must use 'operator()' passing a candidate ref, and not 'associate()' directly!\n";
-
-    reco::VertexCollection::const_iterator vtx, end;
-    size_t ivtx;
-    reco::TrackBaseRef tk; 
-    reco::TransientTrack tt;
-    if (useTracks_) { 
-        if (!ttBuilder_.isValid()) throw cms::Exception("Configuration") << "VertexingHelper: If you use 'useTracks', you must call newEvent(iEvent,iSetup)!\n";
-        tk = getTrack_(c); 
-        if (tk.isNull()) return pat::VertexAssociation(); 
-        tt = ttBuilder_->build(*tk);
-    }
-    for (vtx = vertexHandle_->begin(), end = vertexHandle_->end(), ivtx = 0; vtx != end; ++vtx, ++ivtx) {
-        pat::VertexAssociation association(reco::VertexRef(vertexHandle_, ivtx), tk);
-        if (useTracks_ == false) {
-            association.setDistances(c.vertex(), vtx->position(), vtx->error());
-        } else {
-            GlobalPoint vtxGP(vtx->x(), vtx->y(), vtx->z()); // need to convert XYZPoint to GlobalPoint
-            TrajectoryStateClosestToPoint tscp = tt.trajectoryStateClosestToPoint(vtxGP); 
-            GlobalPoint          trackPos = tscp.theState().position();
-            AlgebraicSymMatrix33 trackErr = tscp.theState().cartesianError().matrix().Sub<AlgebraicSymMatrix33>(0,0);
-            association.setDistances(trackPos, vtx->position(), trackErr + vtx->error());
-        }
-        if (assoSelector_(association)) return association;
-    }
-    return pat::VertexAssociation();
-}
-
-reco::TrackBaseRef pat::helper::VertexingHelper::getTrack_(const reco::Candidate &c) const  {
-    const reco::RecoCandidate   *rc  = dynamic_cast<const reco::RecoCandidate *>(&c);
-    if (rc  != 0)  { return rc->bestTrackRef(); }
-    const reco::PFCandidate *pfc = dynamic_cast<const reco::PFCandidate *>(&c);
-    if (pfc != 0) { return reco::TrackBaseRef(pfc->trackRef()); }
-
-    return reco::TrackBaseRef();
-}
diff --git a/PhysicsTools/PatAlgos/test/BuildFile.xml b/PhysicsTools/PatAlgos/test/BuildFile.xml
deleted file mode 100644
index 6b34511..0000000
--- a/PhysicsTools/PatAlgos/test/BuildFile.xml
+++ /dev/null
@@ -1,18 +0,0 @@
-<export>
-</export>
-<library   name="PhysicsToolsPatAlgos_testAnalyzers" file="private/*.cc">
-  <use   name="FWCore/Framework"/>
-  <use   name="FWCore/ParameterSet"/>
-  <use   name="DataFormats/BTauReco"/>
-  <use   name="PhysicsTools/PatUtils"/>
-  <use   name="DataFormats/PatCandidates"/>
-  <use   name="PhysicsTools/UtilAlgos"/>
-  <use   name="root"/>
-  <flags   EDM_PLUGIN="1"/>
-</library>
-<environment>
-  <bin   file="runtestPhysicsToolsPatAlgos.cpp">
-    <flags   TEST_RUNNER_ARGS=" /bin/bash PhysicsTools/PatAlgos/test runtests.sh"/>
-    <use   name="FWCore/Utilities"/>
-  </bin>
-</environment>
diff --git a/PhysicsTools/PatAlgos/test/IntegrationTest_cfg.py b/PhysicsTools/PatAlgos/test/IntegrationTest_cfg.py
deleted file mode 100644
index fdaf047..0000000
--- a/PhysicsTools/PatAlgos/test/IntegrationTest_cfg.py
+++ /dev/null
@@ -1,84 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-
-
-## ------------------------------------------------------
-#  NOTE: you can use a bunch of core tools of PAT to
-#  taylor your PAT configuration; for a few examples
-#  uncomment the lines below
-## ------------------------------------------------------
-from PhysicsTools.PatAlgos.tools.coreTools import *
-
-## remove MC matching from the default sequence
-# removeMCMatching(process, ['Muons'])
-
-## remove certain objects from the default sequence
-# removeAllPATObjectsBut(process, ['Muons'])
-removeSpecificPATObjects(process, ['Taus'])
-
-
-
-## ------------------------------------------------------
-#  NOTE: you can still run PAT in the 36X version on
-#  input files produced within the 35X series. This
-#  implies some reconfigurations, example are given
-#  below.
-## ------------------------------------------------------
-#from PhysicsTools.PatAlgos.tools.cmsswVersionTools import *
-
-## uncomment this line to run on an 35X input sample
-#run36xOn35xInput(process)
-
-## uncomment the following lines to add jets from a
-## 35X input sample
-#addJetCollection35X(process,cms.InputTag('ak7CaloJets'),
-#                 'AK7', 'Calo',
-#                 doJTA        = True,
-#                 doBTagging   = False,
-#                 jetCorrLabel = ('AK7', 'Calo'),
-#                 doType1MET   = True,
-#                 doL1Cleaning = True,
-#                 doL1Counters = False,
-#                 genJetCollection=cms.InputTag("ak7GenJets"),
-#                 doJetID      = True,
-#                 jetIdLabel   = "ak7"
-#                 )
-
-## uncomment the following lines to switch the jet
-## collection from a 35X input sample
-#switchJetCollection35X(process,cms.InputTag('ak5PFJets'),
-#                 doJTA        = True,
-#                 doBTagging   = True,
-#                 jetCorrLabel = None,
-#                 doType1MET   = True,
-#                 genJetCollection=cms.InputTag("ak5GenJets"),
-#                 doJetID      = True
-#                 )
-
-
-
-## let it run
-process.p = cms.Path(
-    process.patDefaultSequence
-    )
-
-
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-#   process.maxEvents.input = ...         ##  (e.g. -1 to run on all events)
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'IntegrationTest.root'
-#                                         ##
-#   process.options.wantSummary = True    ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/checkPySintax b/PhysicsTools/PatAlgos/test/checkPySintax
deleted file mode 100755
index c1465e1..0000000
--- a/PhysicsTools/PatAlgos/test/checkPySintax
+++ /dev/null
@@ -1,9 +0,0 @@
-#!/bin/bash
-
-## Quickly check if all python files in PhysicsTools/PatAlgos are well formed
-
-for py in $(find $CMSSW_BASE/src/PhysicsTools/PatAlgos -name '*.py' -type f); do
-    pyn=$(echo $py | sed "s#$CMSSW_BASE/src/PhysicsTools/PatAlgos/##g")
-    echo "Checking $pyn..."
-    python $py && echo -ne "\e[F\e[M";
-    done
diff --git a/PhysicsTools/PatAlgos/test/diskSize.pl b/PhysicsTools/PatAlgos/test/diskSize.pl
deleted file mode 100755
index f52d460..0000000
--- a/PhysicsTools/PatAlgos/test/diskSize.pl
+++ /dev/null
@@ -1,171 +0,0 @@
-#!/usr/bin/env perl
-
-## Tool to dig out information about the event size in PAT
-## 
-## Please run this giving as argument the root file, and redirecting the output on an HTML file
-## Notes:
-##    - you must have a correctly initialized environment, and FWLite auto-loading with ROOT
-##    - you must put in the same folder of the html also these three files:
-##            http://cern.ch/gpetrucc/patsize.css
-##            http://cern.ch/gpetrucc/blue-dot.gif
-##            http://cern.ch/gpetrucc/red-dot.gif
-##      otherwise you will get an unreadable output file
-##    - for small files, compression does not work (as you will read from the output html)
-##    - per-event provenance is just the GetZipBytes of EventMetaData, EventHistory.
-##    -  
-
-use strict; 
-use warnings;
-use Data::Dumper;
-use File::Temp qw/tempfile/;
-
-my $filename = shift(@ARGV);
-
-if ((!$filename) || ($filename eq "-h")) {
-    print STDERR "Usage: diskSize.pl filename.root > filename.html\n";
-    exit(1);
-}
-
-my ($MACRO, $macrofile) = tempfile( "macroXXXXX", SUFFIX=>'.c' , UNLINK => 1 );
-my ($macroname) = ($macrofile =~ m/(macro.....)\.c/);
-
-print STDERR "Getting list of branches ...\n";
-
-print $MACRO "void $macroname(){\nEvents->Print();\n}\n";
-close $MACRO;
-my $IN = qx(root.exe -b -l $filename $macrofile -q 2> /dev/null);
-
-my %survey = ();
-my $obj = undef; my $item = undef;
-my $events = 0;
-my %arrays = ();
-
-foreach (split(/\n/, $IN)) {
-  chomp; #print STDERR "    [$_]\n";
-  if (m/\*Branch\s+:((\w+)_(\w+)_(\w*)_(\w+))\./) {
-        $item = undef;
-  }
-  if (m/\*Br\s+\d+\s+:((\w+)_(\w+)_(\w*)_(\w+))\.obj\s/) {
-        $survey{$1} = { 'type'=>$2, 'label'=>$3, 'instance'=>$4, 'process'=>$5, 'tot'=>0, 'num'=> 0, 'items'=>{},  };
-        $obj = undef; $item = $1;
-        #print STDERR "Got item $item\n";
-  }
-  next unless defined $item;
- #if (m/\*Br\s+\d+\s+:((\w+)_(\w+)_(\w*)_(\w+))\.obj\.(\S+) :/) {
-  if (m/\*Br\s+\d+\s+:((\w+)_(\w+)_(\w*)_(\w+))\.(\S+) :/) {
-        $obj = $6; $item = $1;
-        #print STDERR "Got item $item, obj $obj\n";
-        die "Product $1 not found" unless defined($survey{$1});
-  }
-  if ((m/\|\s+\w+\[\S+/) && ($survey{$item}->{'type'} ne 'edmTriggerResults')) { $arrays{$item} = 1;  }
-  next unless defined $obj;
-  if (m/Entries\s+:\s*(\d+)\s+:\s+Total\s+Size=\s+(\d+)\s+bytes\s+File\s+Size\s+=\s+(\d+)/) {
-        die "Mismatching number of events ($events, $1) " unless (($events == 0) || ($events == $1));
-        $events = $1;
-        $survey{$item}->{'items'}->{$obj} = { 'siz'=>$3/1024.0, 'ok'=>1 };
-        $survey{$item}->{'tot'} += $survey{$item}->{'items'}->{$obj}->{'siz'};
-  } elsif (m/Entries\s+:\s*(\d+)\s+:\s+Total\s+Size=\s+(\d+)\s+bytes\s+One basket in memory/) {
-        die "Mismatching number of events ($events, $1) " unless (($events == 0) || ($events == $1));
-        $events = $1;
-        $survey{$item}->{'items'}->{$obj} = { 'siz'=>$2/1024.0, 'ok'=>0 };
-        $survey{$item}->{'tot'} += $survey{$item}->{'items'}->{$obj}->{'siz'};
-  }
-}
-
-my ($grandtotal,$provenance) = (0,0);
-foreach (keys(%survey)) { $grandtotal += $survey{$_}->{'tot'}; }
-
-print STDERR "Events: $events\n";
-open $MACRO, "> $macrofile";
-print $MACRO "void $macroname() {\n";
-foreach my $coll (sort(keys(%arrays))) {
-    print $MACRO "   Events->Draw(\"$coll.\@obj.size()>>htmp\");\n";
-    print $MACRO "   if ( Events->GetSelectedRows()>0) {\n";
-    print $MACRO "      std::cout << \"SIZE\t$coll\\t\" << (htmp->GetMean()*htmp->GetEntries()) << std::endl;\n";
-    print $MACRO "      htmp->Delete();\n";
-    print $MACRO "   } else {\n";
-    print $MACRO "     Events->Draw(\"$coll.obj.\@obj.size()>>htmp\");\n";
-    print $MACRO "     if ( Events->GetSelectedRows()>0) std::cout << \"SIZE\t$coll\\t\" << (htmp->GetMean()*htmp->GetEntries()) << std::endl;\n";
-    print $MACRO "     else std::cout << \"SIZE\t$coll\\t\" << 0 << std::endl;\n";
-    print $MACRO "   }\n";
-}
-print $MACRO "   std::cout << \"PROVENANCE\t\" << (EventMetaData->GetZipBytes()+EventHistory->GetZipBytes()) << std::endl;\n";
-print $MACRO "}\n";
-close $MACRO;
-
-print STDERR "Getting items in the collections (it can take a while) ...\n";
-
-my $root = qx(root.exe -b -l "$filename" -q $macrofile  2> /dev/null);
-my @lines = split('\n', $root);
-foreach (grep( /^SIZE\s+\S+\s+\S+/, @lines)) {
-    my ($item, $total) = (m/SIZE\s+(\w+)\s+(\S+)/);
-    $survey{$item}->{'num'} = $total;
-}
-foreach my $item (keys(%survey)) { $survey{$item}->{'num'} = $events if $survey{$item}->{'num'} == 0; }
-
-foreach (grep( /^PROVENANCE\s+(\S+)/, @lines)) { /^PROVENANCE\s+(\S+)/ and $provenance = $1/1024.0; }
-
-my $totalavg = sprintf("%.1f",$grandtotal/$events);
-print <<_END_;
-<html>
-<head>
-    <title>$filename : PAT Size</title>
-    <link rel="stylesheet" type="text/css" href="patsize.css" />
-</head>
-<h1>Summary ($totalavg kb/event)</h1>
-<table>
-_END_
-print "<tr class='header'><th>".join("</th><th>", "Collection", "items/event", "kb/event", "kb/item", "plot", "%") . "</th></tr>\n";
-foreach (sort({$survey{$b}->{'tot'} <=> $survey{$a}->{'tot'} }
-              keys(%survey))) {
-    print "<th><a href='#$_'>$_</a></th>";
-    foreach my $val ($survey{$_}->{'num'}/$events, $survey{$_}->{'tot'}/$events, $survey{$_}->{'tot'}/$survey{$_}->{'num'}) {
-        print sprintf("<td>%.2f</td>", $val);
-    }
-    print sprintf("<td class=\"img\"><img src='blue-dot.gif' width='\%d' height='\%d' /></td>",
-                            $survey{$_}->{'tot'}/$grandtotal * 200, 10 );
-    print sprintf("<td>%.1f%%</td>", $survey{$_}->{'tot'}/$grandtotal * 100.0);
-    print "</tr>\n";
-}
-# provenance
-print "<th>EventMetaData + EventHistory</th>";
-foreach my $val (1, $provenance/$events, $provenance/$events) {
-    print sprintf("<td>%.2f</td>", $val);
-}
-print sprintf("<td class=\"img\"><img src='red-dot.gif' width='\%d' height='\%d' /></td>",$provenance/$grandtotal * 200, 10 );
-print sprintf("<td>%.1f%%</td>", $provenance/$grandtotal * 100.0);
-print "</tr>\n";
-
-print <<_END_;
-</table>
-Note: size percentages are relative to the total size of data only, without the per-event provenance (EventMetaData + EventHistory).
-<h1>Detail</h1>
-_END_
-foreach (sort(keys(%survey))) {
-    my $avg = sprintf("%.1f",$survey{$_}->{'num'}/$events);
-    print <<_END_;
-<h2><a name="$_" id="$_">$_</a> ($avg items/event)</h2>
-<table>
-_END_
-    print "<tr class='header'><th>".join("</th><th>", "Datamember", "kb/event", "kb/item", "plot", "%", "compressed") . "</th></tr>\n";
-    foreach my $it (sort({$survey{$_}->{'items'}->{$b}->{'siz'} <=> $survey{$_}->{'items'}->{$a}->{'siz'}} 
-                         keys(%{$survey{$_}->{'items'}}))) {
-        print "<th>$it</th>";
-        my $IT = $survey{$_}->{'items'}->{$it};
-        foreach my $val ($IT->{'siz'}/$events, $IT->{'siz'}/$survey{$_}->{'num'}) {
-            print sprintf("<td>%.3f</td>", $val);
-        }
-        print sprintf("<td class=\"img\"><img src='\%s-dot.gif' width='\%d' height='\%d' /></td>",
-                                ($IT->{'ok'} ? 'blue' : 'red'), $IT->{'siz'}/$survey{$_}->{'tot'} * 200, 10 );
-        print sprintf("<td>%.1f%%</td>", $IT->{'siz'}/$survey{$_}->{'tot'} * 100.0);
-        print "<td>". ($IT->{'ok'} ? 'ok' : 'no') . "</td>";
-        print "</tr>\n";
-    }
-    print <<_END_;
-</table>
-_END_
-}
-print <<_END_;
-</body></html>
-_END_
-close;
diff --git a/PhysicsTools/PatAlgos/test/fwlite/rootlogon.C b/PhysicsTools/PatAlgos/test/fwlite/rootlogon.C
deleted file mode 100644
index 6b64647..0000000
--- a/PhysicsTools/PatAlgos/test/fwlite/rootlogon.C
+++ /dev/null
@@ -1,151 +0,0 @@
-{
-  gSystem->Load("libFWCoreFWLite.so"); 
-  AutoLibraryLoader::enable();
-  gSystem->Load("libDataFormatsFWLite.so");
-  gROOT->ProcessLine("namespace edm {typedef edm::Wrapper<vector<float> > Wrapper<vector<float,allocator<float> > >; }");
-  gROOT->ProcessLine("namespace edm {typedef edm::Wrapper<vector<double> > Wrapper<vector<double,allocator<double> > >; }");
-
-  TStyle *tdrStyle = new TStyle("tdrStyle","Style for P-TDR");
-
-  cout << "TDR Style initialized" << endl;
-
-// For the canvas:
-  tdrStyle->SetCanvasBorderMode(0);
-  tdrStyle->SetCanvasColor(kWhite);
-  tdrStyle->SetCanvasDefH(600); //Height of canvas
-  tdrStyle->SetCanvasDefW(600); //Width of canvas
-  tdrStyle->SetCanvasDefX(0);   //POsition on screen
-  tdrStyle->SetCanvasDefY(0);
-
-// For the Pad:
-  tdrStyle->SetPadBorderMode(0);
-  // tdrStyle->SetPadBorderSize(Width_t size = 1);
-  tdrStyle->SetPadColor(kWhite);
-  tdrStyle->SetPadGridX(false);
-  tdrStyle->SetPadGridY(false);
-  tdrStyle->SetGridColor(0);
-  tdrStyle->SetGridStyle(3);
-  tdrStyle->SetGridWidth(1);
-
-// For the frame:
-  tdrStyle->SetFrameBorderMode(0);
-  tdrStyle->SetFrameBorderSize(1);
-  tdrStyle->SetFrameFillColor(0);
-  tdrStyle->SetFrameFillStyle(0);
-  tdrStyle->SetFrameLineColor(1);
-  tdrStyle->SetFrameLineStyle(1);
-  tdrStyle->SetFrameLineWidth(1);
-
-// For the histo:
-  // tdrStyle->SetHistFillColor(1);
-  // tdrStyle->SetHistFillStyle(0);
-  tdrStyle->SetHistLineColor(1);
-  tdrStyle->SetHistLineStyle(0);
-  tdrStyle->SetHistLineWidth(1);
-  // tdrStyle->SetLegoInnerR(Float_t rad = 0.5);
-  // tdrStyle->SetNumberContours(Int_t number = 20);
-
-  tdrStyle->SetEndErrorSize(2);
-  //tdrStyle->SetErrorMarker(20);
-  tdrStyle->SetErrorX(0.);
-  
-  tdrStyle->SetMarkerStyle(20);
-
-//For the fit/function:
-  tdrStyle->SetOptFit(1);
-  tdrStyle->SetFitFormat("5.4g");
-  tdrStyle->SetFuncColor(2);
-  tdrStyle->SetFuncStyle(1);
-  tdrStyle->SetFuncWidth(1);
-
-//For the date:
-  tdrStyle->SetOptDate(0);
-  // tdrStyle->SetDateX(Float_t x = 0.01);
-  // tdrStyle->SetDateY(Float_t y = 0.01);
-
-// For the statistics box:
-  tdrStyle->SetOptFile(0);
-  tdrStyle->SetOptStat(0); // To display the mean and RMS:   SetOptStat("mr");
-  tdrStyle->SetStatColor(kWhite);
-  tdrStyle->SetStatFont(42);
-  tdrStyle->SetStatFontSize(0.025);
-  tdrStyle->SetStatTextColor(1);
-  tdrStyle->SetStatFormat("6.4g");
-  tdrStyle->SetStatBorderSize(1);
-  tdrStyle->SetStatH(0.1);
-  tdrStyle->SetStatW(0.15);
-  // tdrStyle->SetStatStyle(Style_t style = 1001);
-  // tdrStyle->SetStatX(Float_t x = 0);
-  // tdrStyle->SetStatY(Float_t y = 0);
-
-// Margins:
-  tdrStyle->SetPadTopMargin(0.15);
-  tdrStyle->SetPadBottomMargin(0.13);
-  tdrStyle->SetPadLeftMargin(0.13);
-  tdrStyle->SetPadRightMargin(0.15);
-
-// For the Global title:
-
-//  tdrStyle->SetOptTitle(0);
-  tdrStyle->SetTitleFont(42);
-  tdrStyle->SetTitleColor(1);
-  tdrStyle->SetTitleTextColor(1);
-  tdrStyle->SetTitleFillColor(10);
-  tdrStyle->SetTitleFontSize(0.05);
-  // tdrStyle->SetTitleH(0); // Set the height of the title box
-  // tdrStyle->SetTitleW(0); // Set the width of the title box
-  // tdrStyle->SetTitleX(0); // Set the position of the title box
-  // tdrStyle->SetTitleY(0.985); // Set the position of the title box
-  // tdrStyle->SetTitleStyle(Style_t style = 1001);
-  // tdrStyle->SetTitleBorderSize(2);
-
-// For the axis titles:
-
-  tdrStyle->SetTitleColor(1, "XYZ");
-  tdrStyle->SetTitleFont(42, "XYZ");
-  tdrStyle->SetTitleSize(0.06, "XYZ");
-  // tdrStyle->SetTitleXSize(Float_t size = 0.02); // Another way to set the size?
-  // tdrStyle->SetTitleYSize(Float_t size = 0.02);
-  tdrStyle->SetTitleXOffset(1.0);
-//   tdrStyle->SetTitleYOffset(1.5);
-  tdrStyle->SetTitleOffset(1.5, "Y"); // Another way to set the Offset
-
-// For the axis labels:
-
-  tdrStyle->SetLabelColor(1, "XYZ");
-  tdrStyle->SetLabelFont(42, "XYZ");
-  tdrStyle->SetLabelOffset(0.007, "XYZ");
-  tdrStyle->SetLabelSize(0.05, "XYZ");
-
-// For the axis:
-
-  tdrStyle->SetAxisColor(1, "XYZ");
-  tdrStyle->SetStripDecimals(kTRUE);
-  tdrStyle->SetTickLength(0.03, "XYZ");
-  tdrStyle->SetNdivisions(510, "XYZ");
-  tdrStyle->SetPadTickX(1);  // To get tick marks on the opposite side of the frame
-  tdrStyle->SetPadTickY(1);
-
-// Change for log plots:
-  tdrStyle->SetOptLogx(0);
-  tdrStyle->SetOptLogy(0);
-  tdrStyle->SetOptLogz(0);
-
-  tdrStyle->SetPalette(1,0);
-
-// Postscript options:
-  // tdrStyle->SetPaperSize(15.,15.);
-  // tdrStyle->SetLineScalePS(Float_t scale = 3);
-  // tdrStyle->SetLineStyleString(Int_t i, const char* text);
-  // tdrStyle->SetHeaderPS(const char* header);
-  // tdrStyle->SetTitlePS(const char* pstitle);
-
-  // tdrStyle->SetBarOffset(Float_t baroff = 0.5);
-  // tdrStyle->SetBarWidth(Float_t barwidth = 0.5);
-  // tdrStyle->SetPaintTextFormat(const char* format = "g");
-  // tdrStyle->SetPalette(Int_t ncolors = 0, Int_t* colors = 0);
-  // tdrStyle->SetTimeOffset(Double_t toffset);
-  // tdrStyle->SetHistMinimumZero(kTRUE);
-
-  tdrStyle->cd();
-}
diff --git a/PhysicsTools/PatAlgos/test/fwlite/testSelection_electron.C b/PhysicsTools/PatAlgos/test/fwlite/testSelection_electron.C
deleted file mode 100644
index 92098ba..0000000
--- a/PhysicsTools/PatAlgos/test/fwlite/testSelection_electron.C
+++ /dev/null
@@ -1,59 +0,0 @@
-/*   A macro for making a histogram of Electron Pt with cuts
-This is a basic way to cut out electrons of a certain Pt and Eta using an if statement
-This example creates a histogram of Electron Pt, using Electrons with Pt above 30 and ETA above -2.1 and below 2.1
-*/
-
-#include "DataFormats/FWLite/interface/Handle.h"
-#include "DataFormats/FWLite/interface/Event.h"
-#include "TFile.h"
-#include "TH1.h"
-#include "TCanvas.h"
-#include "TLegend.h"
-
-
-#if !defined(__CINT__) && !defined(__MAKECINT__)
-#include "DataFormats/PatCandidates/interface/Electron.h"
-#include "PhysicsTools/PatUtils/interface/ElectronVPlusJetsIDSelectionFunctor.h"
-#endif
-
-#include <iostream>
-#include <cmath>      //necessary for absolute function fabs()
-
-using namespace std;
-
-void sk_fwlitecuts()
-{
-  ElectronVPlusJetsIDSelectionFunctor muId( ElectronVPlusJetsIDSelectionFunctor::SUMMER08 );
-
-
-  TFile  * file = new TFile("PATLayer1_Output.fromAOD_full.root");
-  TH1D * hist_ePt = new TH1D("hist_ePt", "Electron p_{T}", 20, 0, 100 );
-  fwlite::Event ev(file);
-
-  //loop through each event
-  for( ev.toBegin();
-         ! ev.atEnd();
-         ++ev) {
-    fwlite::Handle<std::vector<pat::Electron> > h_mu;
-    h_mu.getByLabel(ev,"cleanLayer1Electrons");
-    if (!h_mu.isValid() ) continue;
-    vector<pat::Electron> const & electrons = *h_mu;
-
-   //loop through each Electron
-   vector<pat::Electron>::const_iterator iter;
-   for ( iter = electrons.begin(); iter != electrons.end() ; ++iter) {
-   
-     if ( (iter->pt() > 30 ) && ( fabs(iter->eta() ) < 2.1)  ) {
-       cout << "Passed kin" << endl;
-       if ( muId( *iter ) ) {
-	 cout << "Passed ID" << endl;
-	 hist_ePt->Fill( iter->pt() );
-       }
-     }
-       
-
-   }   //end Electron loop   
-   }   //end event loop
-
-   hist_ePt->Draw();   
-}
diff --git a/PhysicsTools/PatAlgos/test/fwlite/testSelection_jet.C b/PhysicsTools/PatAlgos/test/fwlite/testSelection_jet.C
deleted file mode 100644
index 11a0681..0000000
--- a/PhysicsTools/PatAlgos/test/fwlite/testSelection_jet.C
+++ /dev/null
@@ -1,59 +0,0 @@
-/*   A macro for making a histogram of Jet Pt with cuts
-This is a basic way to cut out jets of a certain Pt and Eta using an if statement
-This example creates a histogram of Jet Pt, using Jets with Pt above 30 and ETA above -2.1 and below 2.1
-*/
-
-#include "DataFormats/FWLite/interface/Handle.h"
-#include "DataFormats/FWLite/interface/Event.h"
-#include "TFile.h"
-#include "TH1.h"
-#include "TCanvas.h"
-#include "TLegend.h"
-
-
-#if !defined(__CINT__) && !defined(__MAKECINT__)
-#include "DataFormats/PatCandidates/interface/Jet.h"
-#include "PhysicsTools/PatUtils/interface/JetIDSelectionFunctor.h"
-#endif
-
-#include <iostream>
-#include <cmath>      //necessary for absolute function fabs()
-
-using namespace std;
-
-void sk_fwlitecuts()
-{
-  JetIDSelectionFunctor jetId( JetIDSelectionFunctor::CRAFT08, JetIDSelectionFunctor::TIGHT );
-
-
-  TFile  * file = new TFile("PATLayer1_Output.fromAOD_full.root");
-  TH1D * hist_jetPt = new TH1D("hist_jetPt", "Jet p_{T}", 20, 0, 100 );
-  fwlite::Event ev(file);
-
-  //loop through each event
-  for( ev.toBegin();
-         ! ev.atEnd();
-         ++ev) {
-    fwlite::Handle<std::vector<pat::Jet> > h_mu;
-    h_mu.getByLabel(ev,"cleanLayer1Jets");
-    if (!h_mu.isValid() ) continue;
-    vector<pat::Jet> const & jets = *h_mu;
-
-   //loop through each Jet
-   vector<pat::Jet>::const_iterator iter;
-   for ( iter = jets.begin(); iter != jets.end() ; ++iter) {
-   
-     if ( (iter->pt() > 30 ) && ( fabs(iter->eta() ) < 2.1)  ) {
-       cout << "Passed kin" << endl;
-       if ( jetId( *iter ) ) {
-	 cout << "Passed ID" << endl;
-	 hist_jetPt->Fill( iter->pt() );
-       }
-     }
-       
-
-   }   //end Jet loop   
-   }   //end event loop
-
-   hist_jetPt->Draw();   
-}
diff --git a/PhysicsTools/PatAlgos/test/fwlite/testSelection_muon.C b/PhysicsTools/PatAlgos/test/fwlite/testSelection_muon.C
deleted file mode 100644
index df21c82..0000000
--- a/PhysicsTools/PatAlgos/test/fwlite/testSelection_muon.C
+++ /dev/null
@@ -1,59 +0,0 @@
-/*   A macro for making a histogram of Muon Pt with cuts
-This is a basic way to cut out muons of a certain Pt and Eta using an if statement
-This example creates a histogram of Muon Pt, using Muons with Pt above 30 and ETA above -2.1 and below 2.1
-*/
-
-#include "DataFormats/FWLite/interface/Handle.h"
-#include "DataFormats/FWLite/interface/Event.h"
-#include "TFile.h"
-#include "TH1.h"
-#include "TCanvas.h"
-#include "TLegend.h"
-
-
-#if !defined(__CINT__) && !defined(__MAKECINT__)
-#include "DataFormats/PatCandidates/interface/Muon.h"
-#include "PhysicsTools/PatUtils/interface/MuonVPlusJetsIDSelectionFunctor.h"
-#endif
-
-#include <iostream>
-#include <cmath>      //necessary for absolute function fabs()
-
-using namespace std;
-
-void sk_fwlitecuts()
-{
-  MuonVPlusJetsIDSelectionFunctor muId( MuonVPlusJetsIDSelectionFunctor::SUMMER08 );
-
-
-  TFile  * file = new TFile("PATLayer1_Output.fromAOD_full.root");
-  TH1D * hist_muPt = new TH1D("hist_muPt", "Muon p_{T}", 20, 0, 100 );
-  fwlite::Event ev(file);
-
-  //loop through each event
-  for( ev.toBegin();
-         ! ev.atEnd();
-         ++ev) {
-    fwlite::Handle<std::vector<pat::Muon> > h_mu;
-    h_mu.getByLabel(ev,"cleanLayer1Muons");
-    if (!h_mu.isValid() ) continue;
-    vector<pat::Muon> const & muons = *h_mu;
-
-   //loop through each Muon
-   vector<pat::Muon>::const_iterator iter;
-   for ( iter = muons.begin(); iter != muons.end() ; ++iter) {
-   
-     if ( (iter->pt() > 30 ) && ( fabs(iter->eta() ) < 2.1)  ) {
-       cout << "Passed kin" << endl;
-       if ( muId( *iter ) ) {
-	 cout << "Passed ID" << endl;
-	 hist_muPt->Fill( iter->pt() );
-       }
-     }
-       
-
-   }   //end Muon loop   
-   }   //end event loop
-
-   hist_muPt->Draw();   
-}
diff --git a/PhysicsTools/PatAlgos/test/patTuple_PATandPF2PAT_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_PATandPF2PAT_cfg.py
deleted file mode 100644
index 32b1920..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_PATandPF2PAT_cfg.py
+++ /dev/null
@@ -1,95 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-runOnMC = True
-
-if runOnMC:
-    from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-    process.source.fileNames = filesRelValProdTTbarAODSIM
-else:
-    from PhysicsTools.PatAlgos.patInputFiles_cff import filesSingleMuRECO
-    process.source.fileNames = filesSingleMuRECO
-    process.GlobalTag.globaltag = cms.string( autoCond[ 'com10' ] )
-
-# load the PAT config
-process.load("PhysicsTools.PatAlgos.patSequences_cff")
-
-
-# Configure PAT to use PF2PAT instead of AOD sources
-# this function will modify the PAT sequences.
-from PhysicsTools.PatAlgos.tools.pfTools import *
-
-# An empty postfix means that only PF2PAT is run,
-# otherwise both standard PAT and PF2PAT are run. In the latter case PF2PAT
-# collections have standard names + postfix (e.g. patElectronPFlow)
-postfix = "PFlow"
-jetAlgo = "AK5"
-usePF2PAT(process,runPF2PAT=True, jetAlgo=jetAlgo, runOnMC=runOnMC, postfix=postfix)
-
-# to turn on type-1 MET corrections, use the following call
-#usePF2PAT(process,runPF2PAT=True, jetAlgo=jetAlgo, runOnMC=runOnMC, postfix=postfix, typeIMetCorrections=True)
-
-# to run second PF2PAT+PAT with different postfix uncomment the following lines
-# and add the corresponding sequence to path
-#postfix2 = "PFlow2"
-#jetAlgo2="AK7"
-#usePF2PAT(process,runPF2PAT=True, jetAlgo=jetAlgo2, runOnMC=True, postfix=postfix2)
-
-# to use tau-cleaned jet collection uncomment the following:
-#getattr(process,"pfNoTau"+postfix).enable = True
-
-# to switch default tau (HPS) to old default tau (shrinking cone) uncomment
-# the following:
-# note: in current default taus are not preselected i.e. you have to apply
-# selection yourself at analysis level!
-#adaptPFTaus(process,"shrinkingConePFTau",postfix=postfix)
-
-
-if not runOnMC:
-    # removing MC matching for standard PAT sequence
-    # for the PF2PAT+PAT sequence, it is done in the usePF2PAT function
-    removeMCMatchingPF2PAT( process, '' )
-
-# Let it run
-process.p = cms.Path(
-    getattr(process,"patPF2PATSequence"+postfix)
-#    second PF2PAT
-#    + getattr(process,"patPF2PATSequence"+postfix2)
-)
-if not postfix == "":
-    process.p += process.patDefaultSequence
-
-# Add PF2PAT output to the created file
-from PhysicsTools.PatAlgos.patEventContent_cff import patEventContentNoCleaning
-process.out.outputCommands = cms.untracked.vstring('drop *',
-                                                   'keep recoPFCandidates_particleFlow_*_*',
-                                                   *patEventContentNoCleaning )
-
-
-# top projections in PF2PAT:
-getattr(process,"pfNoPileUp"+postfix).enable = True
-getattr(process,"pfNoMuon"+postfix).enable = True
-getattr(process,"pfNoElectron"+postfix).enable = True
-getattr(process,"pfNoTau"+postfix).enable = False
-getattr(process,"pfNoJet"+postfix).enable = True
-
-# verbose flags for the PF2PAT modules
-getattr(process,"pfNoMuon"+postfix).verbose = False
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-#   process.source.fileNames =  ...       ##  (e.g. 'file:AOD.root')
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_PATandPF2PAT.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
-
diff --git a/PhysicsTools/PatAlgos/test/patTuple_PF2PATGsfElectrons_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_PF2PATGsfElectrons_cfg.py
deleted file mode 100644
index 5402e2e..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_PF2PATGsfElectrons_cfg.py
+++ /dev/null
@@ -1,50 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-# load the PAT config
-process.load("PhysicsTools.PatAlgos.patSequences_cff")
-
-# Configure PAT to use PF2PAT instead of AOD sources
-# this function will modify the PAT sequences.
-from PhysicsTools.PatAlgos.tools.pfTools import *
-
-postfix = "PFlow"
-jetAlgo="AK5"
-usePF2PAT(process,runPF2PAT=True, jetAlgo=jetAlgo, runOnMC=True, postfix=postfix)
-
-# to use GsfElectrons instead of PF electrons
-# this will destory the feature of top projection which solves the ambiguity between leptons and jets because
-# there will be overlap between non-PF electrons and jets even though top projection is ON!
-useGsfElectrons(process,postfix,"03") # to change isolation cone size to 0.3 as it is recommended by EGM POG, use "04" for cone size 0.4
-
-# Let it run
-process.p = cms.Path(
-#    process.patDefaultSequence  +
-    getattr(process,"patPF2PATSequence"+postfix)
-)
-
-# Add PF2PAT output to the created file
-from PhysicsTools.PatAlgos.patEventContent_cff import patEventContentNoCleaning
-#process.load("CommonTools.ParticleFlow.PF2PAT_EventContent_cff")
-#process.out.outputCommands =  cms.untracked.vstring('drop *')
-process.out.outputCommands = cms.untracked.vstring('drop *',
-                                                   'keep recoPFCandidates_particleFlow_*_*',
-                                                   *patEventContentNoCleaning )
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 100
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_PF2PATGsfElectrons.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_PF2PATTypeIMET_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_PF2PATTypeIMET_cfg.py
deleted file mode 100644
index 1793e9c..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_PF2PATTypeIMET_cfg.py
+++ /dev/null
@@ -1,97 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-# load the PAT config
-process.load("PhysicsTools.PatAlgos.patSequences_cff")
-
-
-# Configure PAT to use PF2PAT instead of AOD sources
-# this function will modify the PAT sequences.
-from PhysicsTools.PatAlgos.tools.pfTools import *
-
-postfix = "PFTypeI"
-jetAlgo="AK5"
-usePF2PAT(process,runPF2PAT=True, jetAlgo=jetAlgo, runOnMC=True, postfix=postfix, typeIMetCorrections=True)
-
-## There are 3 corrections one can apply to the MET object, type-0, type-1 and type-2
-## your final MET object can be type-1, type-0+1, type-1+2, or type-0+1+2
-## a combination of the following instructions will allow you to get the type of MET that you desire in your
-## analysis
-
-##to add type-0 corrections to your type-1 corrected MET uncomment the following:
-# getattr(process,'patType1CorrectedPFMet'+postfix).srcType1Corrections = cms.VInputTag(
-#     cms.InputTag("patPFJetMETtype1p2Corr"+postfix,"type1"),
-#     cms.InputTag("patPFMETtype0Corr"+postfix),
-#     )
-# getattr(process,'patType1p2CorrectedPFMet'+postfix).srcType1Corrections = cms.VInputTag(
-#     cms.InputTag("patPFJetMETtype1p2Corr"+postfix,"type1"),
-#     cms.InputTag("patPFMETtype0Corr"+postfix),
-#     )
-## to add type-2 corrections to your type-1 or type-0+1 corrected MET uncomment the following:
-# getattr(process,'patMETs'+postfix).metSource = 'patType1p2CorrectedPFMet'+postfix
-
-# to run second PF2PAT+PAT with different postfix uncomment the following lines
-# and add the corresponding sequence to the path
-#postfix2 = "PFlow2"
-#jetAlgo2="AK7"
-#usePF2PAT(process,runPF2PAT=True, jetAlgo=jetAlgo2, runOnMC=True, postfix=postfix2, typeIMetCorrections=True)
-
-# to use tau-cleaned jet collection uncomment the following:
-#getattr(process,"pfNoTau"+postfix).enable = True
-
-# to switch default tau (HPS) to old default tau (shrinking cone) uncomment
-# the following:
-# note: in current default taus are not preselected i.e. you have to apply
-# selection yourself at analysis level!
-#adaptPFTaus(process,"shrinkingConePFTau",postfix=postfix)
-
-# to use GsfElectrons instead of PF electrons
-# useGsfElectrons(process,postfix)
-
-# Let it run
-process.p = cms.Path(
-#    process.patDefaultSequence  +
-    getattr(process,"patPF2PATSequence"+postfix)
-#    second PF2PAT
-#    + getattr(process,"patPF2PATSequence"+postfix2)
-)
-
-# Add PF2PAT output to the created file
-from PhysicsTools.PatAlgos.patEventContent_cff import patEventContentNoCleaning
-#process.load("CommonTools.ParticleFlow.PF2PAT_EventContent_cff")
-#process.out.outputCommands =  cms.untracked.vstring('drop *')
-process.out.outputCommands = cms.untracked.vstring('drop *',
-                                                   'keep recoPFCandidates_particleFlow_*_*',
-                                                   *patEventContentNoCleaning )
-
-
-# top projections in PF2PAT:
-getattr(process,"pfNoPileUp"+postfix).enable = True
-getattr(process,"pfNoMuon"+postfix).enable = True
-getattr(process,"pfNoElectron"+postfix).enable = True
-getattr(process,"pfNoTau"+postfix).enable = False
-getattr(process,"pfNoJet"+postfix).enable = True
-
-# verbose flags for the PF2PAT modules
-getattr(process,"pfNoMuon"+postfix).verbose = False
-
-# enable delta beta correction for muon selection in PF2PAT?
-getattr(process,"pfIsolatedMuons"+postfix).doDeltaBetaCorrection = False
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 100
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_PF2PATTypeI.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_PF2PAT_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_PF2PAT_cfg.py
deleted file mode 100644
index 9f8822a..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_PF2PAT_cfg.py
+++ /dev/null
@@ -1,83 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-# load the PAT config
-process.load("PhysicsTools.PatAlgos.patSequences_cff")
-
-
-# Configure PAT to use PF2PAT instead of AOD sources
-# this function will modify the PAT sequences.
-from PhysicsTools.PatAlgos.tools.pfTools import *
-
-postfix = "PFlow"
-jetAlgo="AK5"
-usePF2PAT(process,runPF2PAT=True, jetAlgo=jetAlgo, runOnMC=True, postfix=postfix)
-
-# to turn on type-1 MET corrections, use the following call
-#usePF2PAT(process,runPF2PAT=True, jetAlgo=jetAlgo, runOnMC=True, postfix=postfix, typeIMetCorrections=True)
-
-# to run second PF2PAT+PAT with different postfix uncomment the following lines
-# and add the corresponding sequence to the path
-#postfix2 = "PFlow2"
-#jetAlgo2="AK7"
-#usePF2PAT(process,runPF2PAT=True, jetAlgo=jetAlgo2, runOnMC=True, postfix=postfix2)
-
-# to use tau-cleaned jet collection uncomment the following:
-#getattr(process,"pfNoTau"+postfix).enable = True
-
-# to switch default tau (HPS) to old default tau (shrinking cone) uncomment
-# the following:
-# note: in current default taus are not preselected i.e. you have to apply
-# selection yourself at analysis level!
-#adaptPFTaus(process,"shrinkingConePFTau",postfix=postfix)
-
-# to use GsfElectrons instead of PF electrons
-# useGsfElectrons(process,postfix)
-
-# Let it run
-process.p = cms.Path(
-#    process.patDefaultSequence  +
-    getattr(process,"patPF2PATSequence"+postfix)
-#    second PF2PAT
-#    + getattr(process,"patPF2PATSequence"+postfix2)
-)
-
-# Add PF2PAT output to the created file
-from PhysicsTools.PatAlgos.patEventContent_cff import patEventContentNoCleaning
-#process.load("CommonTools.ParticleFlow.PF2PAT_EventContent_cff")
-#process.out.outputCommands =  cms.untracked.vstring('drop *')
-process.out.outputCommands = cms.untracked.vstring('drop *',
-                                                   'keep recoPFCandidates_particleFlow_*_*',
-                                                   *patEventContentNoCleaning )
-
-
-# top projections in PF2PAT:
-getattr(process,"pfNoPileUp"+postfix).enable = True
-getattr(process,"pfNoMuon"+postfix).enable = True
-getattr(process,"pfNoElectron"+postfix).enable = True
-getattr(process,"pfNoTau"+postfix).enable = False
-getattr(process,"pfNoJet"+postfix).enable = True
-
-# verbose flags for the PF2PAT modules
-getattr(process,"pfNoMuon"+postfix).verbose = False
-
-# enable delta beta correction for muon selection in PF2PAT?
-getattr(process,"pfIsolatedMuons"+postfix).doDeltaBetaCorrection = False
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 100
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_PF2PAT.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_addBTagging_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_addBTagging_cfg.py
deleted file mode 100644
index 23a3711..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_addBTagging_cfg.py
+++ /dev/null
@@ -1,57 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-##from PhysicsTools.PatAlgos.tools.coreTools import *
-##removeMCMatching(process, ['All'])
-
-## uncomment the following line to add tcMET to the event content
-from PhysicsTools.PatAlgos.tools.metTools import *
-addTcMET(process, 'TC')
-addPfMET(process, 'PF')
-
-## uncomment the following line to add different b-taggers collections
-## to the event content
-from PhysicsTools.PatAlgos.tools.jetTools import *
-
-process.patJets.addTagInfos = True
-
-# uncomment the following lines to add ak5PFJets with new b-tags to your PAT output
-addJetCollection(process,cms.InputTag('ak5PFJets'),
-                 'AK5', 'PF',
-                 doJTA        = True,
-                 doBTagging   = True,
-                 btagInfo           = cms.vstring('impactParameterTagInfos','secondaryVertexTagInfos','secondaryVertexNegativeTagInfos','inclusiveSecondaryVertexFinderTagInfos'),
-                 btagdiscriminators = cms.vstring('jetBProbabilityBJetTags','jetProbabilityBJetTags','trackCountingHighPurBJetTags','trackCountingHighEffBJetTags','simpleSecondaryVertexHighEffBJetTags','simpleSecondaryVertexHighPurBJetTags','combinedSecondaryVertexBJetTags','combinedInclusiveSecondaryVertexBJetTags'),
-                 jetCorrLabel = ('AK5PF', cms.vstring(['L1FastJet', 'L2Relative', 'L3Absolute'])),
-                 doType1MET   = True,
-                 doL1Cleaning = True,
-                 doL1Counters = False,
-                 genJetCollection=cms.InputTag("ak5GenJets"),
-                 doJetID      = True,
-                 jetIdLabel   = "ak5"
-                 )
-process.patJetsAK5PF.addTagInfos = True
-
-## let it run
-process.p = cms.Path(
-    process.patDefaultSequence
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-## switch to RECO input
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_addBTagging.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_addDecayInFlight_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_addDecayInFlight_cfg.py
deleted file mode 100644
index d341b9a..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_addDecayInFlight_cfg.py
+++ /dev/null
@@ -1,69 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## switch to RECO input
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarGENSIMRECO
-process.source.fileNames = filesRelValProdTTbarGENSIMRECO
-
-## add inFlightMuons
-process.load("SimGeneral.HepPDTESSource.pythiapdt_cfi")
-process.inFlightMuons = cms.EDProducer("PATGenCandsFromSimTracksProducer",
-        src           = cms.InputTag("g4SimHits"),   ## use "famosSimHits" for FAMOS
-        setStatus     = cms.int32(-1),
-        particleTypes = cms.vstring("mu+"),          ## picks also mu-, of course
-        filter        = cms.vstring("pt > 0.5"),     ## just for testing
-        makeMotherLink = cms.bool(True),
-        writeAncestors = cms.bool(True),             ## save also the intermediate GEANT ancestors of the muons
-        genParticles   = cms.InputTag("genParticles"),
-)
-## prepare several clones of match associations for status 1, 3 and in flight muons (status -1)
-process.muMatch3 = process.muonMatch.clone(mcStatus = cms.vint32( 3))
-process.muMatch1 = process.muonMatch.clone(mcStatus = cms.vint32( 1))
-process.muMatchF = process.muonMatch.clone(mcStatus = cms.vint32(-1),matched = cms.InputTag("inFlightMuons"))
-
-## add the new matches to the default sequence
-process.patDefaultSequence.replace(process.muonMatch,
-                                   process.muMatch1 +
-                                   process.muMatch3 +
-                                   process.muMatchF
-                                   )
-
-## embed the new matches to the patMuon (they are then accessible via
-## genMuon(int idx))
-process.patMuons.genParticleMatch = cms.VInputTag(
-    cms.InputTag("muMatch3"),
-    cms.InputTag("muMatch1"),
-    cms.InputTag("muMatchF"),
-)
-
-## dump event content
-process.content = cms.EDAnalyzer("EventContentAnalyzer")
-
-## add the in flight muons to the output
-process.out.outputCommands.append('keep *_inFlightMuons_*_*')
-
-## let it run
-process.p = cms.Path(
-    #process.content +
-    process.inFlightMuons +
-    process.patDefaultSequence
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-## switch to RECO input
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarGENSIMRECO
-process.source.fileNames = filesRelValProdTTbarGENSIMRECO
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_addDecayInFlight.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_addJets_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_addJets_cfg.py
deleted file mode 100644
index 01cba43..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_addJets_cfg.py
+++ /dev/null
@@ -1,105 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-##from PhysicsTools.PatAlgos.tools.coreTools import *
-##removeMCMatching(process, ['All'])
-
-## uncomment the following line to add tcMET to the event content
-from PhysicsTools.PatAlgos.tools.metTools import *
-addTcMET(process, 'TC')
-addPfMET(process, 'PF')
-
-## uncomment the following line to add different jet collections
-## to the event content
-from PhysicsTools.PatAlgos.tools.jetTools import *
-
-
-## uncomment the following lines to add ak5JPTJets to your PAT output
-#addJetCollection(process,cms.InputTag('JetPlusTrackZSPCorJetAntiKt5'),
-#                 'AK5', 'JPT',
-#                 doJTA        = True,
-#                 doBTagging   = True,
-#                 jetCorrLabel = ('AK5JPT', cms.vstring(['L1FastJet', 'L2Relative', 'L3Absolute'])),
-#                 doType1MET   = False,
-#                 doL1Cleaning = False,
-#                 doL1Counters = True,
-#                 genJetCollection = cms.InputTag("ak5GenJets"),
-#                 doJetID      = True,
-#                 jetIdLabel   = "ak5"
-#                 )
-
-## uncomment the following lines to add ak7CaloJets to your PAT output
-addJetCollection(process,cms.InputTag('ak7CaloJets'),
-                 'AK7', 'Calo',
-                 doJTA        = True,
-                 doBTagging   = False,
-                 jetCorrLabel = ('AK7Calo', cms.vstring(['L1FastJet', 'L2Relative', 'L3Absolute'])),
-                 doType1MET   = True,
-                 doL1Cleaning = True,
-                 doL1Counters = False,
-                 genJetCollection=cms.InputTag("ak7GenJets"),
-                 doJetID      = True,
-                 jetIdLabel   = "ak7"
-                 )
-
-### uncomment the following lines to add kt4CaloJets to your PAT output
-#addJetCollection(process,cms.InputTag('kt4CaloJets'),
-#                 'KT4', 'Calo',
-#                 doJTA        = True,
-#                 doBTagging   = True,
-#                 jetCorrLabel = ('KT4Calo', cms.vstring(['L2Relative', 'L3Absolute'])),
-#                 doType1MET   = True,
-#                 doL1Cleaning = True,
-#                 doL1Counters = False,
-#                 genJetCollection=cms.InputTag("kt4GenJets"),
-#                 doJetID      = True,
-#                 jetIdLabel   = "kt4"
-#                 )
-
-### uncomment the following lines to add kt6CaloJets to your PAT output
-#addJetCollection(process,cms.InputTag('kt6PFJets'),
-#                 'KT6', 'PF',
-#                 doJTA        = True,
-#                 doBTagging   = False,
-#                 #jetCorrLabel = ('KT6PF', cms.vstring()), # currently not available
-#                 doType1MET   = False,
-#                 doL1Cleaning = True,
-#                 doL1Counters = False,
-#                 genJetCollection=cms.InputTag("kt6GenJets"),
-#                 doJetID      = True,
-#                 jetIdLabel   = "kt6"
-#                 )
-
-## uncomment the following lines to add ak5PFJets to your PAT output
-switchJetCollection(process,cms.InputTag('ak5PFJets'),
-                 doJTA        = True,
-                 doBTagging   = True,
-                 jetCorrLabel = ('AK5PF', cms.vstring(['L1FastJet', 'L2Relative', 'L3Absolute'])),
-                 doType1MET   = True,
-                 genJetCollection=cms.InputTag("ak5GenJets"),
-                 doJetID      = True
-                 )
-
-## let it run
-process.p = cms.Path(
-    process.patDefaultSequence
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-## switch to RECO input
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarGENSIMRECO
-process.source.fileNames = filesRelValProdTTbarGENSIMRECO
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_addJets.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_addTracks_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_addTracks_cfg.py
deleted file mode 100644
index 0059bde..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_addTracks_cfg.py
+++ /dev/null
@@ -1,42 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## add track candidates
-from PhysicsTools.PatAlgos.tools.trackTools import *
-
-makeTrackCandidates(process,
-    label        = 'TrackCands',
-    tracks       = cms.InputTag('generalTracks'),
-    particleType = 'pi+',
-    preselection = 'pt > 10',
-    selection    = 'pt > 10',
-    isolation    = {'tracker':0.3, 'ecalTowers':0.3, 'hcalTowers':0.3},
-    isoDeposits  = [],
-    mcAs         = 'muon'
-)
-
-## add generic tracks to the output file
-process.out.outputCommands.append('keep *_selectedPatTrackCands_*_*')
-
-## let it run
-process.p = cms.Path(
-    process.patDefaultSequence
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_addTracks.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_addTriggerInfo_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_addTriggerInfo_cfg.py
deleted file mode 100644
index 45f4ad7..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_addTriggerInfo_cfg.py
+++ /dev/null
@@ -1,29 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## let it run
-process.p = cms.Path(
-    process.patDefaultSequence
-)
-
-## add trigger information to the configuration
-from PhysicsTools.PatAlgos.tools.trigTools import *
-switchOnTrigger( process )
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_addTriggerInfo.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_addVertexInfo_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_addVertexInfo_cfg.py
deleted file mode 100644
index de0fb6e..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_addVertexInfo_cfg.py
+++ /dev/null
@@ -1,80 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## add track candidates
-from PhysicsTools.PatAlgos.tools.trackTools import *
-
-makeTrackCandidates(process,
-    label        = 'TrackCands',
-    tracks       = cms.InputTag('generalTracks'),
-    particleType = 'pi+',
-    preselection = 'pt > 10',
-    selection    = 'pt > 10',
-    isolation    = {'tracker':0.3, 'ecalTowers':0.3, 'hcalTowers':0.3},
-    isoDeposits  = [],
-    mcAs         = 'muon'
-)
-
-## select best vertex
-process.bestVertex = cms.EDFilter(
-    "PATSingleVertexSelector",
-    mode      = cms.string("nearestToCandidate"),
-    fallbacks = cms.vstring("fromCandidate", "beamSpot"),
-    vertices              = cms.InputTag("offlinePrimaryVerticesWithBS"),
-    vertexPreselection    = cms.vstring("(chi2prob(chi2,ndf) > 0.01) && (trackSize >= 3)"),
-    candidates            = cms.VInputTag(cms.InputTag('gsfElectrons'), cms.InputTag('muons')),
-    candidatePreselection = cms.string("pt > 5"),
-    beamSpot              = cms.InputTag('offlineBeamSpot'),
-)
-
-## produce vertex associations
-process.patTrackVertexInfo = cms.EDProducer(
-    "PATVertexAssociationProducer",
-    candidates = cms.VInputTag(
-    cms.InputTag('gsfElectrons'),
-    cms.InputTag('muons'),
-    cms.InputTag('patAODTrackCands'),
-    ),
-    useTracks = cms.bool(True),
-    vertices  = cms.InputTag('bestVertex'),
-)
-
-## add modules to the default sequence right after the patAODTrackCands
-process.patDefaultSequence.replace(process.patAODTrackCands,
-                                   process.patAODTrackCands *
-                                   process.bestVertex *
-                                   process.patTrackVertexInfo
-                                   )
-
-## add it to the track candidates
-process.patTrackCands.vertexing = cms.PSet(
-    vertexAssociations = cms.InputTag("patTrackVertexInfo"),
-)
-
-## add generic tracks to the output file
-process.out.outputCommands.append('keep *_selectedPatTrackCands_*_*')
-process.out.outputCommands.append('keep *_patTrackVertexInfo_*_*')
-process.out.outputCommands.append('keep *_bestVertex_*_*')
-
-## let it run
-process.p = cms.Path(
-        process.patDefaultSequence
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_addVertexInfo.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_caloTaus_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_caloTaus_cfg.py
deleted file mode 100644
index 33e76e4..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_caloTaus_cfg.py
+++ /dev/null
@@ -1,34 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## ------------------------------------------------------
-#  switch to CaloTau. Outputs will be:
-#  - patCaloTaus,
-#  - selectedPatCaloTaus,
-#  - cleanPatCaloTaus
-## ------------------------------------------------------
-from PhysicsTools.PatAlgos.tools.tauTools import switchToCaloTau
-switchToCaloTau(process)
-
-## let it run
-process.p = cms.Path(
-            process.patDefaultSequence
-            )
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_caloTaus.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_factorisedTaginfo_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_factorisedTaginfo_cfg.py
deleted file mode 100644
index 8e1c8ef..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_factorisedTaginfo_cfg.py
+++ /dev/null
@@ -1,107 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-from PhysicsTools.PatAlgos.tools.jetTools import *
-
-addJetCollection(process,cms.InputTag('ak7CaloJets'),
-                 'AK7', 'Calo',
-                 doJTA        = True,
-#                 doBTagging   = False,
-                 doBTagging   = True,
-#                 jetCorrLabel = ('AK7CaloJets', ['L2Relative', 'L3Absolute']),
-                 doType1MET   = True,
-                 doL1Cleaning = True,
-                 doL1Counters = False,
-                 genJetCollection=cms.InputTag("ak7GenJets"),
-
-                 doJetID      = True,
-                 jetIdLabel   = "ak7"
-
-
-#		 ,btagInfo    = ['impactParameterTagInfos','secondaryVertexTagInfos','softMuonTagInfos']
-
-
-
-#######		  ,btagInfo = ['impactParameterTagInfos']
-#                 ,btagInfo = ['softMuonTagInfos']
-#                 ,btagInfo = ['impactParameterTagInfos','secondaryVertexTagInfos']
-#   		 ,btagInfo = ['impactParameterTagInfos','secondaryVertexTagInfos','secondaryVertexNegativeTagInfos']
-
-
-#		 ,btagdiscriminators=['jetBProbabilityBJetTags', 'jetProbabilityBJetTags', 'trackCountingHighPurBJetTags','trackCountingHighEffBJetTags',
-#	'simpleSecondaryVertexHighEffBJetTags','simpleSecondaryVertexHighPurBJetTags','combinedSecondaryVertexBJetTags','combinedSecondaryVertexMVABJetTags','softMuonBJetTags','softMuonByPtBJetTags','softMuonByIP3dBJetTags']
-
-#		,btagdiscriminators=['softMuonBJetTags','softMuonByPtBJetTags','jetBProbabilityBJetTags', 'jetProbabilityBJetTags', 'trackCountingHighPurBJetTags','trackCountingHighEffBJetTags']
-
-
-#                ,btagdiscriminators=['jetBProbabilityBJetTags','jetProbabilityBJetTags','trackCountingHighPurBJetTags','trackCountingHighEffBJetTags']
-#                ,btagdiscriminators=['softMuonBJetTags','softMuonByPtBJetTags','softMuonByIP3dBJetTags']
-#                ,btagdiscriminators=['combinedSecondaryVertexBJetTags','combinedSecondaryVertexMVABJetTags']
-###                ,btagdiscriminators=['simpleSecondaryVertexHighEffBJetTags','simpleSecondaryVertexHighPurBJetTags']
-##                ,btagdiscriminators=['simpleSecondaryVertexNegativeHighEffBJetTags','simpleSecondaryVertexNegativeHighPurBJetTags','negativeTrackCountingHighEffJetTags','negativeTrackCountingHighPurJetTags']
-#		 ,btagdiscriminators=['negativeTrackCountingHighEffJetTags','negativeTrackCountingHighPurJetTags']
-
-
-	)
-
-switchJetCollection(process,cms.InputTag('ak5PFJets'),
-                 doJTA        = True,
-#                 doBTagging   = False,
-                 doBTagging   = True,
-#                 jetCorrLabel = None,
-                 doType1MET   = True,
-                 genJetCollection=cms.InputTag("ak5GenJets"),
-                 doJetID      = True
-
-#                ,btagInfo    = ['impactParameterTagInfos','secondaryVertexTagInfos','softMuonTagInfos']
-
-#######                 ,btagInfo = ['impactParameterTagInfos']
-###                 ,btagInfo = ['softMuonTagInfos']
-#                 ,btagInfo = ['impactParameterTagInfos','secondaryVertexTagInfos']
-#                 ,btagInfo = ['impactParameterTagInfos','secondaryVertexTagInfos','secondaryVertexNegativeTagInfos']
-
-
-
-#                ,btagdiscriminators=['jetBProbabilityBJetTags', 'jetProbabilityBJetTags', 'trackCountingHighPurBJetTags','trackCountingHighEffBJetTags',
-#       'simpleSecondaryVertexHighEffBJetTags','simpleSecondaryVertexHighPurBJetTags','combinedSecondaryVertexBJetTags','combinedSecondaryVertexMVABJetTags','softMuonBJetTags','softMuonByPtBJetTags','softMuonByIP3dBJetTags']
-
-#               ,btagdiscriminators=['softMuonBJetTags','softMuonByPtBJetTags','jetBProbabilityBJetTags', 'jetProbabilityBJetTags', 'trackCountingHighPurBJetTags','trackCountingHighEffBJetTags']
-
-
-#                ,btagdiscriminators=['jetBProbabilityBJetTags','jetProbabilityBJetTags','trackCountingHighPurBJetTags','trackCountingHighEffBJetTags']
-###                ,btagdiscriminators=['softMuonBJetTags','softMuonByPtBJetTags','softMuonByIP3dBJetTags']
-#                ,btagdiscriminators=['combinedSecondaryVertexBJetTags','combinedSecondaryVertexMVABJetTags']
-#                ,btagdiscriminators=['simpleSecondaryVertexHighEffBJetTags','simpleSecondaryVertexHighPurBJetTags']
-#                ,btagdiscriminators=['simpleSecondaryVertexNegativeHighEffBJetTags','simpleSecondaryVertexNegativeHighPurBJetTags','negativeTrackCountingHighEffJetTags','negativeTrackCountingHighPurJetTags']
-#                ,btagdiscriminators=['negativeTrackCountingHighEffJetTags','negativeTrackCountingHighPurJetTags']
-#
-
-                 )
-
-#process.patJetsAK7Calo.addTagInfos = True
-#process.patJets.addTagInfos = False
-
-process.p = cms.Path(
-    process.patDefaultSequence
-    )
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_factorisedTagInfo.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
-
-
-
diff --git a/PhysicsTools/PatAlgos/test/patTuple_fastsim_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_fastsim_cfg.py
deleted file mode 100644
index f2e6886..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_fastsim_cfg.py
+++ /dev/null
@@ -1,25 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## let it run
-process.p = cms.Path(
-        process.patDefaultSequence
-    )
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_fastsim.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_metUncertainties_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_metUncertainties_cfg.py
deleted file mode 100644
index 4bff593..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_metUncertainties_cfg.py
+++ /dev/null
@@ -1,41 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-process.load("PhysicsTools.PatUtils.patPFMETCorrections_cff")
-
-from PhysicsTools.PatAlgos.tools.jetTools import switchJetCollection
-switchJetCollection(process,cms.InputTag('ak5PFJets'),
-                 doBTagging   = False,
-                 jetCorrLabel = ('AK5PF', cms.vstring(['L1FastJet', 'L2Relative', 'L3Absolute'])),
-                 doType1MET   = False
-                 )
-
-## let it run
-process.p = cms.Path(
-  process.type0PFMEtCorrection
-* process.patPFMETtype0Corr
-* process.patDefaultSequence
-)
-
-# apply type I/type I + II PFMEt corrections to pat::MET object
-# and estimate systematic uncertainties on MET
-from PhysicsTools.PatUtils.tools.metUncertaintyTools import runMEtUncertainties
-runMEtUncertainties(process)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-## switch to RECO input
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_metUncertainties.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_onlyElectrons_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_onlyElectrons_cfg.py
deleted file mode 100644
index 3791999..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_onlyElectrons_cfg.py
+++ /dev/null
@@ -1,33 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## load tau sequences up to selectedPatElectrons
-process.load("PhysicsTools.PatAlgos.producersLayer1.electronProducer_cff")
-process.load("PhysicsTools.PatAlgos.selectionLayer1.electronSelector_cfi")
-
-## make sure to keep the created objects
-process.out.outputCommands = ['keep *_selectedPat*_*_*',]
-
-## let it run
-process.p = cms.Path(
-    process.makePatElectrons *
-    process.selectedPatElectrons
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_onlyElectrons.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_onlyJets_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_onlyJets_cfg.py
deleted file mode 100644
index c7dcb1c..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_onlyJets_cfg.py
+++ /dev/null
@@ -1,33 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## load tau sequences up to selectedPatJets
-process.load("PhysicsTools.PatAlgos.producersLayer1.jetProducer_cff")
-process.load("PhysicsTools.PatAlgos.selectionLayer1.jetSelector_cfi")
-
-## make sure to keep the created objects
-process.out.outputCommands = ['keep *_selectedPat*_*_*',]
-
-## let it run
-process.p = cms.Path(
-     process.makePatJets *
-     process.selectedPatJets
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_onlyJets.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_onlyMET_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_onlyMET_cfg.py
deleted file mode 100644
index d4bef2e..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_onlyMET_cfg.py
+++ /dev/null
@@ -1,31 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## load met sequences up to patMETs
-process.load("PhysicsTools.PatAlgos.producersLayer1.metProducer_cff")
-
-## make sure to keep the created objects
-process.out.outputCommands = ['keep *_patMETs*_*_*',]
-
-## let it run
-process.p = cms.Path(
-     process.makePatMETs
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_onlyMET.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_onlyMuons_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_onlyMuons_cfg.py
deleted file mode 100644
index 74a5b66..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_onlyMuons_cfg.py
+++ /dev/null
@@ -1,33 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## load tau sequences up to selectedPatMuons
-process.load("PhysicsTools.PatAlgos.producersLayer1.muonProducer_cff")
-process.load("PhysicsTools.PatAlgos.selectionLayer1.muonSelector_cfi")
-
-## make sure to keep the created objects
-process.out.outputCommands = ['keep *_selectedPat*_*_*',]
-
-## let it run
-process.p = cms.Path(
-    process.makePatMuons *
-    process.selectedPatMuons
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_onlyMuons.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_onlyPhotons_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_onlyPhotons_cfg.py
deleted file mode 100644
index 7694a45..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_onlyPhotons_cfg.py
+++ /dev/null
@@ -1,33 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## load photon sequencesup to selectedPatPhotons
-process.load("PhysicsTools.PatAlgos.producersLayer1.photonProducer_cff")
-process.load("PhysicsTools.PatAlgos.selectionLayer1.photonSelector_cfi")
-
-## make sure to keep the created objects
-process.out.outputCommands = ['keep *_selectedPat*_*_*',]
-
-## let it run
-process.p = cms.Path(
-    process.makePatPhotons *
-    process.selectedPatPhotons
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_onlyPhotons.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_onlyTaus_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_onlyTaus_cfg.py
deleted file mode 100644
index 59f6bb6..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_onlyTaus_cfg.py
+++ /dev/null
@@ -1,33 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-## load tau sequences up to selectedPatTaus
-process.load("PhysicsTools.PatAlgos.producersLayer1.tauProducer_cff")
-process.load("PhysicsTools.PatAlgos.selectionLayer1.tauSelector_cfi")
-
-## make sure to keep the created objects
-process.out.outputCommands = ['keep *_selectedPat*_*_*',]
-
-## let it run
-process.p = cms.Path(
-    process.makePatTaus *
-    process.selectedPatTaus
-)
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_onlyTaus.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_pfIso_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_pfIso_cfg.py
deleted file mode 100644
index de5edb7..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_pfIso_cfg.py
+++ /dev/null
@@ -1,35 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-from PhysicsTools.PatAlgos.tools.pfTools import *
-usePFIso( process )
-
-# process.patElectrons.pfElectronSource = 'particleFlow'
-
-## let it run
-process.p = cms.Path(
-    process.patDefaultSequence
-    #process.pfParticleSelectionSequence +
-    #process.eleIsoSequence +
-    #process.makePatElectrons +
-    #process.selectedPatElectrons
-    )
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_pfIso.root'
-#                                         ##
-# process.options.wantSummary = False     ##  (to suppress the long output at the end of the job)
-
diff --git a/PhysicsTools/PatAlgos/test/patTuple_standard_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_standard_cfg.py
deleted file mode 100644
index 7d5aeb8..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_standard_cfg.py
+++ /dev/null
@@ -1,43 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-
-## ------------------------------------------------------
-#  NOTE: you can use a bunch of core tools of PAT to
-#  taylor your PAT configuration; for a few examples
-#  uncomment the lines below
-## ------------------------------------------------------
-#from PhysicsTools.PatAlgos.tools.coreTools import *
-
-## remove MC matching from the default sequence
-# removeMCMatching(process, ['Muons'])
-# runOnData(process)
-
-## remove certain objects from the default sequence
-# removeAllPATObjectsBut(process, ['Muons'])
-# removeSpecificPATObjects(process, ['Electrons', 'Muons', 'Taus'])
-
-
-## let it run
-process.p = cms.Path(
-    process.patDefaultSequence
-    )
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 100
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_standard.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
-
diff --git a/PhysicsTools/PatAlgos/test/patTuple_topSelection_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_topSelection_cfg.py
deleted file mode 100644
index d0fb661..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_topSelection_cfg.py
+++ /dev/null
@@ -1,179 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-from PhysicsTools.PatAlgos.tools.coreTools import *
-removeMCMatching(process, ['All'])
-
-removeSpecificPATObjects(process,
-                         ['Photons'],  # 'Tau' has currently been taken out due to problems with tau discriminators
-                         outputModules=[])
-
-removeCleaning(process,
-               outputModules=[])
-
-process.patJetCorrFactors.payload = 'AK5Calo'
-# For data:
-#process.patJetCorrFactors.levels = ['L2Relative', 'L3Absolute', 'L2L3Residual', 'L5Flavor', 'L7Parton']
-# For MC:
-process.patJetCorrFactors.levels = ['L2Relative', 'L3Absolute']
-#process.patJetCorrFactors.flavorType = "T"
-
-process.patMuons.usePV = False
-
-#-------------------------------------------------
-# selection step 1: trigger
-#-------------------------------------------------
-
-from HLTrigger.HLTfilters.hltHighLevel_cfi import *
-process.step1 = hltHighLevel.clone(TriggerResultsTag = "TriggerResults::HLT", HLTPaths = ["HLT_Mu15_eta2p1_v3"])
-
-#-------------------------------------------------
-# selection step 2: vertex filter
-#-------------------------------------------------
-
-# vertex filter
-process.step2 = cms.EDFilter("VertexSelector",
-                             src = cms.InputTag("offlinePrimaryVertices"),
-                             cut = cms.string("!isFake && ndof > 4 && abs(z) < 15 && position.Rho < 2"),
-                             filter = cms.bool(True),
-                             )
-
-#-------------------------------------------------
-# selection steps 3 and 4: muon selection
-#-------------------------------------------------
-
-from PhysicsTools.PatAlgos.cleaningLayer1.muonCleaner_cfi import *
-process.isolatedMuons010 = cleanPatMuons.clone(preselection =
-                                               'isGlobalMuon & isTrackerMuon &'
-                                               'pt > 20. &'
-                                               'abs(eta) < 2.1 &'
-                                               '(trackIso+caloIso)/pt < 0.1 &'
-                                               'innerTrack.numberOfValidHits > 10 &'
-                                               'globalTrack.normalizedChi2 < 10.0 &'
-                                               'globalTrack.hitPattern.numberOfValidMuonHits > 0 &'
-                                               'abs(dB) < 0.02'
-                                               )
-
-process.isolatedMuons010.checkOverlaps = cms.PSet(
-        jets = cms.PSet(src       = cms.InputTag("goodJets"),
-                        algorithm = cms.string("byDeltaR"),
-                        preselection        = cms.string(""),
-                        deltaR              = cms.double(0.3),
-                        checkRecoComponents = cms.bool(False),
-                        pairCut             = cms.string(""),
-                        requireNoOverlaps   = cms.bool(True),
-                        )
-            )
-process.isolatedMuons005 = cleanPatMuons.clone(src = 'isolatedMuons010',
-                                               preselection = '(trackIso+caloIso)/pt < 0.05'
-                                               )
-
-process.vetoMuons = cleanPatMuons.clone(preselection =
-                                        'isGlobalMuon &'
-                                        'pt > 10. &'
-                                        'abs(eta) < 2.5 &'
-                                        '(trackIso+caloIso)/pt < 0.2'
-                                        )
-
-from PhysicsTools.PatAlgos.selectionLayer1.muonCountFilter_cfi import *
-process.step3a = countPatMuons.clone(src = 'isolatedMuons005', minNumber = 1, maxNumber = 1)
-process.step3b = countPatMuons.clone(src = 'isolatedMuons010', minNumber = 1, maxNumber = 1)
-process.step4  = countPatMuons.clone(src = 'vetoMuons', maxNumber = 1)
-
-#-------------------------------------------------
-# selection step 5: electron selection
-#-------------------------------------------------
-
-from PhysicsTools.PatAlgos.selectionLayer1.electronSelector_cfi import *
-process.vetoElectrons = selectedPatElectrons.clone(src = 'selectedPatElectrons',
-                                                   cut =
-                                                   'et > 15. &'
-                                                   'abs(eta) < 2.5 &'
-                                                   '(dr03TkSumPt+dr03EcalRecHitSumEt+dr03HcalTowerSumEt)/et <  0.2'
-                                                   )
-
-from PhysicsTools.PatAlgos.selectionLayer1.electronCountFilter_cfi import *
-process.step5  = countPatMuons.clone(src = 'vetoElectrons', maxNumber = 0)
-
-#-------------------------------------------------
-# selection steps 6 and 7: jet selection
-#-------------------------------------------------
-
-from PhysicsTools.PatAlgos.selectionLayer1.jetSelector_cfi import *
-process.goodJets = selectedPatJets.clone(src = 'patJets',
-                                         cut =
-                                         'pt > 30. &'
-                                         'abs(eta) < 2.4 &'
-                                         'emEnergyFraction > 0.01 &'
-                                         'jetID.n90Hits > 1 &'
-                                         'jetID.fHPD < 0.98'
-                                         )
-
-from PhysicsTools.PatAlgos.selectionLayer1.jetCountFilter_cfi import *
-process.step6a = countPatJets.clone(src = 'goodJets', minNumber = 1)
-process.step6b = countPatJets.clone(src = 'goodJets', minNumber = 2)
-process.step6c = countPatJets.clone(src = 'goodJets', minNumber = 3)
-process.step7  = countPatJets.clone(src = 'goodJets', minNumber = 4)
-
-#-------------------------------------------------
-# paths
-#-------------------------------------------------
-
-process.looseSequence = cms.Path(process.step1 *
-                                 process.step2 *
-                                 process.patDefaultSequence *
-                                 process.goodJets *
-                                 process.isolatedMuons010 *
-                                 process.step3b *
-                                 process.vetoMuons *
-                                 process.step4 *
-                                 process.vetoElectrons *
-                                 process.step5 *
-                                 process.step6a *
-                                 process.step6b *
-                                 process.step6c
-                                 )
-
-process.tightSequence = cms.Path(process.step1 *
-                                 process.step2 *
-                                 process.patDefaultSequence *
-                                 process.goodJets *
-                                 process.isolatedMuons010 *
-                                 process.isolatedMuons005 *
-                                 process.step3a *
-                                 process.vetoMuons *
-                                 process.step4 *
-                                 process.vetoElectrons *
-                                 process.step5 *
-                                 process.step6a *
-                                 process.step6b *
-                                 process.step6c *
-                                 process.step7
-                                )
-
-
-process.out.SelectEvents.SelectEvents = ['tightSequence',
-                                         'looseSequence' ]
-
-from PhysicsTools.PatAlgos.patEventContent_cff import patEventContentNoCleaning
-process.out.outputCommands = cms.untracked.vstring('drop *', *patEventContentNoCleaning )
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 1000
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_topSelection.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/patTuple_userData_cfg.py b/PhysicsTools/PatAlgos/test/patTuple_userData_cfg.py
deleted file mode 100644
index dc34f4a..0000000
--- a/PhysicsTools/PatAlgos/test/patTuple_userData_cfg.py
+++ /dev/null
@@ -1,66 +0,0 @@
-## import skeleton process
-from PhysicsTools.PatAlgos.patTemplate_cfg import *
-
-# load the PAT config
-process.load("PhysicsTools.PatAlgos.patSequences_cff")
-
-# Configure PAT to use PF2PAT instead of AOD sources
-# this function will modify the PAT sequences. It is currently
-# not possible to run PF2PAT+PAT and standart PAT at the same time
-from PhysicsTools.PatAlgos.tools.pfTools import *
-
-# An empty postfix means that only PF2PAT is run,
-# otherwise both standard PAT and PF2PAT are run. In the latter case PF2PAT
-# collections have standard names + postfix (e.g. patElectronPFlow)
-postfix = "PFlow"
-usePF2PAT(process,runPF2PAT=True, jetAlgo='AK5', runOnMC=True, postfix=postfix)
-
-# turn to false when running on data
-getattr(process, "patElectrons"+postfix).embedGenMatch = True
-getattr(process, "patMuons"+postfix).embedGenMatch = True
-
-# add user data
-getattr(process, "patElectrons"+postfix).userData.userFunctions.append( 'trackIso * caloIso' )
-getattr(process, "patMuons"+postfix).userData.userFunctions.append( 'trackIso * caloIso' )
-process.patElectrons.userData.userFunctions.append( 'trackIso * caloIso' )
-process.patMuons.userData.userFunctions.append( 'trackIso * caloIso' )
-
-getattr(process, "patElectrons"+postfix).userData.userFunctionLabels.append( 'trackIso * caloIso' )
-getattr(process, "patMuons"+postfix).userData.userFunctionLabels.append( 'trackIso * caloIso' )
-process.patElectrons.userData.userFunctionLabels.append( 'trackIso * caloIso' )
-process.patMuons.userData.userFunctionLabels.append( 'trackIso * caloIso' )
-
-# Let it run
-process.p = cms.Path(
-    getattr(process,"patPF2PATSequence"+postfix)
-)
-if not postfix=="":
-    process.p += process.patDefaultSequence
-
-
-
-
-# Add PF2PAT output to the created file
-from PhysicsTools.PatAlgos.patEventContent_cff import patEventContentNoCleaning
-#process.load("CommonTools.ParticleFlow.PF2PAT_EventContent_cff")
-#process.out.outputCommands =  cms.untracked.vstring('drop *')
-process.out.outputCommands = cms.untracked.vstring('drop *',
-                                                   *patEventContentNoCleaning )
-
-## ------------------------------------------------------
-#  In addition you usually want to change the following
-#  parameters:
-## ------------------------------------------------------
-#
-#   process.GlobalTag.globaltag =  ...    ##  (according to https://twiki.cern.ch/twiki/bin/view/CMS/SWGuideFrontierConditions)
-#                                         ##
-from PhysicsTools.PatAlgos.patInputFiles_cff import filesRelValProdTTbarAODSIM
-process.source.fileNames = filesRelValProdTTbarAODSIM
-#                                         ##
-process.maxEvents.input = 10
-#                                         ##
-#   process.out.outputCommands = [ ... ]  ##  (e.g. taken from PhysicsTools/PatAlgos/python/patEventContent_cff.py)
-#                                         ##
-process.out.fileName = 'patTuple_userData.root'
-#                                         ##
-#   process.options.wantSummary = False   ##  (to suppress the long output at the end of the job)
diff --git a/PhysicsTools/PatAlgos/test/private/PATUserDataTestModule.cc b/PhysicsTools/PatAlgos/test/private/PATUserDataTestModule.cc
deleted file mode 100644
index 6f495b2..0000000
--- a/PhysicsTools/PatAlgos/test/private/PATUserDataTestModule.cc
+++ /dev/null
@@ -1,216 +0,0 @@
-// -*- C++ -*-
-//
-// Package:    PatAlgos
-// Class:      PATUserDataTestModule
-// 
-/**\class PATUserDataTestModule PATUserDataTestModule.cc PhysicsTools/PatAlgos/test/PATUserDataTestModule.cc
-
- Description: Test module for UserData in PAT
-
- Implementation:
- 
- this analyzer shows how to loop over PAT output. 
-*/
-//
-// Original Author:  Freya Blekman
-//         Created:  Mon Apr 21 10:03:50 CEST 2008
-// $Id: PATUserDataTestModule.cc,v 1.4 2010/02/20 21:00:31 wmtan Exp $
-//
-//
-
-
-// system include files
-#include <memory>
-
-// user include files
-#include "FWCore/Framework/interface/Frameworkfwd.h"
-#include "FWCore/Framework/interface/EDProducer.h"
-
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-
-#include "DataFormats/PatCandidates/interface/Muon.h"
-
-#include "DataFormats/Common/interface/View.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "DataFormats/Common/interface/OwnVector.h"
-
-#include <string>
-
-// BEGIN CRAZY WORKAROUND
-namespace edm { using ::std::advance; }
-// END CRAZY WORKAROUND
-/*  Exmplanation of  the above crazy workaround:
-    1) edm::Ptr uses 'advance' free function to locate a given item within a collection
-    2) 'advance' is defined in  the std::namespace for std containers (e.g. vector)
-       http://www.sgi.com/tech/stl/advance.html
-    3) In edm::Ptr sources, we use 'advance'  without namespace prefix 
-       http://cmslxr.fnal.gov/lxr/source/DataFormats/Common/interface/Ptr.h?v=CMSSW_2_1_10#214
-    4) This normally work because the container is std:: so the free function is resolved in the
-       correct namespace (don't ask me why or how it works; Ask Marc, Bill or read C++ standards)
-    5) The hack 'namespace edm { using ::std::advance; }' imports std::advance into edm namespace,
-       so that it works. Apparently the default implementation of std::advance is ok also for the
-       iterator of the OwnVector
-    6) Anyway, this should be solved upstream in OwnVector.h
-
-            gpetruc
-*/
-
-//
-// class decleration
-//
-
-class PATUserDataTestModule : public edm::EDProducer {
-   public:
-      explicit PATUserDataTestModule(const edm::ParameterSet&);
-      ~PATUserDataTestModule();
-
-
-   private:
-      virtual void produce(edm::Event&, const edm::EventSetup&);
-
-      // ----------member data ---------------------------
-      edm::InputTag muons_;
-      std::string   label_;
-      enum TestMode { TestRead, TestWrite, TestExternal };
-      TestMode mode_;
-};
-
-//
-// constructors and destructor
-//
-PATUserDataTestModule::PATUserDataTestModule(const edm::ParameterSet& iConfig):
-  muons_(iConfig.getParameter<edm::InputTag>("muons")),
-  label_(iConfig.existsAs<std::string>("label") ? iConfig.getParameter<std::string>("label") : ""),
-  mode_( iConfig.getParameter<std::string>("mode") == "write" ? TestWrite : 
-        (iConfig.getParameter<std::string>("mode") == "read"  ? TestRead  : 
-         TestExternal
-        ))
-
-{
-  if (mode_ != TestExternal) {
-      produces<std::vector<pat::Muon> >();
-  } else {
-      produces<edm::ValueMap<int> >(label_);
-      produces<edm::ValueMap<float> >();
-      produces<edm::OwnVector<pat::UserData> >();
-      produces<edm::ValueMap<edm::Ptr<pat::UserData> > >();
-  }
-}
-
-
-PATUserDataTestModule::~PATUserDataTestModule()
-{
-}
-
-// ------------ method called to for each event  ------------
-void
-PATUserDataTestModule::produce(edm::Event& iEvent, const edm::EventSetup& iSetup)
-{
-   using namespace edm;
-
-   // I need to define a type for which we don't have a dictionary in CMSSW. I hope this is crazy enough.
-   typedef std::pair<std::map<std::string,pat::Muon>, std::vector<math::XYZVector> > CrazyDataType;
-
-   if (mode_ != TestExternal) {
-       edm::Handle<edm::View<pat::Muon> > muons;
-       iEvent.getByLabel(muons_,muons);
-
-       std::auto_ptr<std::vector<pat::Muon> > output(new std::vector<pat::Muon>());
-
-       for (edm::View<pat::Muon>::const_iterator muon = muons->begin(), end = muons->end(); muon != end; ++muon) {
-           if (mode_ == TestWrite) {
-               pat::Muon myMuon = *muon; // copy
-               myMuon.addUserInt("answer", 42);
-               myMuon.addUserFloat("pi", 3.14);
-               myMuon.addUserData("half p4", 0.5*muon->p4());
-
-               //// This shoud throw an exception because we don't have the wrapper type
-               //myMuon.addUserData("self", *muon);
-               //// This should throw an exception because we don't have the dictionary (I hope)
-               // myMuon.addUserData("crazy", CrazyDataType());
-               //// These instead should not throw an exception as long as they don't get saved on disk
-               // myMuon.addUserData("tmp self", *muon, true);
-               // myMuon.addUserData("tmp crazy", CrazyDataType(), true);
-
-               output->push_back(myMuon);
-           } else {
-               std::cout << "Muon #" << (muon - muons->begin()) << ":" << std::endl;
-               std::cout << "\tanswer   = " << muon->userInt("answer") << std::endl;
-               std::cout << "\tanswer:il= " << muon->userInt("answer:il") << std::endl;
-               std::cout << "\tpi       = " << muon->userFloat("pi") << std::endl;
-               std::cout << "\tmiss int = " << muon->userInt("missing int") << std::endl;
-               std::cout << "\tmiss flt = " << muon->userFloat("missing flt") << std::endl;
-               std::cout << "\t# u d    = " << muon->userDataNames().size() << std::endl;
-               std::cout << "\tud nam[0]= " << muon->userDataNames()[0] << std::endl;
-               std::cout << "\thas p4/2 = " << muon->hasUserData("half p4") << std::endl;
-               if (muon->hasUserData("half p4")) {
-                   std::cout << "\ttyp p4/2 = " << muon->userDataObjectType("half p4") << std::endl;
-                   std::cout << "\tval p4/2 = " << (*muon->userData<reco::Particle::LorentzVector>("half p4")) << "  == " << (0.5*muon->p4()) << std::endl;
-               }
-               if (muon->hasUserData("tmp self")) {
-                   std::cout << "\tself.pt  = " << muon->userData<pat::Muon>("tmp self")->pt() << "  == " << muon->pt() << std::endl;
-               }
-               if (muon->hasUserData("tmp crazy")) {
-                   std::cout << "\tcrazy.siz= " << muon->userData<CrazyDataType>("tmp crazy")->second.size() << "  == 0 " << std::endl;
-               }
-               if (muon->hasUserData("halfP4")) {
-                   std::cout << "\ttyp P4/2 = " << muon->userDataObjectType("halfP4") << std::endl;
-                   std::cout << "\tval P4/2 = " << (*muon->userData<reco::Particle::LorentzVector>("halfP4")) << "  == " << (0.5*muon->p4()) << std::endl;
-               }
-           }
-       }
-       iEvent.put(output);
-   } else { 
-       using namespace std;
-       Handle<View<reco::Muon> > recoMuons;
-       iEvent.getByLabel(muons_, recoMuons);
-       std::cout << "Got " << recoMuons->size() << " muons" << std::endl;
-
-       vector<int> ints(recoMuons->size(), 42);
-       auto_ptr<ValueMap<int> > answers(new ValueMap<int>());
-       ValueMap<int>::Filler intfiller(*answers);
-       intfiller.insert(recoMuons, ints.begin(), ints.end());
-       intfiller.fill();
-       iEvent.put(answers, label_);
-       std::cout << "Filled in the answer" << std::endl;
-
-       vector<float> floats(recoMuons->size(), 3.14);
-       auto_ptr<ValueMap<float> > pis(new ValueMap<float>());
-       ValueMap<float>::Filler floatfiller(*pis);
-       floatfiller.insert(recoMuons, floats.begin(), floats.end());
-       floatfiller.fill();
-       iEvent.put(pis);
-       std::cout << "Wrote useless floats into the event" << std::endl;
-
-       auto_ptr<OwnVector<pat::UserData> > halfp4s(new OwnVector<pat::UserData>());
-       for (size_t i = 0; i < recoMuons->size(); ++i) {
-            halfp4s->push_back( pat::UserData::make( 0.5 * (*recoMuons)[i].p4() ) );
-       }
-       OrphanHandle<OwnVector<pat::UserData> > handle = iEvent.put(halfp4s);
-       std::cout << "Wrote OwnVector of useless objects into the event" << std::endl;
-       vector<Ptr<pat::UserData> > halfp4sPtr;
-       for (size_t i = 0; i < recoMuons->size(); ++i) {
-            // It is crucial to use the OrphanHandle here and not a RefProd from GetRefBeforePut
-            halfp4sPtr.push_back(Ptr<pat::UserData>(handle, i));
-       }
-       std::cout << "   Made edm::Ptr<> to those useless objects" << std::endl;
-       auto_ptr<ValueMap<Ptr<pat::UserData> > > vmhalfp4s(new ValueMap<Ptr<pat::UserData> >());
-       ValueMap<Ptr<pat::UserData> >::Filler filler(*vmhalfp4s);
-       filler.insert(recoMuons, halfp4sPtr.begin(), halfp4sPtr.end());
-       filler.fill();
-       std::cout << "   Filled the ValueMap of edm::Ptr<> to those useless objects" << std::endl;
-       iEvent.put(vmhalfp4s);
-       std::cout << "   Wrote the ValueMap of edm::Ptr<> to those useless objects" << std::endl;
-
-       std::cout << "So long, and thanks for all the muons.\n" << std::endl;
-   }
-
-}
-
-//define this as a plug-in
-DEFINE_FWK_MODULE(PATUserDataTestModule);
diff --git a/PhysicsTools/PatAlgos/test/private/TestEventHypothesisReader.cc b/PhysicsTools/PatAlgos/test/private/TestEventHypothesisReader.cc
deleted file mode 100644
index 206063d..0000000
--- a/PhysicsTools/PatAlgos/test/private/TestEventHypothesisReader.cc
+++ /dev/null
@@ -1,109 +0,0 @@
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-#include "FWCore/Framework/interface/EDAnalyzer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "DataFormats/PatCandidates/interface/EventHypothesis.h"
-#include "DataFormats/PatCandidates/interface/EventHypothesisLooper.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "DataFormats/Math/interface/deltaR.h"
-
-#include "DataFormats/JetReco/interface/CaloJet.h"
-#include "DataFormats/MuonReco/interface/Muon.h"
-
-class TestEventHypothesisReader : public edm::EDAnalyzer {
-    public:
-        TestEventHypothesisReader(const edm::ParameterSet &iConfig) ;
-        virtual void analyze( const edm::Event &iEvent, const edm::EventSetup &iSetup) ;
-        void runTests( const pat::EventHypothesis &h) ;
-    private:
-        edm::InputTag events_;
-};
-
-
-
-TestEventHypothesisReader::TestEventHypothesisReader(const edm::ParameterSet &iConfig) :
-    events_(iConfig.getParameter<edm::InputTag>("events"))
-{
-}
-
-void
-TestEventHypothesisReader::runTests( const pat::EventHypothesis &h) {
-    using namespace std;
-    using namespace pat::eventhypothesis;
-    cout << "Test 1: Print the muon " << h["mu"]->pt() << endl;
-
-    for (size_t i = 0; i < h.count() - 2; ++i) {
-        cout << "Test 2." << (i+1) << ": Getting of the other jets: " << h.get("other jet",i)->et() << endl;
-    }
-
-    cout << "Test 3: count: " << (h.count() - 2) << " vs " << h.count("other jet") << endl;
-
-    cout << "Test 4: regexp count: " << (h.count() - 1) << " vs " << h.count(".*jet") << endl;
-
-    cout << "Test 5.0: all with muon: " << h.all("mu").size() << endl;
-    cout << "Test 5.1: all with muon: " << h.all("mu").front()->pt() << endl;
-    cout << "Test 5.2: all with other jets: " << h.all("other jet").size() << endl;
-    cout << "Test 5.3: all with regex: " << h.all(".*jet").size() << endl;
-
-    cout << "Test 6.0: get as : " << h.getAs<reco::CaloJet>("nearest jet")->maxEInHadTowers() << endl;
-   
-    cout << "Loopers" << endl;
-    cout << "Test 7.0: simple looper on all" << endl;
-    for (CandLooper jet = h.loop(); jet; ++jet) {
-        cout << "\titem " << jet.index() << ", role " << jet.role() << ": " << jet->et() << endl;
-    }
-    cout << "Test 7.1: simple looper on jets" << endl;
-    for (CandLooper jet = h.loop(".*jet"); jet; ++jet) {
-        cout << "\titem " << jet.index() << ", role " << jet.role() << ": " << jet->et() << endl;
-    }
-    cout << "Test 7.2: loopAs on jets" << endl;
-    for (Looper<reco::CaloJet> jet = h.loopAs<reco::CaloJet>(".*jet"); jet; ++jet) {
-        cout << "\titem " << jet.index() << ", role " << jet.role() << ": " << jet->maxEInHadTowers() << endl;
-    }
-
-
-}
-
-
-
-void
-TestEventHypothesisReader::analyze(const edm::Event &iEvent, const edm::EventSetup &iSetup) {
-    using namespace edm; using namespace std;
-    using reco::Candidate; 
-    using reco::CandidatePtr;
-
-    Handle<vector<pat::EventHypothesis> > hyps;
-    iEvent.getByLabel(events_, hyps);
-
-    Handle<ValueMap<double> >  deltaRsH;
-    iEvent.getByLabel(InputTag(events_.label(), "deltaR"), deltaRsH);
-    const ValueMap<double> & deltaRs = *deltaRsH;
-    
-    for (size_t i = 0, n = hyps->size(); i < n; ++i) {
-        const pat::EventHypothesis &h = (*hyps)[i];
-
-        std::cout << "Hypothesis " << (i+1) << ": " << std::endl;
-        CandidatePtr  mu = h["mu"];
-        std::cout << "   muon : pt = " << mu->pt() << ", eta = " << mu->eta() << ", phi = " << mu->phi() << std::endl;
-        CandidatePtr jet = h["nearest jet"];
-        std::cout << "   n jet: pt = " << jet->pt() << ", eta = " << jet->eta() << ", phi = " << jet->phi() << std::endl;
-   
-        for (pat::EventHypothesis::CandLooper j2 = h.loop("other jet"); j2; ++j2) {
-            std::cout << "   0 jet: pt = " << j2->pt() << ", eta = " << j2->eta() << ", phi = " << j2->phi() << std::endl;
-        }
-
-        Ref< vector<pat::EventHypothesis> > key(hyps,i);
-        std::cout << "   deltaR: " << deltaRs[key] << "\n" << std::endl;
-
-        runTests( h );
-        
-    }
-
-    std::cout << "Found " << hyps->size() << " possible options" << "\n\n" << std::endl;
-
-}
-
-DEFINE_FWK_MODULE(TestEventHypothesisReader);
diff --git a/PhysicsTools/PatAlgos/test/private/TestEventHypothesisWriter.cc b/PhysicsTools/PatAlgos/test/private/TestEventHypothesisWriter.cc
deleted file mode 100644
index afc4e96..0000000
--- a/PhysicsTools/PatAlgos/test/private/TestEventHypothesisWriter.cc
+++ /dev/null
@@ -1,136 +0,0 @@
-#include "FWCore/Framework/interface/MakerMacros.h"
-
-#include "FWCore/Framework/interface/EDProducer.h"
-#include "FWCore/Framework/interface/Event.h"
-#include "FWCore/ParameterSet/interface/ParameterSet.h"
-#include "FWCore/Utilities/interface/InputTag.h"
-
-#include "DataFormats/PatCandidates/interface/EventHypothesis.h"
-#include "DataFormats/PatCandidates/interface/EventHypothesisLooper.h"
-#include "DataFormats/Common/interface/ValueMap.h"
-#include "DataFormats/Math/interface/deltaR.h"
-#include "DataFormats/MuonReco/interface/Muon.h"
-#include "DataFormats/TrackReco/interface/Track.h"
-#include "DataFormats/JetReco/interface/CaloJet.h"
-
-class TestEventHypothesisWriter : public edm::EDProducer {
-    public:
-        TestEventHypothesisWriter(const edm::ParameterSet &iConfig) ;
-        virtual void produce( edm::Event &iEvent, const edm::EventSetup &iSetup) ;
-        void runTests( const pat::EventHypothesis &h) ;
-    private:
-        edm::InputTag jets_, muons_;
-};
-
-
-
-TestEventHypothesisWriter::TestEventHypothesisWriter(const edm::ParameterSet &iConfig) :
-    jets_(iConfig.getParameter<edm::InputTag>("jets")),
-    muons_(iConfig.getParameter<edm::InputTag>("muons"))
-{
-    produces<std::vector<pat::EventHypothesis> >();
-    produces<edm::ValueMap<double> >("deltaR");
-}
-
-void
-TestEventHypothesisWriter::runTests( const pat::EventHypothesis &h) {
-    using namespace std;
-    using namespace pat::eventhypothesis;
-    cout << "Test 1: Print the muon " << h["mu"]->pt() << endl;
-
-    for (size_t i = 0; i < h.count() - 2; ++i) {
-        cout << "Test 2." << (i+1) << ": Getting of the other jets: " << h.get("other jet",i)->et() << endl;
-    }
-
-    cout << "Test 3: count: " << (h.count() - 2) << " vs " << h.count("other jet") << endl;
-
-    cout << "Test 4: regexp count: " << (h.count() - 1) << " vs " << h.count(".*jet") << endl;
-
-    cout << "Test 5.0: all with muon: " << h.all("mu").size() << endl;
-    cout << "Test 5.1: all with muon: " << h.all("mu").front()->pt() << endl;
-    cout << "Test 5.2: all with other jets: " << h.all("other jet").size() << endl;
-    cout << "Test 5.3: all with regex: " << h.all(".*jet").size() << endl;
-
-    cout << "Test 6.0: get as : " << h.getAs<reco::CaloJet>("nearest jet")->maxEInHadTowers() << endl;
-   
-    cout << "Loopers" << endl;
-    cout << "Test 7.0: simple looper on all" << endl;
-    for (CandLooper jet = h.loop(); jet; ++jet) {
-        cout << "\titem " << jet.index() << ", role " << jet.role() << ": " << jet->et() << endl;
-    }
-    cout << "Test 7.1: simple looper on jets" << endl;
-    for (CandLooper jet = h.loop(".*jet"); jet; ++jet) {
-        cout << "\titem " << jet.index() << ", role " << jet.role() << ": " << jet->et() << endl;
-    }
-    cout << "Test 7.2: loopAs on jets" << endl;
-    for (Looper<reco::CaloJet> jet = h.loopAs<reco::CaloJet>(".*jet"); jet; ++jet) {
-        cout << "\titem " << jet.index() << ", role " << jet.role() << ": " << jet->maxEInHadTowers() << endl;
-    }
-
-
-}
-
-void
-TestEventHypothesisWriter::produce(edm::Event &iEvent, const edm::EventSetup &iSetup) {
-    using namespace edm;
-    using namespace std;
-    using reco::Candidate; 
-    using reco::CandidatePtr;
-
-    auto_ptr<vector<pat::EventHypothesis> > hyps(new vector<pat::EventHypothesis>());;
-    vector<double>  deltaRs;
-    
-    Handle<View<Candidate> > hMu; 
-    iEvent.getByLabel(muons_, hMu);
-
-    Handle<View<Candidate> > hJet; 
-    iEvent.getByLabel(jets_, hJet);
-    
-    // fake analysis
-    for (size_t imu = 0, nmu = hMu->size(); imu < nmu; ++imu) {
-        pat::EventHypothesis h;
-        CandidatePtr mu = hMu->ptrAt(imu);
-        h.add(mu, "mu");
-        
-        int bestj = -1; double drmin = 99.0;
-        for (size_t ij = 0, nj = hJet->size(); ij < nj; ++ij) {
-            CandidatePtr jet = hJet->ptrAt(ij);
-            if (jet->et() < 10) break;
-            double dr = deltaR(*jet, *mu);
-            if (dr < drmin) {
-                bestj = ij; drmin = dr;
-            }
-        }
-        if (bestj == -1) continue;
-
-        h.add(hJet->ptrAt(bestj), "nearest jet");
-
-        for (size_t ij = 0, nj = hJet->size(); ij < nj; ++ij) {
-            if (ij == size_t(bestj)) continue;
-            CandidatePtr jet = hJet->ptrAt(ij);
-            if (jet->et() < 10) break;
-            h.add(jet, "other jet");
-        }
-        
-        // save hypothesis
-        deltaRs.push_back(drmin);
-
-        runTests(h);
-
-        hyps->push_back(h);
-    }
-
-    std::cout << "Found " << deltaRs.size() << " possible options" << std::endl;
-
-    // work done, save results
-    OrphanHandle<vector<pat::EventHypothesis> > handle = iEvent.put(hyps);
-    auto_ptr<ValueMap<double> > deltaRMap(new ValueMap<double>());
-    //if (deltaRs.size() > 0) {
-        ValueMap<double>::Filler filler(*deltaRMap);
-        filler.insert(handle, deltaRs.begin(), deltaRs.end());
-        filler.fill();
-    //}
-    iEvent.put(deltaRMap, "deltaR");
-}
-
-DEFINE_FWK_MODULE(TestEventHypothesisWriter);
diff --git a/PhysicsTools/PatAlgos/test/private/patLayer1_fromAOD-minimal.cfg.py b/PhysicsTools/PatAlgos/test/private/patLayer1_fromAOD-minimal.cfg.py
deleted file mode 100755
index 3c250eb..0000000
--- a/PhysicsTools/PatAlgos/test/private/patLayer1_fromAOD-minimal.cfg.py
+++ /dev/null
@@ -1,91 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-process = cms.Process("PAT")
-
-# initialize MessageLogger and output report
-process.load("FWCore.MessageLogger.MessageLogger_cfi")
-process.MessageLogger.cerr.threshold = 'INFO'
-process.MessageLogger.categories.append('PATLayer0Summary')
-process.MessageLogger.cerr.INFO = cms.untracked.PSet(
-    default          = cms.untracked.PSet( limit = cms.untracked.int32(0)  ),
-    PATLayer0Summary = cms.untracked.PSet( limit = cms.untracked.int32(-1) )
-)
-process.options   = cms.untracked.PSet( wantSummary = cms.untracked.bool(True) )
-
-# source
-process.source = cms.Source("PoolSource", 
-     fileNames = cms.untracked.vstring(
-        'file:/data/disk2/lowette/ttbar219.root'
-     )
-)
-process.maxEvents = cms.untracked.PSet( input = cms.untracked.int32(-1) )
-
-process.load("Configuration.StandardSequences.Geometry_cff")
-process.load("Configuration.StandardSequences.FrontierConditions_GlobalTag_cff")
-process.GlobalTag.globaltag = cms.string('STARTUP_V4::All')
-process.load("Configuration.StandardSequences.MagneticField_cff")
-
-# PAT Layer 0+1
-process.load("PhysicsTools.PatAlgos.patLayer0_cff")
-process.load("PhysicsTools.PatAlgos.patLayer1_cff")
-#process.content = cms.EDAnalyzer("EventContentAnalyzer")
-process.p = cms.Path(
-                process.patLayer0  
-                #+ process.content # uncomment to get a dump of the output after layer 0
-                + process.patLayer1  
-            )
-
-process.allLayer1Electrons.embedTrack = False
-process.allLayer1Electrons.embedGsfTrack = False
-process.allLayer1Electrons.embedSuperCluster = False
-process.allLayer1Electrons.addResolutions = False
-process.allLayer1Electrons.isolation = cms.PSet()
-process.allLayer1Electrons.isoDeposits = cms.PSet()
-process.allLayer1Electrons.addElectronID = False
-process.allLayer1Electrons.addTrigMatch = False
-process.allLayer1Electrons.addGenMatch = False
-process.allLayer1Muons.embedTrack = False
-process.allLayer1Muons.embedCombinedMuon = False
-process.allLayer1Muons.embedStandAloneMuon = False
-process.allLayer1Muons.isolation = cms.PSet()
-process.allLayer1Muons.isoDeposits = cms.PSet()
-process.allLayer1Muons.addResolutions = False
-process.allLayer1Muons.addTrigMatch = False
-process.allLayer1Muons.addGenMatch = False
-process.allLayer1Jets.embedCaloTowers = False
-process.allLayer1Jets.addJetCorrFactors = False
-process.allLayer1Jets.addResolutions = False
-process.allLayer1Jets.addBTagInfo = False
-process.allLayer1Jets.addAssociatedTracks = False
-process.allLayer1Jets.addJetCharge = False
-process.allLayer1Jets.addTrigMatch = False
-process.allLayer1Jets.addGenPartonMatch = False
-process.allLayer1Jets.addGenJetMatch = False
-process.allLayer1Jets.getJetMCFlavour = False
-process.allLayer1Photons.embedSuperCluster = False
-process.allLayer1Photons.isolation = cms.PSet()
-process.allLayer1Photons.isoDeposits = cms.PSet()
-process.allLayer1Photons.addPhotonID = False
-process.allLayer1Photons.addTrigMatch = False
-process.allLayer1Photons.addGenMatch = False
-process.allLayer1Taus.embedLeadTrack = False
-process.allLayer1Taus.embedSignalTracks = False
-process.allLayer1Taus.embedIsolationTracks = False
-process.allLayer1Taus.addResolutions = False
-process.allLayer1Taus.isolation = cms.PSet()
-process.allLayer1Taus.isoDeposits = cms.PSet()
-process.allLayer1Taus.addTrigMatch = False
-process.allLayer1Taus.addGenMatch = False
-
-# Output module configuration
-process.out = cms.OutputModule("PoolOutputModule",
-    fileName = cms.untracked.string('PATLayer1_Output.fromAOD-minimal.root'),
-    # save only events passing the full path
-    SelectEvents   = cms.untracked.PSet( SelectEvents = cms.vstring('p') ),
-    outputCommands = cms.untracked.vstring('drop *')
-)
-process.outpath = cms.EndPath(process.out)
-# save PAT Layer 1 output
-process.load("PhysicsTools.PatAlgos.patLayer1_EventContent_cff")
-process.out.outputCommands.extend(process.patLayer1EventContent.outputCommands)
-
diff --git a/PhysicsTools/PatAlgos/test/private/refTestAnalyzer_cfg.py b/PhysicsTools/PatAlgos/test/private/refTestAnalyzer_cfg.py
deleted file mode 100644
index 351ace4..0000000
--- a/PhysicsTools/PatAlgos/test/private/refTestAnalyzer_cfg.py
+++ /dev/null
@@ -1,49 +0,0 @@
-# The following comments couldn't be translated into the new config version:
-
-# discard jets that match with clean electrons
-import FWCore.ParameterSet.Config as cms
-
-process = cms.Process("TestTag2Map")
-process.source = cms.Source("PoolSource",
-    fileNames = cms.untracked.vstring('file:in.root')
-)
-
-process.maxEvents = cms.untracked.PSet(
-    input = cms.untracked.int32(20)
-)
-process.cleanElectrons = cms.EDFilter("PATElectronCleaner",
-    removeDuplicates = cms.bool(True),
-    electronSource = cms.InputTag("pixelMatchGsfElectrons")
-)
-
-process.cleanJets = cms.EDFilter("PATCaloJetCleaner",
-    removeOverlaps = cms.VPSet(cms.PSet(
-        deltaR = cms.double(0.3),
-        collection = cms.InputTag("cleanElectrons")
-    )),
-    jetSource = cms.InputTag("iterativeCone5CaloJets")
-)
-
-process.convBtag = cms.EDFilter("JetTagToValueMapFloat",
-    src = cms.InputTag("iterativeCone5CaloJets"),
-    tags = cms.InputTag("jetProbabilityJetTags")
-)
-
-process.skimBtag = cms.EDFilter("CandValueMapSkimmerFloat",
-    association = cms.InputTag("convBtag","jetProbabilityJetTags"),
-    collection = cms.InputTag("cleanJets"),
-    backrefs = cms.InputTag("cleanJets")
-)
-
-process.refTestAnalyzer = cms.EDAnalyzer("RefTestAnalyzer",
-    jets1 = cms.InputTag("cleanJets"),
-    jets0 = cms.InputTag("iterativeCone5CaloJets"),
-    btag = cms.InputTag("convBtag","jetProbabilityJetTags"),
-    newbtag = cms.InputTag("skimBtag"),
-    backmap = cms.InputTag("cleanJets"),
-    jtag = cms.InputTag("jetProbabilityJetTags")
-)
-
-process.p = cms.Path(process.cleanElectrons*process.cleanJets*process.convBtag*process.skimBtag*process.refTestAnalyzer)
-
-
diff --git a/PhysicsTools/PatAlgos/test/private/testCleaners_cfg.py b/PhysicsTools/PatAlgos/test/private/testCleaners_cfg.py
deleted file mode 100644
index 1e29e20..0000000
--- a/PhysicsTools/PatAlgos/test/private/testCleaners_cfg.py
+++ /dev/null
@@ -1,43 +0,0 @@
-# The following comments couldn't be translated into the new config version:
-
-# discard jets that match with clean electrons
-import FWCore.ParameterSet.Config as cms
-
-process = cms.Process("TestCleaners")
-process.maxEvents = cms.untracked.PSet(
-    input = cms.untracked.int32(3)
-)
-process.source = cms.Source("PoolSource",
-    skipEvents = cms.untracked.uint32(182),
-    fileNames = cms.untracked.vstring('file:in.root')
-)
-
-process.cleanMuons = cms.EDFilter("PATMuonCleaner",
-    muonSource = cms.InputTag("muons")
-)
-
-process.cleanElectrons = cms.EDFilter("PATElectronCleaner",
-    removeDuplicates = cms.bool(True),
-    electronSource = cms.InputTag("pixelMatchGsfElectrons")
-)
-
-process.cleanJets = cms.EDFilter("PATCaloJetCleaner",
-    removeOverlaps = cms.VPSet(cms.PSet(
-        deltaR = cms.double(0.3),
-        collection = cms.InputTag("cleanElectrons")
-    )),
-    jetSource = cms.InputTag("iterativeCone5CaloJets")
-)
-
-process.out = cms.OutputModule("PoolOutputModule",
-    outputCommands = cms.untracked.vstring('drop *', 
-        'keep recoCaloJets_*_*_*', 
-        'keep pixelMatchGsfElectrons_*_*_*', 
-        'keep *_*_*_TestCleaners'),
-    fileName = cms.untracked.string('/tmp/gpetrucc/out.root')
-)
-
-process.p = cms.Path(process.cleanElectrons*process.cleanJets)
-process.e = cms.EndPath(process.out)
-
-
diff --git a/PhysicsTools/PatAlgos/test/private/testEventHypothesisReader_cfg.py b/PhysicsTools/PatAlgos/test/private/testEventHypothesisReader_cfg.py
deleted file mode 100644
index 5a4901c..0000000
--- a/PhysicsTools/PatAlgos/test/private/testEventHypothesisReader_cfg.py
+++ /dev/null
@@ -1,17 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-process = cms.Process("TestEHR")
-process.source = cms.Source("PoolSource",
-    fileNames = cms.untracked.vstring('file:eh.root')
-)
-
-process.maxEvents = cms.untracked.PSet(
-    input = cms.untracked.int32(-1)
-)
-process.read = cms.EDFilter("TestEventHypothesisReader",
-    events = cms.InputTag("sols")
-)
-
-process.p = cms.Path(process.read)
-
-
diff --git a/PhysicsTools/PatAlgos/test/private/testEventHypothesisWriter_cfg.py b/PhysicsTools/PatAlgos/test/private/testEventHypothesisWriter_cfg.py
deleted file mode 100644
index b219149..0000000
--- a/PhysicsTools/PatAlgos/test/private/testEventHypothesisWriter_cfg.py
+++ /dev/null
@@ -1,27 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-process = cms.Process("TestEHW")
-process.source = cms.Source("PoolSource",
-    fileNames = cms.untracked.vstring('file:in.root')
-)
-
-process.maxEvents = cms.untracked.PSet(
-    input = cms.untracked.int32(50)
-)
-process.sols = cms.EDFilter("TestEventHypothesisWriter",
-    jets = cms.InputTag("iterativeCone5CaloJets"),
-    muons = cms.InputTag("pixelMatchGsfElectrons")
-)
-
-process.out = cms.OutputModule("PoolOutputModule",
-    outputCommands = cms.untracked.vstring('drop *', 
-        'keep *_iterativeCone5CaloJets_*_*', 
-        'keep *_pixelMatchGsfElectrons_*_*', 
-        'keep *_*_*_TestEHW'),
-    fileName = cms.untracked.string('eh.root')
-)
-
-process.p = cms.Path(process.sols)
-process.e = cms.EndPath(process.out)
-
-
diff --git a/PhysicsTools/PatAlgos/test/private/testPATUserData.py b/PhysicsTools/PatAlgos/test/private/testPATUserData.py
deleted file mode 100644
index b9091c9..0000000
--- a/PhysicsTools/PatAlgos/test/private/testPATUserData.py
+++ /dev/null
@@ -1,31 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-process = cms.Process("TestUserData")
-
-process.source = cms.Source("PoolSource",
-    fileNames = cms.untracked.vstring('file:patLayer1.root')
-)
-
-process.MessageLogger = cms.Service("MessageLogger")
-
-process.testWrite = cms.EDProducer("PATUserDataTestModule",
-    mode  = cms.string("write"),
-    muons = cms.InputTag("selectedLayer1Muons"),
-)
-
-process.testRead = cms.EDProducer("PATUserDataTestModule",
-    mode  = cms.string("read"),
-    muons = cms.InputTag("testWrite"),
-)
-
-
-process.p = cms.Path(
-    process.testWrite +
-    process.testRead
-)
-
-process.out = cms.OutputModule("PoolOutputModule",
-    fileName = cms.untracked.string('layer1muons_withUserData.root'),
-    outputCommands = cms.untracked.vstring("drop *", "keep patMuons_*_*_*"),
-)
-process.out_step = cms.EndPath(process.out)
diff --git a/PhysicsTools/PatAlgos/test/private/testPATUserDataExternal.py b/PhysicsTools/PatAlgos/test/private/testPATUserDataExternal.py
deleted file mode 100644
index 7092d81..0000000
--- a/PhysicsTools/PatAlgos/test/private/testPATUserDataExternal.py
+++ /dev/null
@@ -1,73 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-process = cms.Process("PAT")
-
-# initialize MessageLogger and output report
-process.load("FWCore.MessageLogger.MessageLogger_cfi")
-process.MessageLogger.cerr.threshold = 'INFO'
-process.MessageLogger.categories.append('PATLayer0Summary')
-process.MessageLogger.cerr.INFO = cms.untracked.PSet(
-    default          = cms.untracked.PSet( limit = cms.untracked.int32(0)  ),
-    PATLayer0Summary = cms.untracked.PSet( limit = cms.untracked.int32(-1) )
-)
-process.options   = cms.untracked.PSet( wantSummary = cms.untracked.bool(True) )
-
-# source
-process.source = cms.Source("PoolSource", 
-     fileNames = cms.untracked.vstring('file:/afs/cern.ch/cms/PRS/top/cmssw-data/relval200-for-pat-testing/FullSimTTBar-2_2_X_2008-11-03-STARTUP_V7-AODSIM.100.root')
-)
-process.maxEvents = cms.untracked.PSet( input = cms.untracked.int32(10) )
-
-process.load("Configuration.StandardSequences.Geometry_cff")
-process.load("Configuration.StandardSequences.FrontierConditions_GlobalTag_cff")
-process.GlobalTag.globaltag = cms.string('STARTUP_V4::All')
-process.load("Configuration.StandardSequences.MagneticField_cff")
-
-# PAT Layer 0+1
-process.load("PhysicsTools.PatAlgos.patLayer0_cff")
-process.load("PhysicsTools.PatAlgos.patLayer1_cff")
-
-process.answer = cms.EDProducer("PATUserDataTestModule", # each of this will produce all
-    mode  = cms.string("external"),                      # but I don't care
-    muons = cms.InputTag("allLayer0Muons"),
-    label = cms.string("il"),                            # use instance label 'il' for the ints
-)
-process.pi = cms.EDProducer("PATUserDataTestModule",
-    mode  = cms.string("external"),
-    muons = cms.InputTag("allLayer0Muons"),
-)
-process.halfP4 = cms.EDProducer("PATUserDataTestModule",
-    mode  = cms.string("external"),
-    muons = cms.InputTag("allLayer0Muons"),
-)
-process.allLayer1Muons.userData.userInts.src    = cms.VInputTag(cms.InputTag("answer","il"))
-process.allLayer1Muons.userData.userFloats.src  = cms.VInputTag(cms.InputTag("pi"))
-process.allLayer1Muons.userData.userClasses.src = cms.VInputTag(cms.InputTag("halfP4"))
-process.testRead = cms.EDProducer("PATUserDataTestModule",
-    mode  = cms.string("read"),
-    muons = cms.InputTag("selectedLayer1Muons"),
-)
-
-
-
-process.content = cms.EDAnalyzer("EventContentAnalyzer")
-process.p = cms.Path(
-                process.patLayer0  
-                + process.answer * process.pi * process.halfP4
-                #+ process.content # uncomment to get a dump of the output after layer 0
-                + process.patLayer1  
-                + process.testRead
-            )
-
-# Output module configuration
-process.out = cms.OutputModule("PoolOutputModule",
-    fileName = cms.untracked.string('PATLayer1_Output.fromAOD_full.root'),
-    # save only events passing the full path
-    SelectEvents   = cms.untracked.PSet( SelectEvents = cms.vstring('p') ),
-    outputCommands = cms.untracked.vstring('drop *')
-)
-process.outpath = cms.EndPath(process.out)
-# save PAT Layer 1 output
-process.load("PhysicsTools.PatAlgos.patLayer1_EventContent_cff")
-process.out.outputCommands.extend(process.patLayer1EventContent.outputCommands)
-
diff --git a/PhysicsTools/PatAlgos/test/private/testPATUserDataRead.py b/PhysicsTools/PatAlgos/test/private/testPATUserDataRead.py
deleted file mode 100644
index 55ab1e9..0000000
--- a/PhysicsTools/PatAlgos/test/private/testPATUserDataRead.py
+++ /dev/null
@@ -1,22 +0,0 @@
-import FWCore.ParameterSet.Config as cms
-
-process = cms.Process("TestUserDataRead")
-
-process.source = cms.Source("PoolSource",
-    fileNames = cms.untracked.vstring('file:layer1muons_withUserData.root')
-)
-
-process.MessageLogger = cms.Service("MessageLogger")
-
-process.testRead = cms.EDProducer("PATUserDataTestModule",
-    mode  = cms.string("read"),
-    muons = cms.InputTag("testWrite"),
-)
-
-##  Use the two lines below to test the output of L1 with embedded external user data
-#process.source.fileNames = cms.untracked.vstring('file:PATLayer1_Output.fromAOD_full.root');
-#process.testRead.muons = cms.InputTag("selectedLayer1Muons")
-
-process.p = cms.Path(
-    process.testRead
-)
diff --git a/PhysicsTools/PatAlgos/test/runAsyncTests.pl b/PhysicsTools/PatAlgos/test/runAsyncTests.pl
deleted file mode 100755
index f9a6684..0000000
--- a/PhysicsTools/PatAlgos/test/runAsyncTests.pl
+++ /dev/null
@@ -1,212 +0,0 @@
-#!/usr/bin/env perl
-use warnings;
-use strict;
-use threads;
-use threads::shared;
-
-my $dir = $ENV{'CMSSW_BASE'} . "/src/PhysicsTools/PatAlgos/test";
-chdir $dir or die "Can't chdir to $dir.\n Check that CMSSW_BASE variable is set correcly, and that you have checked out PhysicsTools/PatAlgos.\n";
-
-my %done   :shared = ();
-my $fake   :shared = 0;
-my $repdef :shared = "";
-
-use Getopt::Long;
-my ($help,$base,$one,$extra,$all,$shy,$obj);
-my @summary :shared;
-GetOptions( 'h|?|help' => \$help, 
-            'n|dry-run' => \$fake,
-            '1|one' => \$one,
-            'b|base' => \$base,
-            'o|obj' => \$obj,
-            'a|all' => \$all,
-            'e|extra' => \$extra,
-            's|summary=s' => \@summary,
-            'q|quiet' => \$shy);
-@summary = split(/,/, join(',',@summary));
-if ($help) {
-    my $name = `basename $0`; chomp $name;
-    print "Usage: perl $name [-n|--dry-run] [cfg.pys]\n" .
-          "   -n or --dry-run: just read the output, don't run cmsRun\n".
-          "   -h or --help:    print this help\n".
-          "   -1 or --one:     add patLayer1_fromAOD_full to the jobs to run\n".   
-          "   -b or --base:    add base standard PAT config files to the jobs to run\n".   
-          "   -o or --obj:     add PAT config files for single physics objecs to the jobs to run\n".   
-          "   -e or --extra:   add the extra standard PAT config files to the jobs to run (that is, those not in base)\n".   
-          "   -a or --all:     add all standard PAT config files to the jobs to run\n". 
-          "   -s or --summary: print summary table of objects (argument can be 'aod', 'allLayer1', 'selectedLayer1', ...)\n".
-          "   -q or --quiet:   print summary tables only if there are warnings/errors in that table.\n";
-    exit(0);
-}
-if ($fake) {
-    print "=== NOT ACTUALLLY RUNNING cmsRun, JUST READING OUTPUT LOGS ===\n";
-}
-
-my @CFGs = map({$_ =~ /\.py$|\*$/ ? $_ : "*$_*"}   @ARGV);
-
-
-my @anyCFGs    = glob("pat*[._]cfg.py");
-my @baseCFGs   = grep($_ =~ /fromAOD_(full|fast|noLayer1Cleaning)|fromScratch_fast/, @anyCFGs);
-my @objCFGs   = grep($_ =~ /fromAOD_(electron|muon|tau|photon|met|jet_)/, @anyCFGs);
-my @extraCFGs  = grep($_ !~ /fromAOD_(full|fast|noLayer1Cleaning|electron|muon|tau|photon|jet_)|fromScratch_fast/, @anyCFGs);
-if ($one )  { push @CFGs, grep(m/fromAOD_full/, @anyCFGs);  }
-if ($base ) { push @CFGs, @baseCFGs;  }
-if ($obj )  { push @CFGs, @objCFGs;  }
-if ($all  ) { push @CFGs, @anyCFGs;   }
-if ($extra) { push @CFGs, @extraCFGs; }
-if (@CFGs) {
-    #pass through a hash, to remove duplicates
-    my %allCFGs = ();
-    foreach my $cfg (@CFGs) { 
-        foreach my $cfgfile (grep(/cfg\.py$/, glob($cfg))) { $allCFGs{$cfgfile} = 1; }
-    }
-    @CFGs = sort(keys(%allCFGs));
-} else {
-    print STDERR "Please specify a cfg, or use --one, --base, --all, --extra to select the standard ones\n"; exit(0);
-}
-
-print "Will run " . scalar(@CFGs) . " config files: " . join(' ', @CFGs) . "\n\n";
-
-foreach my $cfg (@CFGs) { 
-    unless (-f $cfg) {  die "Config file $cfg does not exist in $dir\n"; } 
-}
-
-sub cmsRun {
-    my ($f, $o) = ($_[0], $_[1]);
-    unless ($fake) {
-        system("sh -c 'cmsRun $f > $o 2>&1 '");
-    } else {
-        #system("sh -c 'sleep ". int(rand(5)+2) ."'");
-        system("sh -c 'sleep 1'");
-    }
-    $done{$f} = time();
-}
-
-my %info = ();
-
-my @txt = ("Jobs starting:");
-foreach my $f (@CFGs) {
-    my $o = $f; $o =~ s/[\._]cfg\.py$/.log/;
-
-    my $max = -1;
-    open CFG, $f;
-    foreach(<CFG>) { 
-        m/maxEvents\s*=\s*cms\.untracked\.PSet/ and $max = 0;
-        if ($max == 0) { m/input\s*=\s*cms\.untracked\.int32\(\s*(\d+)\s*\)/ and $max = $1; }
-    }
-    close CFG;
-
-    push @txt, "   \e[32;1m$f\e[37;0m: starting (on $max events total)";
-    $info{$f} = { 'out' => $o, 'start' => time(), 'max'=>$max };
-    my $thr = threads->create(\&cmsRun, $f, $o);
-}
-print join("\n", @txt), "\n";
-
-sub printDone {
-    my $f = shift(@_);
-    my $lines = 0; my $last = 0;
-    my ($excep, $exbody) = (0,"");
-    open LOG, $info{$f}->{'out'};
-    while (<LOG>) { 
-        $lines++; 
-        m/Begin processing the (\d+)\S* record\./ and $last = $1;
-        if (m/---- (.*?) BEGIN/) {
-            my $exname = $1;
-            $excep++; 
-            if ($excep == 1) { $exbody .= "\t" . $_; }
-            while ($_ = <LOG>) { 
-                $lines++; 
-                if ($excep == 1) { $exbody .= "\t" . $_; }
-                last if (m/---- $exname END/);
-            }
-        }
-    };
-    close LOG;
-
-    $info{$f}->{'last'}  = $last;
-    $info{$f}->{'lines'} = $lines;
-    $info{$f}->{'excep'} = $excep;
-    $info{$f}->{'exbody'}= $exbody;
-    return "\e[32;1m$f\e[37;0m: \e[;;1mdone\e[m events " . $info{$f}->{'last'} . "/" . $info{$f}->{'max'} .
-          ", total time " . ($done{$f} - $info{$f}->{'start'}) . "s, " .
-          $info{$f}->{'lines'} . " output lines, " .
-          ($info{$f}->{'excep'} ? "\e[1;31m" . $info{$f}->{'excep'} . " exceptions\e[0m" : "\e[32mno exceptions\e[0m" );
-}
-
-sub printRunning {
-    my $f = shift(@_);
-    my $lines = 0; my $last = 0;
-    my ($excep, $exbody) = (0,"");
-    open LOG, $info{$f}->{'out'};
-    while (<LOG>) { 
-        $lines++; 
-        m/Begin processing the (\d+)\S* record\./ and $last = $1;
-        if (m/---- (.*?) BEGIN/) {
-            my $exname = $1;
-            $excep++; 
-            if ($excep == 1) { $exbody .= "\t" . $_; }
-            while ($_ = <LOG>) { 
-                $lines++; 
-                if ($excep == 1) { $exbody .= "\t" . $_; }
-                last if (m/---- $exname END/);
-            }
-        }
-    };
-    close LOG;
-
-    my $secs = time() - $info{$f}->{'start'};
-    $info{$f}->{'time'}  = $secs;
-    $info{$f}->{'last'}  = $last;
-    $info{$f}->{'lines'} = $lines;
-    $info{$f}->{'excep'} = $excep;
-    $info{$f}->{'exbody'}= $exbody;
-    return "\e[32;1m$f\e[37;0m: event $last/" . $info{$f}->{'max'} ." (time ${secs}s, ${lines} output lines, " . 
-        ($excep ? "\e[1;31m$excep exceptions\e[0m" : "\e[32mno exceptions yet\e[0m" ) . ")...";
-}
-
-while (scalar(keys(%done)) < scalar(@CFGs)) {
-    sleep 1;
-
-    foreach my $f (@txt) { print "\e[F\e[M"; };  @txt = ();
-
-    my @run = (); my @done = ();
-    foreach my $f (@CFGs) {
-        if (defined($done{$f}) and defined($info{$f}->{'last'})) {
-           push @done, "   " . printDone($f); 
-        } else {
-           push @run,  "   " . printRunning($f);
-        }
-    }
-    push @txt, ("Jobs running:", @run);
-    if (@done) { push @txt, ("Jobs done:", @done) };
-    push @txt, "";
-    print join("\n", @txt), "\n";
-}
-
-foreach my $f (@txt) { print "\e[F\e[M"; }
-
-print "All jobs done.\n";
-
-sub redIf($$) {
-    return ($_[1] ? "\e[1;31m E> " . $_[0] . "\e[0m" : "    ".$_[0]);
-}
-foreach my $f (@CFGs) {
-    print printDone ($f), "\n";
-    if ($info{$f}->{'excep'}) { print "\e[1;31m" . $info{$f}->{'exbody'} . "\e[0m"; }
-
-    open LOG, $info{$f}->{'out'}; my @log = <LOG>; close LOG;
-    my $log = join('',@log);
-    foreach my $table (@summary) {
-        if ($log =~ m/(^Summary Table\s+$table.*\n(^    .*\n)*)/m) {
-            my $info = $1;
-            $info =~ s/^    (.*present\s+\d+\s+\(\s*(\d+\.?\d*)\s*%\).*)$/redIf($1,$2 ne '100')/meg;
-            $info =~ s/^    (.*total\s+0\s.*)$/\e[1;31m E> $1\e[0m/mg;
-            if (!$shy or ($info =~ /\e\[1;31m E>/)) {
-                print "  ".$info; 
-            }
-        }
-    }
-    foreach my $l (grep(/TrigReport Events total =/, @log)) { print "  \e[1m$l\e[0m"; }
-
-    print "\n";
-}
diff --git a/PhysicsTools/PatAlgos/test/runtestPhysicsToolsPatAlgos.cpp b/PhysicsTools/PatAlgos/test/runtestPhysicsToolsPatAlgos.cpp
deleted file mode 100644
index b2991bd..0000000
--- a/PhysicsTools/PatAlgos/test/runtestPhysicsToolsPatAlgos.cpp
+++ /dev/null
@@ -1,3 +0,0 @@
-#include "FWCore/Utilities/interface/TestHelper.h"
-
-RUNTEST()
diff --git a/PhysicsTools/PatAlgos/test/runtests.sh b/PhysicsTools/PatAlgos/test/runtests.sh
deleted file mode 100755
index 18eb473..0000000
--- a/PhysicsTools/PatAlgos/test/runtests.sh
+++ /dev/null
@@ -1,42 +0,0 @@
-#!/bin/sh
-
-function die { echo $1: status $2 ;  exit $2; }
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_standard_cfg.py || die 'Failure using patTuple_standard_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_PF2PAT_cfg.py || die 'Failure using patTuple_PF2PAT_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_PATandPF2PAT_cfg.py || die 'Failure using patTuple_PATandPF2PAT_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_pfIso_cfg.py || die 'Failure using patTuple_pfIso_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_addDecayInFlight_cfg.py || die 'Failure using patTuple_addDecayInFlight_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_addBTagging_cfg.py || die 'Failure using patTuple_addBTagging_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_addJets_cfg.py || die 'Failure using patTuple_addJets_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_addTracks_cfg.py || die 'Failure using patTuple_addTracks_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_addTriggerInfo_cfg.py || die 'Failure using patTuple_addTriggerInfo_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_addVertexInfo_cfg.py || die 'Failure using patTuple_addVertexInfo_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_caloTaus_cfg.py || die 'Failure using patTuple_caloTaus_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_fastsim_cfg.py || die 'Failure using patTuple_fastsim_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_topSelection_cfg.py || die 'Failure using patTuple_topSelection_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_userData_cfg.py || die 'Failure using patTuple_userData_cfg.py' $?
-
-cmsRun ${LOCAL_TEST_DIR}/patTuple_metUncertainties_cfg.py || die 'Failure using patTuple_metUncertainties_cfg.py' $?
-
-# Not needed in IBs
-# cmsRun ${LOCAL_TEST_DIR}/patTuple_factorisedTaginfo_cfg.py || die 'Failure using patTuple_factorisedTaginfo_cfg.py' $?
-# cmsRun ${LOCAL_TEST_DIR}/patTuple_onlyElectrons_cfg.py || die 'Failure using patTuple_onlyElectrons_cfg.py' $?
-# cmsRun ${LOCAL_TEST_DIR}/patTuple_onlyJets_cfg.py || die 'Failure using patTuple_onlyJets_cfg.py' $?
-# cmsRun ${LOCAL_TEST_DIR}/patTuple_onlyMET_cfg.py || die 'Failure using patTuple_onlyMET_cfg.py' $?
-# cmsRun ${LOCAL_TEST_DIR}/patTuple_onlyMuons_cfg.py || die 'Failure using patTuple_onlyMuons_cfg.py' $?
-# cmsRun ${LOCAL_TEST_DIR}/patTuple_onlyPhotons_cfg.py || die 'Failure using patTuple_onlyPhotons_cfg.py' $?
-# cmsRun ${LOCAL_TEST_DIR}/patTuple_onlyTaus_cfg.py || die 'Failure using patTuple_onlyTaus_cfg.py' $?
